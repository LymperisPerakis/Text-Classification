                                                                 ATA6614Q
          32K Flash Microcontroller with LIN Transceiver, 5V
                                                Regulator and Watchdog
                                                                    DATASHEET
General Features
● Single-package fully-integrated AVR® 8-bit microcontroller with LIN transceiver,
  5V regulator (85mA current capability) and watchdog
● Very low current consumption in sleep mode
● 32Kbytes flash memory for application program
● Supply voltage up to 40V
● Operating voltage: 5V to 27V
● Temperature range: Tcase –40°C to +125°C
● QFN48, 7mm  7mm package
                                                                    9240I-AUTO-03/16


1. Description
   Atmel® ATA6614Q is a system-in-package (SiP) product, which is particularly suited for complete LIN-bus slave-node
   applications. It consists of two ICs in one package supporting highly integrated solutions for in-vehicle LIN networks. The first
   chip is the LIN-system-basis-chip (LIN-SBC) Atmel ATA6630, which has an integrated LIN transceiver, a 5V regulator
   (85mA) and a window watchdog. The second chip is an automotive microcontroller from Atmel’s series of AVR® 8-bit
   microcontroller with advanced RISC architecture and 32Kbytes of flash (Atmel ATmega328P). All pins of the AVR
   microcontroller and almost all pins of the LIN System Basis Chip are bonded out to provide customers the same flexibility for
   their applications as they have when using discrete parts.
   The Atmel ATA6614Q is pin compatible to the Atmel ATA6612P/ATA6613P.
   In Section 2. “Pin Configuration” on page 3 you will find the pin configuration for the complete SiP. In Section 3. “Absolute
   Maximum Ratings” on page 5 to Section 5. “Microcontroller Block” on page 30 the LIN SBC is described, and in Section 7.
   “Ordering Information” on page 307 the AVR is described in detail.
   Figure 1-1. Application Diagram
                                                                                          LIN Bus
                                           Atmel ATA6614Q
                                                   MCU               LIN-SBC
                                                   Atmel              Atmel
                                               ATmega328P            ATA6630
2  ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


2.   Pin Configuration
     Figure 2-1. Pinning QFN48, 7mm  7mm
                                                          PB4
                                                          PB3
                                                          PB2
                                                          PB1
                                                          PB0
                                                          PD7
                                                          PD6
                                                          PD5
                                                          PB7
                                                          PB6
                                                          MCUVCC
                                                          GND2
                                                          48 47 46 45 44 43 42 41 40 39 38 37
                                              PB5     1                                     36   MCUVCC
                                          MCUAVCC     2                                    35    GND1
                                             ADC6     3                                    34    PD4
                                             AREF     4                                    33    PD3
                                             GND4     5                                    32    LIN
                                             ADC7     6                                    31    GND
                                              PC0     7                                    30    WAKE
                                              PC1     8                                    29    NTRIG
                                              PC2     9                                    28    EN
                                              PC3     10                                   27    VS
                                              PC4     11                                   26    VCC
                                              PC5     12                                 25      PVCC
                                                       13 14 15 16 17 18 19 20 21 22 23 24
                                                             PC6
                                                             PD0
                                                             PD1
                                                             PD2
                                                             RXD
                                                              INH
                                                             TXD
                                                            NRES
                                                          WD_OSC
                                                               TM
                                                            MODE
                                                            KL_15
     Table 2-1.       Pin Description
          Pin           Symbol       Function
           1              PB5        Port B 5 I/O line (SCK / PCINT5)
                                     Microcontroller ADC-unit supply voltage (referred to as AVCC pin in Section 5. “Microcontroller
           2           MCUAVCC
                                     Block” on page 30)
           3             ADC6        ADC input channel 6
           4             AREF        Analog reference voltage input
           5              GND        Ground
           6             ADC7        ADC input channel 7
           7              PC0        Port C 0 I/O line (ADC0/PCINT8)
           8              PC1        Port C 1 I/O line (ADC1/PCINT9)
           9              PC2        Port C 2 I/O line (ADC2/PCINT10)
          10              PC3        Port C 3 I/O line (ADC3/PCINT11)
          11              PC4        Port C 4 I/O line (ADC4/SDA/PCINT12)
          12              PC5        Port C 5 I/O line (ADC5/SCL/PCINT13)
          13              PC6        Port C 6 I/O line (RESET/PCINT14)
          14              PD0        Port D 0 I/O line (RXD/PCINT16)
          15              PD1        Port D 1 I/O line (TXD/PCINT17)
          16              PD2        Port D 2 I/O line (INT0/PCINT18)
         17(1)            RXD        Receive data output
           (1)
        18                INH         High side switch output for controlling an external voltage regulator
     Note:       1.   This identifies the pins of the LIN SBC ATA6630
                                                                                                  ATA6614Q [DATASHEET]             3
                                                                                                              9240I–AUTO–03/16


  Table 2-1.     Pin Description (Continued)
        Pin         Symbol        Function
          (1)
       19             TXD         Transmit data input, active low output (strong pull down)
          (1)
       20            NRES         Watchdog and undervoltage reset output (open drain)
          (1)
       21          WD_OSC         External resistor for adjustable watchdog timing
       22(1)           TM         Tie to Ground – for factory use only
          (1)
       23            MODE         Connect to GND for normal watchdog operation or connect to VCC for disabling the watchdog
          (1)
       24            KL_15        Ignition detection (edge sensitive)
          (1)
       25            PVCC         Voltage regulator sense input
       26(1)          VCC         Voltage regulator output
          (1)
       27              VS         Battery supply voltage
          (1)
       28              EN         Enables the device into normal mode
          (1)
       29            NTRIG        Watchdog trigger input (negative edge)
       30(1)         WAKE         High voltage input for local wake-up request
          (1)
       31            AGND         Analog system GND
          (1)
       32              LIN        LIN bus input/output
        33            PD3         Port D 3 I/O line (INT1 OC2B/PCINT19)
        34            PD4         Port D 4 I/O line (T0/XCK/PCINT20)
        35           GND1         Ground
                                  Microcontroller supply voltage (referred to as VCC pin in Section 5. “Microcontroller Block” on
        36         MCUVCC
                                  page 30)
        37           GND2         Ground
                                  Microcontroller supply voltage (referred to as VCC pin in Section 5. “Microcontroller Block” on
        38         MCUVCC
                                  page 30)
        39            PB6         Port B 6 I/O line (TOSC1/XTAL1/PCINT6)
        40            PB7         Port B 7 I/O line (TOSC2/XTAL2/PCINT7)
        41            PD5         Port D 5 I/O line (T1/OC0B/PCINT21)
        42            PD6         Port D 6 I/O line (AIN0/OC0A PCINT22)
        43            PD7         Port D 7 I/O line (AIN1/PCINT23)
        44            PB0         Port B 0 I/O line (ICP1/CLKO/PCINT0)
        45            PB1         Port B 1 I/O line (OC1A/PCINT1)
        46            PB2         Port B 2 I/O line (OC1B/SS/PCINT2)
        47            PB3         Port B 3 I/O line (MOSI/OC2A/PCINT3)
        48            PB4         Port B 4 I/O line (MISO/PCINT4)
    Backside                      Heat slug is connected to GND
   Note:      1.  This identifies the pins of the LIN SBC ATA6630
4 ATA6614Q [DATASHEET]
  9240I–AUTO–03/16


3.       Absolute Maximum Ratings
Table 3-1.     Maximum Ratings of the SiP
Stresses beyond those listed under “Absolute Maximum Ratings” may cause permanent damage to the device. This is a stress rating
only and functional operation of the device at these or any other conditions beyond those indicated in the operational sections of this
specification is not implied. Exposure to absolute maximum rating conditions for extended periods may affect device reliability.
 Parameters                                              Symbol            Min.            Typ.             Max.             Unit
 HBM ESD
 ANSI/ESD-STM5.1
                                                                             ±2                                               KV
 JESD22-A114
 AEC-Q100 (002)
 CDM ESD STM 5.3.1                                                         ±750                                                V
 Machine Model ESD AEC-Q100-Rev.F (003)                                    ±100                                                V
 ESD according to IBEE LIN EMC
 Test Spec. 1.0 following IEC 61000-4-2
 - Pin VS, LIN to GND                                                        ±8                                               KV
 - Pin WAKE (2.7k serial resistor) to GND
 - KL_15 (47k/100nF) to GND
 ESD HBM following STM5.1 with 1.5k 100pF
                                                                             ±6                                               KV
 - Pin VS, LIN, KL_15, WAKE to GND
 Storage temperature                                        Ts              –55                             +150              °C
 Operating temperature(1)                                  Tcase            –40                             +125              °C
 Thermal resistance junction to heat slug                  Rthjc                             5                               K/W
 Thermal resistance junction to ambient                    Rthja                            25                               K/W
 Thermal shutdown of VCC regulator                                          150            165              170               °C
 Thermal shutdown of LIN output                                             150            165              170               °C
 Thermal shutdown hysteresis                                                                10                                °C
 Note:     1. Tcase means the temperature of the heat slug (backside). It is mandatory that this backside temperature is ≤ 125°C in
                the application.
Table 3-2.     Maximum Ratings of the LIN-SBC
Stresses beyond those listed under “Absolute Maximum Ratings” may cause permanent damage to the device. This is a stress rating
only and functional operation of the device at these or any other conditions beyond those indicated in the operational sections of this
specification is not implied. Exposure to absolute maximum rating conditions for extended periods may affect device reliability.
 Parameters                                              Symbol            Min.            Typ.             Max.             Unit
 Supply voltage VS                                          VS             –0.3                             +40                V
 Pulse time ≤ 500ms; Ta = 25°C
                                                            VS                                              +40                V
 Output current IVCC ≤ 85mA
 Pulse time ≤ 2min; Ta = 25°C
                                                            VS                                               27                V
 Output current IVCC ≤ 85mA
 WAKE (with 2.7k serial resistor)
 KL_15 (with 47k/100nF)                                                     –1                             +40                V
 DC voltage                                                                –150                            +100                V
 Transient voltage due to ISO7637 (coupling 1nF)
 INH
 - DC voltage                                                              –0.3                           VS + 0.3             V
 LIN
 - DC voltage                                                               –27                             +40                V
                                                                                               ATA6614Q [DATASHEET]                   5
                                                                                                             9240I–AUTO–03/16


Table 3-2.     Maximum Ratings of the LIN-SBC (Continued)
Stresses beyond those listed under “Absolute Maximum Ratings” may cause permanent damage to the device. This is a stress rating
only and functional operation of the device at these or any other conditions beyond those indicated in the operational sections of this
specification is not implied. Exposure to absolute maximum rating conditions for extended periods may affect device reliability.
 Parameters                                              Symbol            Min.            Typ.             Max.             Unit
 Logic pins (RXD, TXD, EN, NRES, NTRIG,
                                                                           –0.3                          VCC + 0.5            V
 WD_OSC, MODE, TM)
 Output current NRES                                      INRES                                              +2              mA
 PVCC DC voltage                                                           –0.3                             +5.5              V
 VCC DC voltage                                                            –0.3                             +6.5              V
Table 3-3.     Maximum Ratings of the Microcontroller
Stresses beyond those listed under “Absolute Maximum Ratings” may cause permanent damage to the device. This is a stress rating
only and functional operation of the device at these or any other conditions beyond those indicated in the operational sections of this
specification is not implied. Exposure to absolute maximum rating conditions for extended periods may affect device reliability.
 Parameters                                              Symbol            Min.            Typ.             Max.             Unit
 Voltage on any Pin except RESET with respect to                                                        MCUVCC +
                                                                           –0.5                                               V
 Ground                                                                                                      0.5
 Voltage on RESET with respect to Ground                                   –0.5                             13.0              V
 Maximum Operating Voltage                                                                                   6.0              V
 DC Current per I/O Pin                                                                                     40.0             mA
 DC Current MCUVCC and GND Pins                                                                            200.0             mA
                                     (1)
 Injection Current at MCUVCC = 0V                                                                           ±5.0             mA
 Injection Current at MCUVCC = 5V                                                                           ±1.0             mA
 Note:     1. Maximum current per port = ±30mA
6         ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


4.  LIN System-basis-chip Block
4.1 Features
      ●    Master and slave operation possible
      ●    Supply voltage up to 40V
      ●    Operating voltage VS = 5V to 27V
      ●    Typically 10µA supply current during sleep mode
      ●    Typically 35µA supply current in silent mode
      ●    Linear low-drop voltage regulator, 85mA current capability:
              ●     Normal, fail-safe, and silent mode
                       ●   VCC = 5.0V ±2%
              ●     In sleep mode VCC is switched off
      ●    VCC undervoltage detection (4ms reset time) and watchdog reset logical combined at open drain output NRES
      ●    Negative trigger input for watchdog
      ●    Adjustable watchdog time via external resistor
      ●    Boosting the voltage regulator possible with an external NPN transistor
      ●    LIN physical layer according to LIN 2.0, 2.1 and SAEJ2602-2
      ●    Wake-up capability via LIN-bus, wake pin, or Kl_15 pin
      ●    INH output to control an external voltage regulator or to switch off the master pull up resistor
      ●    TXD time-out timer
      ●    Bus pin is overtemperature and short-circuit protected versus GND and battery
      ●    Advanced EMC and ESD performance
      ●    Fulfills the OEM “Hardware Requirements for LIN in Automotive Applications Rev.1.1”
      ●    Interference and damage protection according to ISO7637
4.2 Description
    The Atmel® ATA6630 is a fully integrated LIN transceiver, which complies with the LIN 2.0, 2.1 and SAEJ2602-2
    specifications. It has a low-drop voltage regulator for 5V/85mA output and a window watchdog. The voltage regulator is able
    to source up to 85mA, but the output current can be boosted by using an external NPN transistor. The Atmel ATA6630 is
    designed to handle the low-speed data communication in vehicles, e.g., in convenience electronics. Improved slope control
    at the LIN-driver ensures secure data communication up to 20kBaud. Sleep Mode and Silent Mode guarantee very low
    current consumption.
                                                                                           ATA6614Q [DATASHEET]               7
                                                                                                           9240I–AUTO–03/16


  Figure 4-1. Block Diagram SBC
                                                                                                                       VS
                          Normal and
                           Fail-safe
      INH                    Mode
                    PVCC                       Receiver                                  Normal
                                                                                          Mode
                                                     -
     RXD
                                                     +
                                                                                           RF Filter                   LIN
    WAKE
                            Edge             Wake-up
    KL_15
                           Detection         Bus Timer
            PVCC                                                                               Short Circuit and
                                                                                               Overtemperature
                                                        Slew Rate Control                          Protection
                             TXD
     TXD                   Time-out
                             Timer
                                                           Control Unit
                                                                              Normal/Silent/                           VCC
                                                                             Fail-safe Mode
                           Debounce                                                5V                                  PVCC
       EN                    Time                         Mode Select
                                                                              Undervoltage
                                                                                  Reset                                NRES
                                                                             OUT                           Adjustable
                                    Internal Testing
                                                                      Watchdog                             Watchdog    WD_OSC
                                          Unit
                                                                                                            Oscillator
     GND
                                                             PVCC
                                     MODE      TM                       NTRIG
8 ATA6614Q [DATASHEET]
  9240I–AUTO–03/16


4.3   Functional Description
4.3.1 Physical Layer Compatibility
      Since the LIN physical layer is independent from higher LIN layers (e.g., the LIN protocol layer), all nodes with a LIN physical
      layer according to revision 2.x can be mixed with LIN physical layer nodes, which are, according to older versions (i.e., LIN
      1.0, LIN 1.1, LIN 1.2, LIN 1.3), without any restrictions.
4.3.2 Supply Pin (VS)
      The LIN operating voltage is VS = 5V to 27V. An undervoltage detection is implemented to disable data transmission if VS
      falls below VSth in order to avoid false bus messages. After switching on VS, the IC starts in fail-safe mode, and the voltage
      regulator is switched on (5V/85mA output capability).
      The supply current is typically 10µA in sleep mode and 35µA in silent mode.
4.3.3 Ground Pin (GND)
      The IC does not affect the LIN Bus in the event of GND disconnection. It is able to handle a ground shift up to 11.5% of
      versus The mandatory system ground is pin 5.
4.3.4 Voltage Regulator Output Pin (VCC)
      The internal 3.3V/5V voltage regulator is capable of driving loads up to 50mA. It is able to supply the microcontroller and
      other ICs on the PCB and is protected against overloads by means of current limitation and overtemperature shut-down.
      Furthermore, the output voltage is monitored and will cause a reset signal at the NRES output pin if it drops below a defined
      threshold Vthun. To boost up the maximum load current, an external NPN transistor may be used, with its base connected to
      the VCC pin and its emitter connected to PVCC.
4.3.5 Voltage Regulator Sense Pin (PVCC)
      The PVCC is the sense input pin of the 5V voltage regulator. For normal applications (i.e., when only using the internal
      output transistor), this pin must be connected to the VCC pin. If an external boosting transistor is used, the PVCC pin must
      be connected to the output of this transistor, i.e., its emitter terminal.
4.3.6 Bus Pin (LIN)
      A low-side driver with internal current limitation and thermal shutdown and an internal pull-up resistor compliant with the LIN
      2.x specification are implemented. The allowed voltage range is between –27V and +40V. Reverse currents from the LIN
      bus to VS are suppressed, even in the event of GND shifts or battery disconnection. LIN receiver thresholds are compatible
      with the LIN protocol specification. The fall time from recessive to dominant bus state and the rise time from dominant to
      recessive bus state are slope controlled.
4.3.7 Input/Output Pin (TXD)
      In normal mode the TXD pin is the microcontroller interface used to control the state of the LIN output. TXD must be pulled to
      ground in order to have a low LIN-bus. If TXD is high or not connected (internal pull-up resistor), the LIN output transistor is
      turned off, and the bus is in recessive state. During Fail-safe Mode, this pin is used as output and is signalling the fail-safe
      source (together with the RXD output). It is current-limited to < 8mA.
4.3.8 TXD Dominant Time-out Function
      The TXD input has an internal pull-up resistor. An internal timer prevents the bus line from being driven permanently in
      dominant state. If TXD is forced to low for longer than tDOM > 27ms, the LIN-bus driver is switched to recessive state.
      Nevertheless, when switching to sleep mode, the actual level at the TXD pin is relevant.
      To reactivate the LIN bus driver, switch TXD to high (> 10µs).
                                                                                              ATA6614Q [DATASHEET]                     9
                                                                                                              9240I–AUTO–03/16


4.3.9  Output Pin (RXD)
       This output pin reports the state of the LIN-bus to the microcontroller. LIN high (recessive state) is reported by a high level at
       RXD; LIN low (dominant state) is reported by a low level at RXD. The output has an internal pull-up resistor with typically
       5k to PVCC. The AC characteristics can be defined with an external load capacitor of 20pF.
       The output is short-circuit protected. RXD is switched off in Unpowered Mode (i.e., VS = 0V).
       During Fail-safe Mode it is signalling the fail-safe source (together with the TXD- pin).
4.3.10 Enable Input Pin (EN)
       The Enable Input pin controls the operation mode of the device. If EN is high, the circuit is in Normal Mode, with transmission
       paths from TXD to LIN and from LIN to RXD both active. The VCC voltage regulator operates with 5V/85mA output
       capability.
       If EN is switched to low while TXD is still high, the device is forced to Silent Mode. No data transmission is then possible, and
       the current consumption is reduced to IVSsilent typ. 35µA. The VCC regulator has its full functionality.
       If EN is switched to low while TXD is low, the device is forced to Sleep Mode. No data transmission is possible, and the
       voltage regulator is switched off.
4.3.11 Wake Input Pin (WAKE)
       The WAKE Input pin is a high-voltage input used to wake up the device from Sleep Mode or Silent Mode. It is usually
       connected to an external switch in the application to generate a local wake-up. A pull-up current source, typically 10µA, is
       implemented.
       If a local wake-up is not needed in the application, connect the WAKE pin directly to the VS pin.
4.3.12 Mode Input Pin (MODE)
       Connect the MODE pin directly or via an external resistor to GND for normal watchdog operation. To debug the software of
       the connected microcontroller, connect the MODE pin to VCC and the watchdog is switched off.
4.3.13 TM Input Pin
       The TM pin is used for final production measurements at Atmel®. In normal application, it has to be always connected to
       GND.
4.3.14 KL_15 Pin
       The KL_15 pin is a high-voltage input used to wake up the device from Sleep or Silent Mode. It is an edge-sensitive pin (low-
       to-high transition). It is usually connected to ignition to generate a local wake-up in the application when the ignition is
       switched on. Although KL_15 pin is at high voltage (VBatt), it is possible to switch the IC into Sleep or Silent Mode. Connect
       the KL_15 pin directly to GND if you do not need it. A debounce timer with a typical TdbKl_15 of 160µs is implemented.
       The input voltage threshold can be adjusted by varying the external resistor due to the input current IKL_15. To protect this pin
       against voltage transients, a serial resistor of 47k and a ceramic capacitor of 100nF are recommended. With this RC
       combination you can increase the wake-up time TwKL_15 and, therefore, the sensitivity against transients on the ignition
       KL_15.
       The wake-up time can also be increased by using external capacitors with higher values.
4.3.15 INH Output Pin
       The INH Output pin is used to switch on an external voltage regulator during Normal and Fail-safe Mode. The INH Output is
       a high-side switch, which is switched-off in Sleep and Silent Mode. It is possible to switch off the external 1k master resistor
       via the INH pin for master node applications.
4.3.16 Wake-up Events from Sleep or Silent Mode
          ●    LIN-bus
          ●    WAKE pin
          ●    EN pin
          ●    KL_15
10     ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


4.3.17    Reset Output Pin (NRES)
       The Reset Output pin, an open drain output, switches to low during VCC undervoltage or a watchdog failure.
4.3.18 WD_OSC Output Pin
       The WD_OSC Output pin provides a typical voltage of 1.2V, which supplies an external resistor with values between 34k
       and 120k to adjust the watchdog oscillator time.
4.3.19 NTRIG Input Pin
       The NTRIG Input pin is the trigger input for the window watchdog. A pull-up resistor is implemented.
       A negative edge triggers the watchdog. The trigger signal (low) must exceed a minimum time ttrigmin to generate a watchdog
       trigger.
4.4    Modes of Operation
       Figure 4-2. Modes of Operation
                                                         Unpowered Mode                            a: VS > 5V
                                                             VBatt = 0V                            b: VS < 4V
                                                                                                   c: Bus wake-up event
                                                                                                   d: Wake up from WAKE or KL_15 pin
                                                            b            a                         e: NRES switches to low
                                                           Fail-safe Mode                b
                                     b                        VCC: 5V                                  b
                                                    With undervoltage monitoring
                                                       Communication: OFF                   c+d+e
                                        e                  Watchdog: ON
                                        EN = 1                                    EN = 1
                                                                                   c+d
                                                        Go to silent command
                                           EN = 0                                                        Silent Mode
                                          TXD = 1                                                         VCC: 5V
                                                         Local wake-up event                   With undervoltage monitoring
                       Normal Mode         EN = 1
                                                                                                   Communication: OFF
                          VCC: 5V                                                                      Watchdog: OFF
                      With undervoltage
                         monitoring
                                                        Go to sleep command
                                           EN = 0                                          Sleep Mode
                    Communication: ON
                       Watchdog: ON       TXD = 0                                        VCC: switched off
                                                                                       Communication: OFF
                                                                                          Watchdog: OFF
       Table 4-1.     Table of Modes
            Mode of
           Operation        Transceiver         Pin LIN                VCC       Pin Mode       Watchdog          Pin WD_OSC          Pin INH
           Unpowered              Off          Recessive                On         GND                On                 On             Off
            Fail-safe             Off          Recessive                5V         GND                On                1.23V           On
             Normal               On        TXD depending               5V         GND                On                1.23V           On
             Silent               Off          Recessive                5V         GND                Off                0V             Off
             Sleep                Off          Recessive                0V         GND                Off                0V             Off
                                                                                                   ATA6614Q [DATASHEET]                     11
                                                                                                                     9240I–AUTO–03/16


4.4.1 Normal Mode
      This is the normal transmitting and receiving mode. The voltage regulator is active and can source up to 85mA. The
      undervoltage detection is activated. The watchdog needs a trigger signal from NTRIG to avoid resets at NRES. If NRES is
      switched to low, the IC changes its state to Fail-safe Mode.
4.4.2 Silent Mode
      A falling edge at EN when TXD is high switches the IC into Silent Mode. The TXD Signal has to be logic high during the
      Mode Select window (see Figure 4-3 on page 12). The transmission path is disabled in Silent Mode. The INH output is
      switched off and the voltage divider is enabled. The overall supply current from VBatt is a combination of the IVSsi = 35µA plus
      the VCC regulator output current IVCC.
      The 5V regulator with 2% tolerance can source up to 85mA. The internal slave termination between the LIN pin and the VS
      pin is disabled in Silent Mode to minimize the current consumption in the event that the LIN pin is short-circuited to GND.
      Only a weak pull-up current (typically 10µA) between the LIN pin and the VS pin is present. Silent Mode can be activated
      independently from the actual level on the LIN, WAKE, or KL_15 pins. If an undervoltage condition occurs, NRES is switched
      to low and the IC changes its state to Fail-safe Mode.
      A voltage lower than the LIN Pre_Wake detection VLINL at the LIN pin activates the internal LIN receiver and starts the
      wake-up detection timer.
      Figure 4-3. Switch to Silent Mode
                                    Normal Mode
                                                                                              Silent Mode
                                 EN
                                                                 Mode select window
                                TXD
                                                           td = 3.2μs
                              NRES
                               VCC
                                                          Delay time silent mode
                                                        td_sleep = maximum 20μs
                                 LIN
                                                      LIN switches directly to recessive mode
12    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


A falling edge at the LIN pin followed by a dominant bus level maintained for a certain time period (>tbus) and followed by a
rising edge at the LIN pin (see Figure 4-4 on page 13) result in a remote wake-up request which is only possible if TXD is
high. The device switches from Silent Mode to Fail-safe Mode. The internal LIN slave termination resistor is switched on. The
remote wake-up request is indicated by a low level at the RXD pin to interrupt the microcontroller (see Figure 4-4 on page
13). EN high can be used to switch directly to Normal Mode.
Figure 4-4. LIN Wake Up from Silent Mode
                                Bus wake-up filtering time
                                              tbus                              Fail-safe mode           Normal mode
                 LIN bus
                           Node in silent mode
                     RXD                      High                                     Low                 High
                    TXD
               Watchdog                  Watchdog off                       Start watchdog lead time td
                  VCC
                 voltage                  Silent mode 5V                        Fail safe mode 5V       Normal mode
                regulator
                                                                                                         EN High
                      EN
                   NRES                                 Undervoltage detection active
                                                                                                ATA6614Q [DATASHEET]        13
                                                                                                           9240I–AUTO–03/16


4.4.3 Sleep Mode
      A falling edge at EN when TXD is low switches the IC into Sleep Mode. The TXD Signal has to be logic low during the Mode
      Select window (Figure 4-5 on page 14). In order to avoid any influence to the LIN-pin during switching into sleep mode it is
      possible to switch the EN up to 3.2µs earlier to Low than the TXD. Therefore, the best an easiest way are two falling edges
      at TXD and EN at the same time. The transmission path is disabled in Sleep Mode. The supply current IVSsleep from VBatt is
      typically 10µA.
      The INH output and the VCC regulator are switched off. NRES and RXD are low. The internal slave termination between the
      LIN pin and VS pin is disabled to minimize the current consumption in the event that the LIN pin is short-circuited to GND.
      Only a weak pull-up current (typically 10µA) between the LIN pin and the VS pin is present. Sleep Mode can be activated
      independently from the current level on the LIN, WAKE, or KL_15 pin.
      A voltage lower than the LIN Pre_Wake detection VLINL at the LIN pin activates the internal LIN receiver and starts the
      wake-up detection timer.
      Figure 4-5. Switch to Sleep Mode
                                   Normal Mode                                               Sleep Mode
                               EN
                                                                 Mode select window
                              TXD
                                                          td = 3.2μs
                             NRES
                              VCC
                                                         Delay time sleep mode
                                                        td_sleep = maximum 20μs
                               LIN
                                                       LIN switches directly to recessive mode
14    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


A falling edge at the LIN pin followed by a dominant bus level maintained for a certain time period (>tbus) and a rising edge at
pin LIN result in a remote wake-up request. The device switches from Sleep Mode to Fail-safe Mode.
The VCC regulator is activated, and the internal LIN slave termination resistor is switched on. The remote wake-up re-quest
is indicated by a low level at the RXD pin to interrupt the microcontroller (see Figure 4-6 on page 15).
EN high can be used to switch directly from Sleep/Silent to Fail-safe Mode. If EN is still high after VCC ramp up and
undervoltage reset time, the IC switches to the Normal Mode.
Figure 4-6. LIN Wake Up from Sleep Mode
                                 Bus wake-up filtering time
                                           tbus                           Fail-safe Mode            Normal Mode
                 LIN bus
                     RXD                                                        Low
                  TXD
                  VCC                                                           On state
                 voltage                     Off state
                regulator
                                                                    Regulator wake-up time
                                                                                                    EN High
                      EN
                                                                   Reset
                                                                    time
                   NRES
                                                                                  Microcontroller
                                                                                start-up time delay
               Watchdog               Watchdog off                   Start watchdog lead time td
                                                                                            ATA6614Q [DATASHEET]             15
                                                                                                       9240I–AUTO–03/16


4.4.4 Sleep or Silent Mode: Behavior at a Floating LIN-bus or a Short Circuited LIN to GND
      In Sleep or in Silent Mode the device has a very low current consumption even during short-circuits or floating conditions on
      the bus. A floating bus can arise if the Master pull-up resistor is missing, e.g., if it is switched off when the LIN-Master is in
      sleep mode or even if the power supply of the Master node is switched off.
      In order to minimize the current consumption IVS in sleep or silent mode during voltage levels at the LIN-pin below the LIN
      pre-wake threshold, the receiver is activated only for a specific time tmon. If tmon elapses while the voltage at the bus is lower
      than the Pre-wake detection low (VLINL) and higher than the LIN dominant level, the receiver is switched off again and the
      circuit changes back to sleep respectively Silent Mode. The current consumption is then IVSsleep_short or IVSsilent_short (typ. 10µA
      more than IVSsleep respectively IVSsilent). If a dominant state is reached on the bus no wake-up will occur. Even if the voltage
      rises above the Pre-wake detection high (VLINH), the IC will stay in sleep respectively silent mode (see Figure 4-7).
      This means the LIN-bus must be above the Pre-wake detection threshold VLINH for a few microseconds before a new LIN
      wake-up is possible.
      Figure 4-7. Floating LIN-bus During Sleep or Silent Mode
                                                                                                                LIN Pre-wake
                                         VLINL
                           LIN BUS
                                                                                                          LIN dominant state
                                         VBUSdom
                                                                        tmon
                                                                                        IVSsleep_short/
                                                                       IVSfail          IVSsilent_short
                                 IVS
                                         IVSsleep/silent                                                 IVSsleep / IVSsilent
                            Mode of
                           operation  Sleep/Silent Mode     Wake-up Detection Phase            Sleep/Silent Mode
                         Int. Pull-up
                           Resistor                                off (disabled)
                             RLIN
16    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


      If the Atmel® ATA6630 is in Sleep or Silent Mode and the voltage level at the LIN-bus is in dominant state (VLIN < VBUSdom) for
      a time period exceeding tmon (during a short circuit at LIN, for example), the IC switches back to Sleep Mode respectively
      Silent Mode. The VS current consumption then is IVSsleep_short or IVSsilent_short (typ. 10µA more than IVSsleep respectively IVSsilent).
      After a positive edge at pin LIN the IC switches directly to Fail-safe Mode (see Figure 4-8 on page 17).
      Figure 4-8. Short Circuit to GND on the LIN bus During Sleep- or Silent Mode
                                                                                                              LIN Pre-wake
                                        VLINL
                           LIN BUS
                                                                                                         LIN dominant state
                                        VBUSdom
                                                                            tmon
                                                                     tmon
                                                                    IVSfail           IVSsleep_short /
                                IVS                                                  IVSsilent_short
                                         IVSsleep/silent
                           Mode of
                                     Sleep/Silent Mode   Wake-up Detection Phase     Sleep/Silent       Fail-Safe Mode
                          operation
                                                                                          Mode
                        Int. Pull-up
                          Resistor                        off (disabled)                                on (enabled)
                            RLIN
4.4.5 Fail-safe Mode
      The device automatically switches to Fail-safe Mode at system power-up. The voltage regulator is switched on (see Figure
      4-12 on page 21). The NRES output switches to low for tres = 4ms and gives a reset to the microcontroller. The LIN
      communication is switched off. The IC stays in this mode until EN is switched to high. The IC then changes to Normal Mode.
      A power down of VBatt (VS < VSthU) during Silent or Sleep Mode switches the IC into Fail-safe Mode after power up. A low
      level at NRES switches into Fail-safe Mode directly. During Fail-safe Mode, the TXD pin is an output and signals the fail-safe
      source (together with the RXD output).
      The LIN SBC can operate in different Modes, like Normal, Silent, or Sleep Mode. The functionality of these modes is
      described in Table 4-2.
      Table 4-2.     TXD, RXD Depending from Operation Modes
        Different Modes                                                TXD                                             RXD
        Fail-safe Mode                                                   Signalling fail-safe sources (see Table 4-3)
        Normal Mode                                                               Follows data transmission
        Silent Mode                                                    High                                            High
      A wake-up event from either Silent or Sleep Mode will be signalled to the microcontroller using the two pins RXD and TXD.
      The coding is shown in Table 4-3 on page 18.
      A wake-up event will lead the IC to the Fail-safe Mode.
                                                                                                      ATA6614Q [DATASHEET]                17
                                                                                                                    9240I–AUTO–03/16


        Table 4-3.   Signalling Fail-safe Sources
         Fail-safe Sources                                                                     TXD                     RXD
         LIN wake-up (pin LIN)                                                                  Low                    Low
         Local wake-up (at pin WAKE, pin KL_15)                                                 Low                    High
         VSth (battery) undervoltage detection                                                 High                    Low
        Table 4-4.   Signalling in Fail-safe Mode after a Reset (NRES was Low), shows the Reset Source at TXD and RXD
                     Pins
         Fail-safe Source                                                                      TXD                     RXD
         VCC undervoltage                                                                      High                    Low
         Watchdog reset                                                                        High                    High
4.4.6   Unpowered Mode
        After the battery voltage has been connected to the application circuit, the voltage at the VS pin increases according to the
        block capacitor (see Figure 4-11 on page 21). After VS is higher than the VS undervoltage threshold VSthF, the IC mode
        changes from Unpowered Mode to Fail-safe Mode. The VCC output voltage reaches its nominal value after tVCC. This time,
        tVCC, depends on the externally applied VCC capacitor and the load. The NRES is low for the reset time delay
        treset. During this time, treset, no mode change is possible.
        The behavior of VCC, NRES and VS is shown in Figure 4-9 (ramp up):
        Figure 4-9. VCC and NRES versus VS (Ramp Up)
                                                 7.0
                                                 6.5
                                                 6.0
                                                 5.5
                                                 5.0
                                                                             VS
                                                 4.5
                                                 4.0
                                         V (V)   3.5
                                                 3.0
                                                 2.5
                                                 2.0
                                                 1.5
                                                                                        NRES
                                                 1.0
                                                 0.5              VCC
                                                   0
                                                       0 0.5   1.0 1.5 2.0   2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0
                                                                                   VS (V)
                                                           Unpowered Mode
18      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        Figure 4-10. VCC and NRES versus VS (Ramp Down)
                                                  7.0
                                                  6.5
                                                  6.0
                                                  5.5
                                                  5.0
                                                                                          VS
                                                  4.5
                                                  4.0
                                          V (V)   3.5
                                                  3.0
                                                  2.5
                                                  2.0
                                                  1.5
                                                                             NRES
                                                  1.0
                                                  0.5                                                VCC
                                                    0
                                                     7.0 6.5   6.0 5.5 5.0 4.5 4.0 3.5 3.0 2.5 2.0 1.5 1.0 0.5     0
                                                                                 VS (V)
                                                                                                  Unpowered Mode
        Please note that the upper graphs are only valid if the VS ramp up and ramp down-time is much slower than the VCC ramp
        up time tVcc and the NRES delay time treset.
        If during sleep or silent mode the voltage level of VS drops below the undervoltage detection threshold VSthU, the IC switches
        into Unpowered Mode.
        If during Normal Mode the voltage level of VS drops below the undervoltage detection threshold VSthU, the IC switches into
        Fail-safe Mode, this means the LIN transceiver is disabled in order to avoid malfunctions or false bus messages.
4.5     Wake-up Scenarios from Silent or Sleep Mode
4.5.1   Remote Wake-up via Dominant Bus State
        A voltage lower than the LIN Pre_Wake detection VLINL at the LIN pin activates the internal LIN receiver and starts the wake-
        up detection timer.
        A falling edge at the LIN pin followed by a dominant bus level VBUSdom maintained for a certain time period (>tBUS) and
        followed by a rising edge at pin LIN result in a remote wake-up request. A remote wake-up from Silent Mode is only possible
        if TXD is high. The device switches from Silent or Sleep Mode to Fail-safe Mode. The VCC voltage regulator is/remains
        activated, the INH pin is switched to high, and the internal slave termination resistor is switched on. The remote wake-up
        request is indicated by a low level at the RXD pin to generate an interrupt for the microcontroller and a strong pull down at
        TXD.
4.5.2   Local Wake-up via Pin WAKE
        A falling edge at the WAKE pin followed by a low level maintained for a certain time period (>tWAKE) results in a local wake-up
        request. The device switches to Fail-safe Mode. The internal slave termination resistor is switched on. The local wake-up
        request is indicated by a low level at the TXD pin to generate an interrupt for the microcontroller. When the Wake pin is low,
        it is possible to switch to Silent or Sleep Mode via pin EN. In this case, the wake-up signal has to be switched to high > 10µs
        before the negative edge at WAKE starts a new local wake-up request.
4.5.3   Local Wake-up via Pin KL_15
        A positive edge at pin KL_15 followed by a high voltage level for a certain time period (> tKL_15) results in a local wake-up
        request. The device switches into the Fail-safe Mode. The internal slave termination resistor is switched on. The extra long
        wake-up time ensures that no transients at KL_15 create a wake-up. The local wake-up request is indicated by a low level at
        the TXD pin to generate an interrupt for the microcontroller. During high-level voltage at pin KL_15, it is possible to switch to
        Silent or Sleep Mode via pin EN. In this case, the wake-up signal has to be switched to low > 250µs before the positive edge
        at KL_15 starts a new local wake-up request. With external RC combination, the time is even longer.
                                                                                                         ATA6614Q [DATASHEET]             19
                                                                                                                       9240I–AUTO–03/16


4.5.4 Wake-up Source Recognition
      The device can distinguish between different wake-up sources.
      The wake-up source can be read on the TXD and RXD pin in Fail-safe Mode. These flags are immediately reset if the
      microcontroller sets the EN pin to high (see Figure 4-4 on page 13 and Figure 4-6 on page 15) and the IC is in Normal mode.
4.5.5 Fail-safe Features
        ●    During a short-circuit at LIN to VBattery, the output limits the output current to IBUS_lim. Due to the power dissipation, the
             chip temperature exceeds TLINoff, and the LIN output is switched off. The chip cools down and after a hysteresis of
             Thys, switches the output on again. RXD stays on high because LIN is high. During LIN overtemperature switch-off,
             the VCC regulator works independently.
        ●    During a short-circuit from LIN to GND the IC can be switched into Sleep or Silent Mode and even in this case the
             current consumption is lower than 30µA in Sleep Mode and lower than 70µA in Silent Mode. If the short-circuit
             disappears, the IC starts with a remote wake-up.
        ●    Sleep or Silent Mode: During a floating condition on the bus the IC switches back to
             Sleep Mode/Silent Mode automatically and thereby the current consumption is lower
             than 30µA/70µA.
        ●    The reverse current is < 2µA at the LIN pin during loss of VBatt. This is optimal behavior for bus systems where some
             slave nodes are supplied from battery or ignition.
        ●    During a short circuit at VCC, the output limits the output current to IVCClim. Because of undervoltage, NRES switches
             to low and the IC switches into Fail-safe Mode. If the chip temperature exceeds the value TVCCoff, the VCC output
             switches off. The chip cools down and after a hysteresis of Thys, switches the output on again. Because of the Fail-
             safe Mode, the VCC voltage will switch on again although EN is switched off from the microcontroller. The
             microcontroller can start with its normal operation.
        ●    EN pin provides a pull-down resistor to force the transceiver into recessive mode if EN is disconnected.
        ●    RXD pin is set floating if VBatt is disconnected.
        ●    TXD pin provides a pull-up resistor to force the transceiver into recessive mode if TXD is disconnected.
        ●    If TXD is short-circuited to GND, it is possible to switch to Sleep Mode via ENABLE.
        ●    After switching the LIN transceiver into Normal Mode the TXD pin must be pulled to high longer than 10µs in order to
             activate the LIN driver. This feature prevents the bus from being driven into dominant state when the IC is switched
             into Normal Mode and TXD is low.
        ●    If the WD_OSC pin has a short-circuit to GND and the NTRIG Signal has a period time > 27ms a reset is guaranteed.
        ●    If the resistor at the WD_OSC pin is disconnected and the NTRIG Signal has a period time < 46ms a reset is
             guaranteed.
        ●    If there is no NTRIG signal and a short-circuit at WD_OSC to GND the NRES switches to low after 90ms. For an open
             circuit (no resistor) at WD_OSC it switches to low after 390ms.
20    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


4.6   Voltage Regulator
      The voltage regulator needs an external capacitor for compensation and for smoothing the disturbances from the
      microcontroller. It is recommended to use an electrolythic capacitor with C ≥ 1.8µF and a ceramic capacitor with C = 100nF.
      The values of these capacitors can be varied by the customer, depending on the application.
      The main power dissipation of the IC is created from the VCC output current IVCC, which is needed for the application.
      Figure 4-11. VCC Voltage Regulator: Ramp-up and Undervoltage Detection
                                VS
                               12V
                               5.5V
                                                                                                                                  t
                              VCC
                                  5V
                               Vthun
                                                          tVCC        tReset                                         tres_f       t
                             NRES
                                5V
                                                                                                                                  t
      Figure 4-12. Power Dissipation: Safe Operating Area: VCC Output Current versus Supply Voltage VS at Different
                   Ambient Temperatures
                                             90
                                             80
                                                                                                                   Tamb = 100°C
                                             70
                                             60
                                 IVCC (mA)
                                                                                                                   Tamb = 105°C
                                             50
                                                                                                                   Tamb = 110°C
                                             40
                                             30
                                                                                                                   Tamb = 115°C
                                             20
                                             10
                                              0
                                                  4   5   6   7   8   9   10 11   12    13   14 15 16   17 18 19
                                                                               VS (V)
      For programming purposes of the microcontroller it is potentially necessary to supply the VCC output via an external power
      supply while the VS Pin of the system basis chip is disconnected. This behavior will not affect the system basis chip.
                                                                                                             ATA6614Q [DATASHEET]                        21
                                                                                                                                      9240I–AUTO–03/16


4.7   Watchdog
      The watchdog anticipates a trigger signal from the microcontroller at the NTRIG (negative edge) input within a time window
      of Twd. The trigger signal must exceed a minimum time ttrigmin > 200ns. If a triggering signal is not received, a reset signal will
      be generated at output NRES. After a watchdog reset the IC starts with the lead time. The timing basis of the watchdog is
      provided by the internal oscillator. Its time period, Tosc, is adjustable via the external resistor Rwd_osc (34k to 120k).
      During Silent or Sleep Mode the watchdog is switched off to reduce current consumption.
      The minimum time for the first watchdog pulse is required after the undervoltage reset at NRES disappears. It is defined as
      lead time td. After wake up from Sleep or Silent Mode, the lead time td starts with the negative edge of the RXD output.
4.7.1 Typical Timing Sequence with RWO_OSC = 51k
      The trigger signal Twd is adjustable between 20ms and 64ms using the external resistor RWD_OSC.
      For example, with an external resistor of RWD_OSC = 51k ±1%, the typical parameters of the watchdog are as follows:
      tosc = 0.405 × RWD_OSC – 0.0004 × (RWD_OSC)2 (RWD_OSC in k ; tosc in μs)
      tOSC = 19.6μs due to 51k
      td = 7895 × 19.6μs = 155ms
      t1 = 1053 × 19.6μs = 20.6ms
      t2 = 1105 × 19.6μs = 21.6ms
      tnres = constant = 4ms
      After ramping up the battery voltage, the 5V regulator is switched on. The reset output NRES stays low for the time treset
      (typically 4ms), then it switches to high, and the watchdog waits for the trigger sequence from the microcontroller. The lead
      time, td, follows the reset and is td = 155ms. In this time, the first watchdog pulse from the microcontroller is required. If the
      trigger pulse NTRIG occurs during this time, the time t1 starts immediately. If no trigger signal occurs during the time td, a
      watchdog reset with tNRES = 4ms will reset the microcontroller after td = 155ms. The times t1 and t2 have a fixed relationship.
      A triggering signal from the microcontroller is anticipated within the time frame of t2 = 21.6ms. To avoid false triggering from
      glitches, the trigger pulse must be longer than tTRIG,min > 200ns. This slope serves to restart the watchdog sequence. If the
      triggering signal fails in this open window t2, the NRES output will be drawn to ground. A triggering signal during the closed
      window t1 immediately switches NRES to low.
      Figure 4-13. Timing Sequence with RWD_OSC=51k
                   VCC
                     5V
                             Undervoltage Reset                                                                    Watchdog Reset
                              treset = 4ms                                                                           tnres = 4ms
                 NRES
                                                      td = 155ms                              t1            t2
                                                                    t1 = 20.6ms     t2 = 21ms
                                                                                twd
                 NTRIG
                                                            ttrig > 200ns
22    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


4.7.2 Worst Case Calculation with RWO_OSC = 51k
      The internal oscillator has a tolerance of 20%. This means that t1 and t2 can also vary by 20%.
      The worst case calculation for the watchdog period twd is calculated as follows.
      The ideal watchdog time twd is between the maximum t1 and the minimum t1 plus the minimum t2.
      t1,min = 0.8 × t1 = 16.5ms, t1,max = 1.2 × t1 = 24.8ms
      t2,min = 0.8 × t2 = 17.3ms, t2,max = 1.2 × t2 = 26ms
      twdmax = t1min + t2min = 16.5ms + 17.3ms = 33.8ms
      twdmin = t1max = 24.8ms
      twd = 29.3ms ±4.5ms (±15%)
      A microcontroller with an oscillator tolerance of ±15% is sufficient to supply the trigger inputs correctly.
      Table 4-5.      Typical Watchdog Timings
       ROSC/k                    tOSC /µs          td /ms          t1 /ms             t2/ms             twd /ms          tnres /ms
       34                           13.3              105             14.0              14.7               19.9                4
       51                          19.61            154.80           20.64             21.67              29.32                4
       91                          33.54            264.80           35.32             37.06              50.14                4
       120                         42.84            338.22           45.32             47.34              64.05                4
                                                                                               ATA6614Q [DATASHEET]                 23
                                                                                                              9240I–AUTO–03/16


4.8      Electrical Characteristics
5V < VS < 27V, –40°C < Tj < 150°C, unless otherwise specified. All values refer to GND pins
  No. Parameters                   Test Conditions                 Pin      Symbol        Min. Typ.     Max.    Unit Type*
   1   VS Pin
  1.1  Nominal DC voltage range                                     VS           VS         5            27      V     A
                                   Sleep Mode
                                   VLIN > VS – 0.5V                 VS       IVSsleep       3   10       14     µA     A
       Supply current in Sleep     VS < 14V
  1.2
       Mode                        Sleep Mode, VLIN = 0V
                                   Bus shorted to GND               VS    IVSsleep_short    6   20       30     µA     A
                                   VS < 14V
                                   Bus recessive
                                   VS < 14V                         VS       IVSsilent     20   35       50     µA     A
                                   Without load at VCC
       Supply current in Silent
  1.3                              Silent Mode
       Mode
                                   VS < 14V
                                                                    VS    IVSsilent_short  25   45       70     µA     A
                                   Bus shorted to GND
                                   Without load at VCC
                                   Bus recessive
       Supply current in Normal
  1.4                              VS < 14V                         VS         IVSrec      0.3           0.8    mA     A
       Mode
                                   Without load at VCC
                                   Bus recessive
       Supply current in Normal
  1.5                              VS < 14V                         VS        IVSdom       50            53     mA     A
       Mode
                                   VCC load current 50mA
                                   Bus recessive, RXD is low
       Supply current in Fail-safe
  1.6                              VS < 14V                         VS         IVSfail          1.5      2.0    mA     A
       Mode
                                   Without load at VCC
                                   Switch to Unpowered Mode         VS         VSthU       3.7  4.2      4.7     V     A
  1.7  VS undervoltage threshold
                                   Switch to Fail-safe Mode         VS         VSthF       4.0  4.5      5.0     V     A
       VS undervoltage threshold
  1.8                                                               VS      VSth_hys            0.3              V     A
       hysteresis
   2   RXD Output Pin
                                   Normal Mode
       Low-level output sink
  2.1                              VLIN = 0V                      RXD           IRXD       1.3  2.5       8     mA     A
       current
                                   VRXD = 0.4V
  2.2  Low-level output voltage    IRXD = 1mA                     RXD         VRXDL                      0.4     V     A
  2.3  Internal resistor to PVCC                                  RXD          RRXD         3    5        7     k     A
   3   TXD Input/Output Pin
  3.1  Low-level voltage input                                     TXD        VTXDL       –0.3          +0.8     V     A
                                                                                                       VCC +
  3.2  High-level voltage input                                    TXD        VTXDH         2                    V     A
                                                                                                        0.3V
  3.3  Pull-up resistor            VTXD = 0V                       TXD         RTXD       125  250      400     k     A
  3.4  High-level leakage current VTXD = VCC                       TXD          ITXD       –3            +3     µA     A
                                   Fail-safe Mode, wake up
       Low-level output sink       VLIN = VS
  3.5                                                              TXD      ITXDwake        2   2.5       8     mA     A
       current                     VWAKE = 0V
                                   VTXD = 0.4V
*) Type means: A = 100% tested, B = 100% correlation tested, C = Characterized on samples, D = Design parameter
24       ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


4.8      Electrical Characteristics (Continued)
5V < VS < 27V, –40°C < Tj < 150°C, unless otherwise specified. All values refer to GND pins
  No. Parameters                  Test Conditions                  Pin      Symbol      Min.    Typ.    Max.      Unit  Type*
   4   EN Input Pin
  4.1  Low-level voltage input                                      EN        VENL      –0.3             +0.8       V     A
                                                                                                        VCC +
  4.2  High-level voltage input                                     EN        VENH         2                        V     A
                                                                                                         0.3V
  4.3  Pull-down resistor         VEN = VCC                         EN        REN         50     125     200       k     A
  4.4  Low-level input current    VEN = 0V                          EN         IEN        –3              +3       µA     A
   5   NTRIG Watchdog Input Pin
  5.1  Low-level voltage input                                  NTRIG       VNTRIGL     -0.3             +0.8       V     A
                                                                                                        VCC +
  5.2  High-level voltage input                                 NTRIG       VNTRIGH        2                        V     A
                                                                                                         0.3V
  5.3  Pull-up resistor           VNTRIG = 0V                   NTRIG        RNTRIG      125     250     400       k     A
  5.4  High-level leakage current VNTRIG = VCC                  NTRIG        INTRIG       -3              +3       µA     A
   6   Mode Input Pin
  6.1  Low-level voltage input                                   MODE       VMODEL      –0.3             +0.8       V     A
                                                                                                        VCC +
  6.2  High-level voltage input                                  MODE       VMODEH         2                        V     A
                                                                                                         0.3V
                                  VMODE = VCC or
  6.3  High-level leakage current                                MODE        IMODE        –3              +3       µA     A
                                  VMODE = 0V
   7   INH Output Pin
  7.1  High-level voltage         IINH = –15mA                     INH       VINHH    VS – 0.75           VS        V     A
       Switch-on resistance
  7.2                                                              INH        RINH                30      50             A
       between VS and INH
                                  Sleep Mode
  7.3  Leakage current                                             INH        IINHL       –3              +3       µA     A
                                  VINH = 0V/27V, VS = 27V
   8   LIN Bus Driver
       Driver recessive output
  8.1                             Load1/Load2                      LIN      VBUSrec   0.9  VS            VS        V     A
       voltage
                                  VVS = 7V
  8.2  Driver dominant voltage                                     LIN      V_LoSUP                       1.2       V     A
                                  Rload = 500
                                  VVS = 18V
  8.3  Driver dominant voltage                                     LIN      V_HiSUP                        2        V     A
                                  Rload = 500
                                  VVS = 7.0V
  8.4  Driver dominant voltage                                     LIN     V_LoSUP_1k    0.6                        V     A
                                  Rload = 1000
                                  VVS = 18V
  8.5  Driver dominant voltage                                     LIN     V_HiSUP_1k    0.8                        V     A
                                  Rload = 1000
                                  The serial diode is
  8.6  Pull-up resistor to VS                                      LIN        RLIN        20      30      47       k     A
                                  mandatory
       Voltage drop at the serial In pull-up path with Rslave
  8.7                                                              LIN      VSerDiode    0.4              1.0       V     D
       diodes                     ISerDiode = 10mA
       LIN current limitation
  8.8                                                              LIN      IBUS_LIM      70     120     200       mA     A
       VBUS = VBatt_max
*) Type means: A = 100% tested, B = 100% correlation tested, C = Characterized on samples, D = Design parameter
                                                                                             ATA6614Q [DATASHEET]          25
                                                                                                       9240I–AUTO–03/16


4.8      Electrical Characteristics (Continued)
5V < VS < 27V, –40°C < Tj < 150°C, unless otherwise specified. All values refer to GND pins
  No. Parameters                    Test Conditions                Pin       Symbol      Min.     Typ.      Max.    Unit Type*
                                    Input leakage current
       Input leakage current at
                                    Driver off                             IBUS_PAS_do
  8.9  the receiver including pull-                                LIN                    –1     –0.35              mA     A
                                    VBUS = 0V                                    m
       up resistor as specified
                                    VBatt = 12V
                                    Driver off
       Leakage current LIN          8V < VBatt < 18V
 8.10                                                              LIN    IBUS_PAS_rec             10        20     µA     A
       recessive                    8V < VBUS < 18V
                                    VBUS  VBatt
       Leakage current at GND
       loss, control unit
                                    GNDDevice = VS
       disconnected from ground.
  8.11                              V     = 12V                    LIN     IBUS_NO_gnd   –10      +0.5      +10     µA     A
       Loss of local ground must Batt
                                    0V < VBUS < 18V
       not affect communication
       in the residual network.
       Leakage current at loss of
       battery. Node has to
       sustain the current that     VBatt disconnected
 8.12 can flow under this           VSUP_Device = GND              LIN     IBUS_NO_bat             0.1        2     µA     A
       condition. Bus must          0V < VBUS < 18V
       remain operational under
       this condition.
       Capacitance on pin LIN to
 8.13                                                              LIN        CLIN                           20      pF    D
       GND
   9   LIN Bus Receiver
       Center of receiver           VBUS_CNT =                                         0.475 
  9.1                                                              LIN      VBUS_CNT            0.5  VS 0.525  VS  V     A
       threshold                    (Vth_dom + Vth_rec)/2                                 VS
  9.2  Receiver dominant state      VEN = VCC                      LIN       VBUSdom                      0.4  VS   V     A
  9.3  Receiver recessive state     VEN = VCC                      LIN       VBUSrec   0.6  VS                      V     A
                                                                                       0.028 
  9.4  Receiver input hysteresis Vhys = Vth_rec – Vth_dom          LIN       VBUShys            0.1  VS 0.175  VS  V     A
                                                                                          VS
       Pre_Wake detection LIN
  9.5                                                              LIN        VLINH    VS – 2V           VS + 0.3V   V     A
       High-level input voltage
       Pre_Wake detection LIN
  9.6                               Activates the LIN receiver     LIN        VLINL      –27             VS – 3.3V   V     A
       Low-level input voltage
   10  Internal Timers
       Dominant time for wake-up
 10.1                               VLIN = 0V                      LIN         tbus       30       90       150      µs    A
       via LIN bus
       Time delay for mode
 10.2 change from Fail-safe into VEN = VCC                          EN        tnorm        5       15        20      µs    A
       Normal Mode via EN pin
       Time delay for mode
 10.3 change from Normal Mode VEN = 0V                              EN        tsleep       2        7        12      µs    A
       to Sleep Mode via EN pin
       TXD dominant time-out
 10.4                               VTXD = 0V                      TXD         tdom       27       55        70     ms     A
       time
       Time delay for mode
 10.5 change from Silent Mode VEN = VCC                             EN         ts_n        5       15        40      µs    A
       into Normal Mode via EN
*) Type means: A = 100% tested, B = 100% correlation tested, C = Characterized on samples, D = Design parameter
26       ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


4.8      Electrical Characteristics (Continued)
5V < VS < 27V, –40°C < Tj < 150°C, unless otherwise specified. All values refer to GND pins
  No. Parameters                   Test Conditions                  Pin     Symbol      Min.    Typ.    Max.       Unit   Type*
       Monitoring time for wake-
 10.6                                                               LIN        tmon       6      10       15        ms      A
       up over LIN bus
       LIN Bus Driver AC Parameter with Different Bus Loads
       Load 1 (small): 1nF, 1k ; Load 2 (large): 10nF, 500 ; RRXD = 5k; CRXD = 20pF;
       Load 3 (medium): 6.8nF, 660 characterized on samples; 10.7 and 10.8 specifies the timing parameters for proper operation
       at 20Kbit/s, 10.9 and 10.10 at 10.4Kbit/s
                                   THRec(max) = 0.744  VS
                                   THDom(max) = 0.581  VS
 10.7 Duty cycle 1                 VS = 7.0V to 18V                 LIN         D1     0.396                                A
                                   tBit = 50µs
                                   D1 = tbus_rec(min)/(2  tBit)
                                   THRec(min) = 0.422  VS
                                   THDom(min) = 0.284  VS
 10.8 Duty cycle 2                 VS = 7.6V to 18V                 LIN         D2                      0.581               A
                                   tBit = 50µs
                                   D2 = tbus_rec(max)/(2  tBit)
                                   THRec(max) = 0.778  VS
                                   THDom(max) = 0.616  VS
 10.9 Duty cycle 3                 VS = 7.0V to 18V                 LIN         D3     0.417                                A
                                   tBit = 96µs
                                   D3 = tbus_rec(min)/(2  tBit)
                                   THRec(min) = 0.389  VS
                                   THDom(min) = 0.251  VS
 10.10 Duty cycle 4                VS = 7.6V to 18V                 LIN         D4                      0.590               A
                                   tBit = 96µs
                                   D4 = tbus_rec(max)/(2  tBit)
       Slope time falling and                                              tSLOPE_fall
 10.11                             VS = 7.0V to 18V                 LIN                  3.5             22.5       µs      A
       rising edge at LIN                                                  tSLOPE_rise
       Receiver Electrical AC Parameters of the LIN Physical Layer
   11
       LIN Receiver, RXD Load Conditions (CRXD): 20pF
       Propagation delay of
                                   VS = 7.0V to 18V
  11.1 receiver (Figure 4-14 on                                    RXD        trx_pd                       6        µs      A
                                   trx_pd = max(trx_pdr , trx_pdf)
       page 29)
       Symmetry of receiver
                                   VS = 7.0V to 18V
  11.2 propagation delay rising                                    RXD       trx_sym     –2               +2        µs      A
                                   trx_sym = trx_pdr – trx_pdf
       edge minus falling edge
   12  NRES Open Drain Output Pin
                                   VS  5.5V
 12.1 Low-level output voltage                                     NRES      VNRESL                      0.14        V      A
                                   INRES = 1mA
                                   10k to 5V
 12.2 Low-level output low                                         NRES     VNRESLL                      0.14        V      A
                                   VCC = 0V
                                   VS  5.5V
 12.3 Undervoltage reset time                                      NRES                   2       4        6        ms      A
                                   CNRES = 20pF
       Reset debounce time for     VS  5.5V
 12.4                                                              NRES       tres_f     1.5              10        µs      A
       falling edge                CNRES = 20pF
 12.5 Switch off leakage current VNRES = 5.5V                      NRES                  –3               +3        µA      A
*) Type means: A = 100% tested, B = 100% correlation tested, C = Characterized on samples, D = Design parameter
                                                                                             ATA6614Q [DATASHEET]             27
                                                                                                       9240I–AUTO–03/16


4.8      Electrical Characteristics (Continued)
5V < VS < 27V, –40°C < Tj < 150°C, unless otherwise specified. All values refer to GND pins
  No. Parameters                  Test Conditions                  Pin      Symbol      Min.   Typ.     Max.     Unit  Type*
   13  Watchdog Oscillator
       Voltage at WD_OSC in       IWD_OSC = –200µA              WD_OS
 13.1                                                                       VWD_OSC     1.13   1.23     1.33       V     A
       Normal or Fail-safe Mode VVS  4V                            C
                                                                WD_OS
 13.2 Possible values of resistor Resistor ±1%                                ROSC        34             120      k     A
                                                                    C
 13.3 Oscillator period           ROSC = 34k                                  tOSC    10.65   13.3    15.97      µs     A
 13.4 Oscillator period           ROSC = 51k                                  tOSC    15.68   19.6    23.52      µs     A
 13.5 Oscillator period           ROSC = 91k                                  tOSC    26.83   33.5    40.24      µs     A
 13.6 Oscillator period           ROSC = 120k                   NRES          tOSC     34.2   42.8     51.4      µs     A
   14  Watchdog Timing Relative to tOSC
       Watchdog lead time after
 14.1                                                                            td           7895              cycles   A
       Reset
 14.2 Watchdog closed window                                                     t1           1053              cycles   A
 14.3 Watchdog open window                                                       t2           1105              cycles   A
       Watchdog reset time
 14.4                                                                          tnres     3.2     4       4.8     ms      A
       NRES
   15  KL_15 Pin
       High-level input voltage   Positive edge initializes a
 15.1                                                            KL_15      VKL_15H        4         VS + 0.3V     V     A
       RV = 47k                  wake-up
       Low-level input voltage
 15.2                                                            KL_15       VKL_15L      –1             +2        V     A
       RV = 47k
                                  VS < 27V
 15.3 KL_15 pull-down current                                    KL_15        IKL_15            50        60      µA     A
                                  VKL_15 = 27V
 15.4 Internal debounce time      Without external capacitor     KL_15      TdbKL_15      80   160       250      µs     A
 15.5 KL_15 wake-up time          RV = 47k , C = 100nF          KL_15      TwKL_15      0.4     2       4.5     ms      C
   16  WAKE Pin
 16.1 High-level input voltage                                   WAKE       VWAKEH    VS – 1V        VS + 0.3V     V     A
 16.2 Low-level input voltage     Initializes a wake-up signal   WAKE        VWAKEL       –1          VS – 3.3V    V     A
 16.3 WAKE pull-up current        VS < 27V, VWAKE = 0V           WAKE         IWAKE      –30   –10                µA     A
 16.4 High-level leakage current VS = 27V, VWAKE = 27V           WAKE        IWAKEL       –5             +5       µA     A
       Time of low pulse for
 16.5                             VWAKE = 0V                     WAKE        IWAKEL       30    70       150      µs     A
       wake-up via WAKE pin
   17  VCC Voltage Regulator in Normal/ Fail-safe and Silent Mode, VCC and PVCC Shortcircuited
                                  5.5V < VS < 18V
                                                                  VCC        VCCnor      4.9             5.1       V     A
                                  (0mA to 50mA)
 17.1 Output voltage VCC
                                  5.5V < VS < 18V
                                                                  VCC        VCCnor      4.9             5.1       V     C
                                  (0mA to 85mA)
       Output voltage VCC at
 17.2                             4V < VS < 5.5V                  VCC       VCClow    VS – VD            5.1       V     A
       low VS
 17.3 Regulator drop voltage      VS > 4V, IVCC = –20mA        VS, VCC         VD1                       250     mV      A
 17.4 Regulator drop voltage      VS > 4V, IVCC = –50mA        VS, VCC         VD2             400       600     mV      A
 17.5 Regulator drop voltage      VS > 3.3V, IVCC = –15mA      VS, VCC         VD3                       200     mV      A
 17.6 Line regulation             5.5V < VS < 18V                 VCC       VCCline             0.1      0.2      %      A
*) Type means: A = 100% tested, B = 100% correlation tested, C = Characterized on samples, D = Design parameter
28       ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


4.8      Electrical Characteristics (Continued)
5V < VS < 27V, –40°C < Tj < 150°C, unless otherwise specified. All values refer to GND pins
  No. Parameters                           Test Conditions                   Pin           Symbol    Min.          Typ.      Max.        Unit    Type*
                                           5mA < IVCC < 50mA at
 17.7 Load regulation                                                        VCC           VCCload                  0.1      0.5           %       A
                                           100kHz
                                           10Hz to 100kHz
       Power supply ripple
 17.8                                      CVCC = 10µF                       VCC                      50                                  dB       D
       rejection
                                           VS = 14V, IVCC = –15mA
 17.9 Output current limitation            VS > 5.5V                         VCC            IVCClim  –240          –130      –85          mA       A
                                           0.2 < ESR < 5 at
                                           100kHz for phase margin
 17.10 External Load capacity               60°                             VCC             Cload    1.8            10                   µF       D
                                           ESR < 0.2 at 100kHz for
                                           phase margin  30°
       VCC undervoltage                    Referred to VCC
 17.11                                                                       VCC            VthunN    4.2                    4.8            V      A
       threshold                           VS > 5.5V
       Hysteresis of undervoltage Referred to VCC
 17.12                                                                       VCC           Vhysthun                 250                   mV       A
       threshold                           VS > 5.5V
       Ramp-up time VS > 5.5V to CVCC = 2.2µF
 17.13                                                                       VCC             tVCC                   370      600           µs      A
       VCC = 5V                            Iload = –5mA at VCC
*) Type means: A = 100% tested, B = 100% correlation tested, C = Characterized on samples, D = Design parameter
         Figure 4-14. Definition of Bus Timing Characteristics
                                                              tBit                              tBit                    tBit
                                 TXD
                    (Input to transmitting node)
                                                                      tBus_dom(max)                  tBus_rec(min)
                                                                                                                                  Thresholds of
                                            THRec(max)
                                                                                                                                 receiving node1
                         VS                THDom(max)
               (Transceiver supply
               of transmitting node)                               LIN Bus Signal
                                                                                                                                  Thresholds of
                                             THRec(min)                                                                          receiving node2
                                            THDom(min)
                                                                     tBus_dom(min)                     tBus_rec(max)
                               RXD
                 (Output of receiving node1)
                                                   trx_pdf(1)                                         trx_pdr(1)
                               RXD
                 (Output of receiving node2)
                                                                                trx_pdr(2)                                          trx_pdf(2)
                                                                                                           ATA6614Q [DATASHEET]                     29
                                                                                                                         9240I–AUTO–03/16


5.  Microcontroller Block
5.1 Features
      ●    High performance, low power AVR® 8-Bit microcontroller
      ●    Advanced RISC architecture
              ●   131 powerful instructions – most single clock cycle execution
              ●   32 x 8 general purpose working registers
              ●   Fully static operation
              ●   Up to 20MIPS throughput at 20MHz
              ●   On-chip 2-cycle multiplier
      ●    High endurance non-volatile memory segments
              ●   32Kbytes of in-system self-programmable flash program memory
              ●   1Kbyte EEPROM
              ●   2Kbytes internal SRAM
              ●   Write/erase cycles: 10,000 flash/100,000 EEPROM
              ●   Optional boot code section with independent lock bits
                     ●   In-system programming by on-chip boot program
                     ●   True read-while-write operation
              ●   Programming lock for software security
      ●    Peripheral features
              ●   Two 8-bit timer/counters with separate prescaler and compare mode
              ●   One 16-bit timer/counter with separate prescaler, compare mode, and capture mode
              ●   Real time counter with separate oscillator
              ●   Six PWM channels
              ●   8-channel 10-bit ADC
                     ●   Temperature measurement
              ●   Programmable serial USART
              ●   Master/slave SPI serial interface
              ●   Byte-oriented 2-wire serial interface (Philips I2C compatible)
              ●   Programmable watchdog timer with separate on-chip oscillator
              ●   On-chip analog comparator
              ●   Interrupt and wake-up on pin change
      ●    Special microcontroller features
              ●   Power-on reset and programmable brown-out detection
              ●   Internal calibrated oscillator
              ●   External and internal interrupt sources
              ●   Six sleep modes: idle, ADC noise reduction, power-save, power-down, standby, and extended standby
      ●    I/O
              ●   23 programmable I/O lines
      ●    Operating voltage:
              ●   2.7V - 5.5V for ATmega328P
      ●    Temperature range:
              ●   Automotive temperature range: -40°C to +125°C
      ●    Speed grade:
              ●   0 - 8MHz at 2.7 - 5.5V (automotive temp. range: -40°C to +125°C)
              ●   0 - 16MHz at 4.5 - 5.5V (automotive temp. range: -40°C to +125°C)
30  ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


         ●    Low-power consumption
                ●    Active mode: 1.5mA at 3V - 4MHz
                ●    Power-down mode: 1µA at 3V
5.2     Overview
        The ATmega328P is a low-power CMOS 8-bit microcontroller based on the AVR® enhanced RISC architecture. By
        executing powerful instructions in a single clock cycle, the ATmega328P achieves throughputs approaching 1 MIPS per MHz
        allowing the system designer to optimize power consumption versus processing speed.
5.2.1   Block Diagram
        Figure 5-1. Block Diagram
                                                            GND         VCC
                                              Watchdog
                                                              Power           debugWIRE
                                               Timer
                                                            Supervision
                                                            POR/BOD
                                                               and
                                              Watchdog        RESET            Program
                                              Oscillator                        Logic
                                             Oscillator
                                              Circuits/        Flash              SRAM
                                               Clock
                                             Generation
                                                                        AVR CPU
                                              EEPROM
                                                                                                        AVCC
                                                                                                        AREF
                                                                                                        GND
                                                                                               2
                                              8-bit T/C 0   16-bit T/C 1      A/D Conv.
                                  DATA BUS
                                                              Analog           Internal    6
                                              8-bit T/C 2   Comparator         Bandgap
                                              USART 0             SPI             TWI
                                             PORT D (8)     PORT B (8)        PORT C (7)
                                                                                                        RESET
                                                                                                        XTAL[1..2]
                                               PD[0..7]      PB[0..7]          PC[0..6]    ADC[6..7]
                                                                                                   ATA6614Q [DATASHEET]           31
                                                                                                               9240I–AUTO–03/16


    The AVR® core combines a rich instruction set with 32 general purpose working registers. All the 32 registers are directly
    connected to the arithmetic logic unit (ALU), allowing two independent registers to be accessed in one single instruction
    executed in one clock cycle. The resulting architecture is more code efficient while achieving throughputs up to ten times
    faster than conventional CISC microcontrollers.
    The ATmega328P provides the following features: 32Kbytes of in-system programmable flash with read-while-write
    capabilities, 1Kbyte EEPROM, 2Kbytes SRAM, 23 general purpose I/O lines, 32 general purpose working registers, three
    flexible timer/counters with compare modes, internal and external interrupts, a serial programmable USART, a byte-oriented
    2-wire serial Interface, an SPI serial port, a 8-channel 10-bit ADC, a programmable watchdog timer with internal oscillator,
    and five software selectable power saving modes. The Idle mode stops the CPU while allowing the SRAM, Timer/Counters,
    USART,
    2-wire serial interface, SPI port, and interrupt system to continue functioning. The power-down mode saves the register
    contents but freezes the oscillator, disabling all other chip functions until the next interrupt or hardware reset. In power-save
    mode, the asynchronous timer continues to run, allowing the user to maintain a timer base while the rest of the device is
    sleeping. The ADC noise reduction mode stops the CPU and all I/O modules except asynchronous timer and ADC, to
    minimize switching noise during ADC conversions. In standby mode, the crystal/resonator oscillator is running while the rest
    of the device is sleeping. This allows very fast start-up combined with low power consumption.
    The device is manufactured using Atmel®’s high density non-volatile memory technology. The on-chip ISP flash allows the
    program memory to be reprogrammed in-system through an SPI serial interface, by a conventional non-volatile memory
    programmer, or by an on-chip boot program running on the AVR core. The Boot program can use any interface to download
    the application program in the application flash memory. Software in the boot flash section will continue to run while the
    application flash section is updated, providing true read-while-write operation. By combining an 8-bit RISC CPU with in-
    system
    self-programmable flash on a monolithic chip, the Atmel ATmega328P is a powerful microcontroller that provides a highly
    flexible and cost effective solution to many embedded control applications.
    The ATmega328P AVR is supported with a full suite of program and system development tools including: C compilers,
    macro assemblers, program debugger/simulators, in-circuit emulators, and evaluation kits.
5.3 Resources
    A comprehensive set of development tools, application notes and datasheets are available for download on
    http://www.atmel.com/avr.
5.4 Data Retention
    Reliability Qualification results show that the projected data retention failure rate is much less than 1 PPM over 20 years at
    85°C or 100 years at 25°C.
5.5 About Code Examples
    This documentation contains simple code examples that briefly show how to use various parts of the device. These code
    examples assume that the part specific header file is included before compilation. Be aware that not all C compiler vendors
    include bit definitions in the header files and interrupt handling in C is compiler dependent. Please confirm with the C
    compiler documentation for more details.
    For I/O registers located in extended I/O map, “IN”, “OUT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must be replaced
    with instructions that allow access to extended I/O. Typically “LDS” and “STS” combined with “SBRS”, “SBRC”, “SBR”, and
    “CBR”.
32  ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.6     AVR CPU Core
5.6.1   Overview
        This section discusses the AVR® core architecture in general. The main function of the CPU core is to ensure correct
        program execution. The CPU must therefore be able to access memories, perform calculations, control peripherals, and
        handle interrupts.
        Figure 5-2. Block Diagram of the AVR Architecture
                                                                                                       Data Bus 8-bit
                                       Flash            Program                                        Status and
                                      Program           Counter                                         Control
                                      Memory
                                                                                                                              Interrupt
                                                                                                        32 x 8
                                                                                                                                 Unit
                                                                                                       General
                                     Instruction
                                                                                                       Purpose
                                      Register
                                                                                                       Registers                SPI
                                                                                                                                Unit
                                     Instruction
                                                             Direct Addressing
                                                                                 Indirect Addressing
                                      Decoder                                                                                Watchdog
                                                                                                         ALU                  Timer
                                    Control Lines                                                                             Analog
                                                                                                                            Comparator
                                                                                                                            I/O Module 1
                                                                                                          Data
                                                                                                         SRAM
                                                                                                                            I/O Module 2
                                                                                                                            I/O Module n
                                                                                                       EEPROM
                                                                                                       I/O Lines
        In order to maximize performance and parallelism, the AVR uses a Harvard architecture – with separate memories and
        buses for program and data. Instructions in the program memory are executed with a single level pipelining. While one
        instruction is being executed, the next instruction is pre-fetched from the program memory. This concept enables instructions
        to be executed in every clock cycle. The program memory is in-system reprogrammable flash memory.
        The fast-access register file contains 32 x 8-bit general purpose working registers with a single clock cycle access time. This
        allows single-cycle arithmetic logic unit (ALU) operation. In a typical ALU operation, two operands are output from the
        register file, the operation is executed, and the result is stored back in the register file – in one clock cycle.
        Six of the 32 registers can be used as three 16-bit indirect address register pointers for data space addressing – enabling
        efficient address calculations. One of the these address pointers can also be used as an address pointer for look up tables in
        flash program memory. These added function registers are the 16-bit X-, Y-, and Z-register, described later in this section.
                                                                                                                        ATA6614Q [DATASHEET]              33
                                                                                                                                       9240I–AUTO–03/16


        The ALU supports arithmetic and logic operations between registers or between a constant and a register. Single register
        operations can also be executed in the ALU. After an arithmetic operation, the Status Register is updated to reflect
        information about the result of the operation.
        Program flow is provided by conditional and unconditional jump and call instructions, able to directly address the whole
        address space. Most AVR® instructions have a single 16-bit word format. Every program memory address contains a 16- or
        32-bit instruction.
        Program flash memory space is divided in two sections, the boot program section and the application program section. Both
        sections have dedicated lock bits for write and read/write protection. The SPM instruction that writes into the application flash
        memory section must reside in the boot program section.
        During interrupts and subroutine calls, the return address program counter (PC) is stored on the stack. The stack is
        effectively allocated in the general data SRAM, and consequently the stack size is only limited by the total SRAM size and
        the usage of the SRAM. All user programs must initialize the SP in the reset routine (before subroutines or interrupts are
        executed). The stack pointer (SP) is read/write accessible in the I/O space. The data SRAM can easily be accessed through
        the five different addressing modes supported in the AVR architecture.
        The memory spaces in the AVR architecture are all linear and regular memory maps.
        A flexible interrupt module has its control registers in the I/O space with an additional global interrupt enable bit in the status
        register. All interrupts have a separate interrupt vector in the interrupt vector table. The interrupts have priority in accordance
        with their interrupt vector position. The lower the interrupt vector address, the higher the priority.
        The I/O memory space contains 64 addresses for CPU peripheral functions as control registers, SPI, and other I/O functions.
        The I/O memory can be accessed directly, or as the data space locations following those of the register File, 0x20 - 0x5F. In
        addition, the ATmega328P has extended I/O space from 0x60 - 0xFF in SRAM where only the ST/STS/STD and
        LD/LDS/LDD instructions can be used.
5.6.2   ALU – Arithmetic Logic Unit
        The high-performance AVR ALU operates in direct connection with all the 32 general purpose working registers. Within a
        single clock cycle, arithmetic operations between general purpose registers or between a register and an immediate are
        executed. The ALU operations are divided into three main categories – arithmetic, logical, and bit-functions. Some
        implementations of the architecture also provide a powerful multiplier supporting both signed/unsigned multiplication and
        fractional format. See the “Instruction Set” section for a detailed description.
5.6.3   Status Register
        The status register contains information about the result of the most recently executed arithmetic instruction. This
        information can be used for altering program flow in order to perform conditional operations. Note that the status register is
        updated after all ALU operations, as specified in the instruction set reference. This will in many cases remove the need for
        using the dedicated compare instructions, resulting in faster and more compact code.
        The status register is not automatically stored when entering an interrupt routine and restored when returning from an
        interrupt. This must be handled by software.
5.6.3.1 SREG – AVR Status Register
        The AVR Status Register – SREG – is defined as:
                 Bit          7         6          5          4          3          2          1          0
          0x3F (0x5F)         I         T          H          S          V          N          Z          C       SREG
           Read/Write        R/W       R/W       R/W        R/W         R/W        R/W        R/W        R/W
           Initial Value      0         0          0          0          0          0          0          0
        • Bit 7 – I: Global Interrupt Enable
        The global interrupt enable bit must be set for the interrupts to be enabled. The individual interrupt enable control is then
        performed in separate control registers. If the global interrupt enable register is cleared, none of the interrupts are enabled
        independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is
        set by the RETI instruction to enable subsequent interrupts. The I-bit can also be set and cleared by the application with the
        SEI and CLI instructions, as described in the instruction set reference.
34      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


      • Bit 6 – T: Bit Copy Storage
      The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T-bit as source or destination for the operated bit. A bit
      from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a
      register in the register file by the BLD instruction.
      • Bit 5 – H: Half Carry Flag
      The half carry flag H indicates a half carry in some arithmetic operations. Half carry Is useful in BCD arithmetic. See the
      “Instruction Set Description” for detailed information.
      • Bit 4 – S: Sign Bit, S = N V
      The S-bit is always an exclusive or between the negative flag N and the two’s complement overflow flag V. See the
      “Instruction Set Description” for detailed information.
      • Bit 3 – V: Two’s Complement Overflow Flag
      The two’s complement overflow flag V supports two’s complement arithmetics. See the “Instruction Set Description” for
      detailed information.
      • Bit 2 – N: Negative Flag
      The negative flag N indicates a negative result in an arithmetic or logic operation. See the “Instruction Set Description” for
      detailed information.
      • Bit 1 – Z: Zero Flag
      The zero flag Z indicates a zero result in an arithmetic or logic operation. See the “Instruction Set Description” for detailed
      information.
      • Bit 0 – C: Carry Flag
      The carry flag C indicates a carry in an arithmetic or logic operation. See the “Instruction Set Description” for detailed
      information.
5.6.4 General Purpose Register File
      The register file is optimized for the AVR® enhanced RISC instruction set. In order to achieve the required performance and
      flexibility, the following input/output schemes are supported by the register file:
         ● One 8-bit output operand and one 8-bit result input
         ●     Two 8-bit output operands and one 8-bit result input
         ●     Two 8-bit output operands and one 16-bit result input
         ●     One 16-bit output operand and one 16-bit result input
                                                                                              ATA6614Q [DATASHEET]                   35
                                                                                                              9240I–AUTO–03/16


        Figure 5-3 shows the structure of the 32 general purpose working registers in the CPU.
        Figure 5-3. AVR CPU General Purpose Working Registers
                                                  7                 0          Addr.
                                                          R0                   0x00
                                                          R1                   0x01
                                                          R2                   0x02
                                                           …
                                                          R13                  0x0D
                     General                              R14                  0x0E
                     Purpose                              R15                  0x0F
                     Working                              R16                  0x10
                     Registers                            R17                  0x11
                                                           …
                                                          R26                  0x1A            X-register Low Byte
                                                          R27                  0x1B            X-register High Byte
                                                          R28                  0x1C            Y-register Low Byte
                                                          R29                  0x1D            Y-register High Byte
                                                          R30                  0x1E            Z-register Low Byte
                                                          R31                  0x1F            Z-register High Byte
        Most of the instructions operating on the register file have direct access to all registers, and most of them are single cycle
        instructions.
        As shown in Figure 5-3, each register is also assigned a data memory address, mapping them directly into the first 32
        locations of the user data space. Although not being physically implemented as SRAM locations, this memory organization
        provides great flexibility in access of the registers, as the X-, Y- and Z-pointer registers can be set to index any register in the
        file.
5.6.4.1 The X-register, Y-register, and Z-register
        The registers R26..R31 have some added functions to their general purpose usage. These registers are 16-bit address
        pointers for indirect addressing of the data space. The three indirect address registers X, Y, and Z are defined as described
        in
        Figure 5-4.
        Figure 5-4. The X-, Y-, and Z-registers
                                          15                    XH                     XL                       0
               X-register                 7                      0                      7                       0
                                                  R27 (0x1B)                                  R26 (0x1A)
                                          15                    YH                     YL                       0
                Y-register                 7                     0                      7                       0
                                                  R29 (0x1D)                                  R28 (0x1C)
                                          15                    ZH                     ZL                       0
                Z-register                 7                     0                      7                       0
                                                  R31 (0x1F)                                  R30 (0x1E)
        In the different addressing modes these address registers have functions as fixed displacement, automatic increment, and
        automatic decrement (see the instruction set reference for details).
36      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.6.5   Stack Pointer
        The stack is mainly used for storing temporary data, for storing local variables and for storing return addresses after
        interrupts and subroutine calls. Note that the stack is implemented as growing from higher to lower memory locations. The
        stack pointer register always points to the top of the stack. The stack pointer points to the data SRAM stack area where the
        subroutine and interrupt stacks are located. A stack PUSH command will decrease the stack pointer.
        The stack in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are
        enabled. Initial stack pointer value equals the last address of the internal SRAM and the stack pointer must be set to point
        above start of the SRAM, see Figure 5-8 on page 41.
        See Table 5-1 for stack pointer details.
        Table 5-1.      Stack Pointer Instructions
            Instruction        Stack pointer          Description
                PUSH           Decremented by 1       Data is pushed onto the stack
                 CALL
                ICALL          Decremented by 2       Return address is pushed onto the stack with a subroutine call or interrupt
                RCALL
                  POP          Incremented by 1       Data is popped from the stack
                  RET                                 Return address is popped from the stack with return from subroutine or return
                               Incremented by 2
                  RETI                                from interrupt
        The AVR® stack pointer is implemented as two 8-bit registers in the I/O space. The number of bits actually used is
        implementation dependent. Note that the data space in some implementations of the AVR architecture is so small that only
        SPL is needed. In this case, the SPH register will not be present.
5.6.5.1 SPH and SPL – Stack Pointer High and Stack Pointer Low Register
                Bit         15         14        13         12         11         10        9          8
         0x3E (0x5E)      SP15        SP14      SP13      SP12       SP11       SP10       SP9        SP8       SPH
         0x3D (0x5D)       SP7        SP6       SP5        SP4        SP3        SP2       SP1        SP0       SPL
                             7          6         5          4          3          2        1          0
          Read/Write       R/W        R/W       R/W       R/W         R/W        R/W       R/W        R/W
                           R/W        R/W       R/W       R/W         R/W        R/W       R/W        R/W
          Initial Value RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND
                        RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND
                                                                                                ATA6614Q [DATASHEET]               37
                                                                                                              9240I–AUTO–03/16


5.6.6 Instruction Execution Timing
      This section describes the general access timing concepts for instruction execution. The AVR® CPU is driven by the CPU
      clock clkCPU, directly generated from the selected clock source for the chip. No internal clock division is used.
      Figure 5-5 shows the parallel instruction fetches and instruction executions enabled by the Harvard architecture and the fast-
      access register file concept. This is the basic pipelining concept to obtain up to 1MIPS per MHz with the corresponding
      unique results for functions per cost, functions per clocks, and functions per power-unit.
      Figure 5-5. The Parallel Instruction Fetches and Instruction Executions
                                                              T1            T2            T3           T4
                                                  clkCPU
                                  1st Instruction Fetch
                               1st Instruction Execute
                                 2nd Instruction Fetch
                              2nd Instruction Execute
                                 3rd Instruction Fetch
                               3rd Instruction Execute
                                  4th Instruction Fetch
      Figure 5-6 shows the internal timing concept for the register file. In a single clock cycle an ALU operation using two register
      operands is executed, and the result is stored back to the destination register.
      Figure 5-6. Single Cycle ALU Operation
                                                             T1             T2              T3            T4
                                               clkCPU
                              Total Execution Time
                           Register Operands Fetch
                            ALU Operation Execute
                                  Result Write Back
38    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.6.7 Reset and Interrupt Handling
      The AVR® provides several different interrupt sources. These interrupts and the separate Reset Vector each have a
      separate program vector in the program memory space. All interrupts are assigned individual enable bits which must be
      written logic one together with the global interrupt enable bit in the status register in order to enable the interrupt. Depending
      on the program counter value, interrupts may be automatically disabled when boot lock bits BLB02 or BLB12 are
      programmed. This feature improves software security. See Section 5.27 “Memory Programming” on page 262 for details.
      The lowest addresses in the program memory space are by default defined as the reset and interrupt vectors. The complete
      list of vectors is shown in Section 5.11 “Interrupts” on page 73. The list also determines the priority levels of the different
      interrupts. The lower the address the higher is the priority level. RESET has the highest priority, and next is INT0 – the
      external interrupt request 0. The interrupt vectors can be moved to the start of the boot flash section by setting the IVSEL bit
      in the MCU control register (MCUCR). Refer to Section 5.11 “Interrupts” on page 73 for more information. The reset vector
      can also be moved to the start of the boot flash section by programming the BOOTRST fuse, see Section 5.26 “Boot Loader
      Support – Read-while-write Self-programming” on page 250.
      When an interrupt occurs, the global interrupt enable I-bit is cleared and all interrupts are disabled. The user software can
      write logic one to the I-bit to enable nested interrupts. All enabled interrupts can then interrupt the current interrupt routine.
      The I-bit is automatically set when a return from interrupt instruction – RETI – is executed.
      There are basically two types of interrupts. The first type is triggered by an event that sets the interrupt flag. For these
      interrupts, the program counter is vectored to the actual Interrupt Vector in order to execute the interrupt handling routine,
      and hardware clears the corresponding interrupt flag. Interrupt flags can also be cleared by writing a logic one to the flag bit
      position(s) to be cleared. If an interrupt condition occurs while the corresponding interrupt enable bit is cleared, the interrupt
      flag will be set and remembered until the interrupt is enabled, or the flag is cleared by software. Similarly, if one or more
      interrupt conditions occur while the global interrupt enable bit is cleared, the corresponding interrupt flag(s) will be set and
      remembered until the global interrupt enable bit is set, and will then be executed by order of priority.
      The second type of interrupts will trigger as long as the interrupt condition is present. These interrupts do not necessarily
      have interrupt flags. If the interrupt condition disappears before the interrupt is enabled, the interrupt will not be triggered.
      When the AVR exits from an interrupt, it will always return to the main program and execute one more instruction before any
      pending interrupt is served.
      Note that the status register is not automatically stored when entering an interrupt routine, nor restored when returning from
      an interrupt routine. This must be handled by software.
      When using the CLI instruction to disable interrupts, the interrupts will be immediately disabled. No interrupt will be executed
      after the CLI instruction, even if it occurs simultaneously with the CLI instruction. The following example shows how this can
      be used to avoid interrupts during the timed EEPROM write sequence.
        Assembly Code Example
                  in                 r16, SREG                             ; store SREG value
                  cli                ; disable interrupts during timed sequence
                  sbi                EECR, EEMPE                           ; start EEPROM write
                  sbi                EECR, EEPE
                  out                SREG, r16                             ; restore SREG value (I-bit)
        C Code Example
                  char cSREG;
                  cSREG = SREG;                                            /* store SREG value */
                  /* disable interrupts during timed sequence */
                  _CLI();
                  EECR |= (1<<EEMPE); /* start EEPROM write */
                  EECR |= (1<<EEPE);
                  SREG = cSREG; /* restore SREG value (I-bit) */
                                                                                                 ATA6614Q [DATASHEET]                   39
                                                                                                               9240I–AUTO–03/16


        When using the SEI instruction to enable interrupts, the instruction following SEI will be executed before any pending
        interrupts, as shown in this example.
         Assembly Code Example
                   sei                         ; set Global Interrupt Enable
                   sleep                       ; enter sleep, waiting for interrupt
                   ; note: will enter sleep before any pending interrupt(s)
         C Code Example
                   __enable_interrupt(); /* set Global Interrupt Enable */
                   __sleep(); /* enter sleep, waiting for interrupt */
                   /* note: will enter sleep before any pending interrupt(s) */
5.6.7.1 Interrupt Response Time
        The interrupt execution response for all the enabled AVR® interrupts is four clock cycles minimum. After four clock cycles the
        program vector address for the actual interrupt handling routine is executed. During this four clock cycle period, the program
        counter is pushed onto the stack. The vector is normally a jump to the interrupt routine, and this jump takes three clock
        cycles. If an interrupt occurs during execution of a multi-cycle instruction, this instruction is completed before the interrupt is
        served. If an interrupt occurs when the MCU is in sleep mode, the interrupt execution response time is increased by four
        clock cycles. This increase comes in addition to the start-up time from the selected sleep mode.
        A return from an interrupt handling routine takes four clock cycles. During these four clock cycles, the program counter (two
        bytes) is popped back from the stack, the stack pointer is incremented by two, and the I-bit in SREG is set.
5.7     AVR Memories
5.7.1   Overview
        This section describes the different memories in the ATmega328P. The AVR architecture has two main memory spaces, the
        Data Memory and the Program Memory space. In addition, the ATmega328P features an EEPROM Memory for data
        storage. All three memory spaces are linear and regular.
5.7.2   In-system Reprogrammable Flash Program Memory
        The ATmega328P contains 32Kbytes on-chip in-system reprogrammable flash memory for program storage. Since all AVR
        instructions are 16 or 32 bits wide, the flash is organized as 16K x 16. For software security, the flash program memory
        space is divided into two sections, boot loader section and application program section in ATmega328P. See SELFPRGEN
        description in Section 5.25.3.1 “SPMCSR – Store Program Memory Control and Status Register” on page 249 and 261 for
        more details.
        The flash memory has an endurance of at least 10,000 write/erase cycles. The ATmega328P Program Counter (PC) is 14
        bits wide, thus addressing the 16K program memory locations. The operation of boot program section and associated boot
        lock bits for software protection are described in detail in Section 5.25 “Self-programming the Flash, ATmega328P” on page
        243 and Section 5.26 “Boot Loader Support – Read-while-write Self-programming” on page 250. Section 5.27 “Memory
        Programming” on page 262 contains a detailed description on flash programming in SPI or parallel programming mode.
        Constant tables can be allocated within the entire program memory address space (see the LPM – Load Program Memory
        instruction description).
        Timing diagrams for instruction fetch and execution are presented in Section 5.6.6 “Instruction Execution Timing” on page
        38.
40      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


      Figure 5-7. Program Memory Map ATmega328P
                                                          Program Memory
                                                                                   0x0000
                                                     Application Flash Section
                                                         Boot Flash Section
                                                                                   0x3FFF
5.7.3 SRAM Data Memory
      Figure 5-8 shows how the ATmega328P SRAM Memory is organized.
      The ATmega328P is a complex microcontroller with more peripheral units than can be supported within the 64 locations
      reserved in the Opcode for the IN and OUT instructions. For the extended I/O space from 0x60 - 0xFF in SRAM, only the
      ST/STS/STD and LD/LDS/LDD instructions can be used.
      The lower 2303 data memory locations address both the register file, the I/O memory, extended I/O memory, and the
      internal data SRAM. The first 32 locations address the register file, the next 64 location the standard I/O memory, then 160
      locations of extended I/O memory, and the next 2048 locations address the internal data SRAM.
      The five different addressing modes for the data memory cover: Direct, Indirect with displacement, indirect, indirect with pre-
      decrement, and Indirect with post-increment. In the register file, registers R26 to R31 feature the indirect addressing pointer
      registers.
      The direct addressing reaches the entire data space.
      The indirect with displacement mode reaches 63 address locations from the base address given by the Y- or Z-register.
      When using register indirect addressing modes with automatic pre-decrement and post-increment, the address registers X,
      Y, and Z are decremented or incremented.
      The 32 general purpose working registers, 64 I/O registers, 160 extended I/O registers, and the 2048 bytes of internal data
      SRAM in the ATmega328P are all accessible through all these addressing modes. The register file is described in Section
      5.6.4 “General Purpose Register File” on page 35.
      Figure 5-8. Data Memory Map
                                                       Data Memory
                                                        32 Registers       0x0000 - 0x001F
                                                      64 I/O Registers     0x0020 - 0x005F
                                                   160 Ext I/O Registers   0x0060 - 0x00FF
                                                                           0x0100
                                                       Internal SRAM
                                                          (2048 x 8)
                                                                           0x08FF
                                                                                              ATA6614Q [DATASHEET]                 41
                                                                                                            9240I–AUTO–03/16


5.7.3.1 Data Memory Access Times
        This section describes the general access timing concepts for internal memory access. The internal data SRAM access is
        performed in two clkCPU cycles as described in Figure 5-9.
        Figure 5-9. On-chip Data SRAM Access Cycles
                                                    T1                        T2                    T3
                               clkCPU
                             Address          Compute Address             Address valid
                                 Data
                                                                                                                 Write
                                  WR
                                 Data
                                                                                                                 Read
                                  RD
                                                      Memory Access Instruction                 Next Instruction
5.7.4   EEPROM Data Memory
        The ATmega328P contains 1K byte of data EEPROM memory. It is organized as a separate data space, in which single
        bytes can be read and written. The EEPROM has an endurance of at least 100,000 write/erase cycles. The access between
        the EEPROM and the CPU is described in the following, specifying the EEPROM address registers, the EEPROM data
        register, and the EEPROM control register.
        Section 5.27 “Memory Programming” on page 262 contains a detailed description on EEPROM programming in SPI or
        parallel programming mode.
5.7.4.1 EEPROM Read/Write Access
        The EEPROM access registers are accessible in the I/O space.
        The write access time for the EEPROM is given in Table 5-3. A self-timing function, however, lets the user software detect
        when the next byte can be written. If the user code contains instructions that write the EEPROM, some precautions must be
        taken. In heavily filtered power supplies, VCC is likely to rise or fall slowly on power-up/down. This causes the device for
        some period of time to run at a voltage lower than specified as minimum for the clock frequency used. See Section 5.7.4.2
        “Preventing EEPROM Corruption” on page 42 for details on how to avoid problems in these situations.
        In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the
        EEPROM control register for details on this.
        When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction is executed. When the
        EEPROM is written, the CPU is halted for two clock cycles before the next instruction is executed.
5.7.4.2 Preventing EEPROM Corruption
        During periods of low VCC, the EEPROM data can be corrupted because the supply voltage is too low for the CPU and the
        EEPROM to operate properly. These issues are the same as for board level systems using EEPROM, and the same design
        solutions should be applied.
        An EEPROM data corruption can be caused by two situations when the voltage is too low. First, a regular write sequence to
        the EEPROM requires a minimum voltage to operate correctly. Secondly, the CPU itself can execute instructions incorrectly,
        if the supply voltage is too low.
42      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        EEPROM data corruption can easily be avoided by following this design recommendation:
        Keep the AVR® RESET active (low) during periods of insufficient power supply voltage. This can be done by enabling the
        internal brown-out Detector (BOD). If the detection level of the internal BOD does not match the needed detection level, an
        external low VCC reset protection circuit can be used. If a reset occurs while a write operation is in progress, the write
        operation will be completed provided that the power supply voltage is sufficient.
5.7.5   I/O Memory
        The I/O space definition of the ATmega328P is shown in Section 5.30 “Register Summary” on page 294.
        All ATmega328P I/Os and peripherals are placed in the I/O space. All I/O locations may be accessed by the LD/LDS/LDD
        and ST/STS/STD instructions, transferring data between the 32 general purpose working registers and the I/O space. I/O
        registers within the address range 0x00 - 0x1F are directly bit-accessible using the SBI and CBI instructions. In these
        registers, the value of single bits can be checked by using the SBIS and SBIC instructions. Refer to the instruction set
        section for more details. When using the I/O specific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used.
        When addressing I/O Registers as data space using LD and ST instructions, 0x20 must be added to these addresses. The
        ATmega328P is a complex microcontroller with more peripheral units than can be supported within the 64 location reserved
        in Opcode for the IN and OUT instructions. For the Extended I/O space from 0x60 - 0xFF in SRAM, only the ST/STS/STD
        and LD/LDS/LDD instructions can be used.
        For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory addresses
        should never be written.
        Some of the status flags are cleared by writing a logical one to them. Note that, unlike most other AVRs, the CBI and SBI
        instructions will only operate on the specified bit, and can therefore be used on registers containing such status flags. The
        CBI and SBI instructions work with registers 0x00 to 0x1F only.
        The I/O and peripherals control registers are explained in later sections.
5.7.5.1 General Purpose I/O Registers
        The ATmega328P contains three general purpose I/O registers. These registers can be used for storing any information,
        and they are particularly useful for storing global variables and status flags. General purpose I/O registers within the address
        range 0x00 - 0x1F are directly bit-accessible using the SBI, CBI, SBIS, and SBIC instructions.
5.7.6   Register Description
5.7.6.1 EEARH and EEARL – The EEPROM Address Register
                 Bit         15        14         13         12        11        10        9         8
           0x22 (0x42)        –         –          –          –         –         –        –       EEAR8      EEARH
           0x21 (0x41)     EEAR7     EEAR6     EEAR5      EEAR4     EEAR3      EEAR2     EEAR1     EEAR0      EEARL
                              7         6          5          4         3         2        1         0
           Read/Write        R         R           R         R         R          R        R        R/W
                            R/W       R/W        R/W        R/W       R/W       R/W       R/W       R/W
           Initial Value      0         0          0          0         0         0        0         X
                             X         X           X         X         X          X        X         X
        • Bits 15..9 – Res: Reserved Bits
        These bits are reserved bits in the ATmega328P and will always read as zero.
        • Bits 8..0 – EEAR8..0: EEPROM Address
        The EEPROM address registers – EEARH and EEARL specify the EEPROM address in the 256/512/512/1K bytes
        EEPROM space. The EEPROM data bytes are addressed linearly between 0 and 255/511/511/1023. The initial value of
        EEAR is undefined. A proper value must be written before the EEPROM may be accessed.
        EEAR8 is an unused bit in ATmega328P and must always be written to zero.
                                                                                                 ATA6614Q [DATASHEET]                 43
                                                                                                               9240I–AUTO–03/16


5.7.6.2 EEDR – The EEPROM Data Register
                 Bit         7        6          5         4        3         2         1         0
           0x20 (0x40)      MSB                                                                  LSB      EEDR
           Read/Write       R/W      R/W       R/W        R/W      R/W       R/W       R/W       R/W
           Initial Value     0        0          0         0        0         0         0         0
        • Bits 7..0 – EEDR7.0: EEPROM Data
        For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by
        the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address
        given by EEAR.
5.7.6.3 EECR – The EEPROM Control Register
                 Bit         7        6          5         4        3         2         1         0
           0x1F (0x3F)       –        –      EEPM1      EEPM0    EERIE     EEMPE      EEPE      EERE      EECR
           Read/Write        R        R        R/W        R/W      R/W      R/W        R/W       R/W
           Initial Value     0        0          X         X        0         0         X         0
        • Bits 7..6 – Res: Reserved Bits
        These bits are reserved bits in the ATmega328P and will always read as zero.
        • Bits 5, 4 – EEPM1 and EEPM0: EEPROM Programming Mode Bits
        The EEPROM programming mode bit setting defines which programming action that will be triggered when writing EEPE. It
        is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase
        and Write operations in two different operations. The programming times for the different modes are shown in Table 5-2.
        While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be reset to 0b00 unless the
        EEPROM is busy programming.
        Table 5-2.       EEPROM Mode Bits
            EEPM1           EEPM0       Programming Time       Operation
                 0             0               3.4ms           Erase and Write in one operation (Atomic Operation)
                 0             1               1.8ms           Erase Only
                 1             0               1.8ms           Write Only
                 1             1                   –           Reserved for future use
        • Bit 3 – EERIE: EEPROM Ready Interrupt Enable
        Writing EERIE to one enables the EEPROM ready interrupt if the I bit in SREG is set. Writing EERIE to zero disables the
        interrupt. The EEPROM ready interrupt generates a constant interrupt when EEPE is cleared. The interrupt will not be
        generated during EEPROM write or SPM.
        • Bit 2 – EEMPE: EEPROM Master Write Enable
        The EEMPE bit determines whether setting EEPE to one causes the EEPROM to be written. When EEMPE is set, setting
        EEPE within four clock cycles will write data to the EEPROM at the selected address If EEMPE is zero, setting EEPE will
        have no effect. When EEMPE has been written to one by software, hardware clears the bit to zero after four clock cycles.
        See the description of the EEPE bit for an EEPROM write procedure.
44      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


• Bit 1 – EEPE: EEPROM Write Enable
The EEPROM write enable signal EEPE is the write strobe to the EEPROM. When address and data are correctly set up,
the EEPE bit must be written to one to write the value into the EEPROM. The EEMPE bit must be written to one before a
logical one is written to EEPE, otherwise no EEPROM write takes place. The following procedure should be followed when
writing the EEPROM (the order of steps 3 and 4 is not essential):
  1. Wait until EEPE becomes zero.
  2.    Wait until SELFPRGEN in SPMCSR becomes zero.
  3.    Write new EEPROM address to EEAR (optional).
  4.    Write new EEPROM data to EEDR (optional).
  5.    Write a logical one to the EEMPE bit while writing a zero to EEPE in EECR.
  6.    Within four clock cycles after setting EEMPE, write a logical one to EEPE.
The EEPROM can not be programmed during a CPU write to the flash memory. The software must check that the flash
programming is completed before initiating a new EEPROM write. Step 2 is only relevant if the software contains a boot
loader allowing the CPU to program the flash. If the flash is never being updated by the CPU, step 2 can be omitted. See
Section 5.26 “Boot Loader Support – Read-while-write Self-programming” on page 250 for details about boot programming.
Caution: An interrupt between step 5 and step 6 will make the write cycle fail, since the EEPROM master write enable will
time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR
register will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag
cleared during all the steps to avoid these problems.
When the write access time has elapsed, the EEPE bit is cleared by hardware. The user software can poll this bit and wait
for a zero before writing the next byte. When EEPE has been set, the CPU is halted for two cycles before the next instruction
is executed.
• Bit 0 – EERE: EEPROM Read Enable
The EEPROM read enable signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR
register, the EERE bit must be written to a logic one to trigger the EEPROM read. The EEPROM read access takes one
instruction, and the requested data is available immediately. When the EEPROM is read, the CPU is halted for four cycles
before the next instruction is executed.
The user should poll the EEPE bit before starting the read operation. If a write operation is in progress, it is neither possible
to read the EEPROM, nor to change the EEAR register.
The calibrated oscillator is used to time the EEPROM accesses. Table 5-3 lists the typical programming time for EEPROM
access from the CPU.
Table 5-3.     EEPROM Programming Time
         Symbol                     Number of Calibrated RC Oscillator Cycles                        Typ Programming Time
  EEPROM write (from
                                                         26.368                                                3.3ms
           CPU)
The following code examples show one assembly and one C function for writing to the EEPROM. The examples assume
that interrupts are controlled (e.g. by disabling interrupts globally) so that no interrupts will occur during execution of these
functions. The examples also assume that no flash boot loader is present in the software. If such code is present, the
EEPROM write function must also wait for any ongoing SPM command to finish.
                                                                                           ATA6614Q [DATASHEET]                 45
                                                                                                          9240I–AUTO–03/16


    Assembly Code Example
             EEPROM_write:
                    ; Wait for completion of previous write
                    sbic   EECR,EEPE
                    rjmp   EEPROM_write
                    ; Set up address (r18:r17) in address register
                    out    EEARH, r18
                    out    EEARL, r17
                    ; Write data (r16) to Data Register
                    out    EEDR,r16
                    ; Write logical one to EEMPE
                    sbi    EECR,EEMPE
                    ; Start eeprom write by setting EEPE
                    sbi    EECR,EEPE
                    ret
    C Code Example
             void EEPROM_write(unsigned int uiAddress, unsigned char ucData)
             {
                    /* Wait for completion of previous write */
                    while(EECR & (1<<EEPE))
                    ;
                    /* Set up address and Data Registers */
                    EEAR = uiAddress;
                    EEDR = ucData;
                    /* Write logical one to EEMPE */
                    EECR |= (1<<EEMPE);
                    /* Start eeprom write by setting EEPE */
                    EECR |= (1<<EEPE);
             }
46 ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


        The next code examples show assembly and C functions for reading the EEPROM. The examples assume that interrupts
        are controlled so that no interrupts will occur during execution of these functions.
         Assembly Code Example
                     EEPROM_read:
                            ; Wait for completion of previous write
                            sbic      EECR,EEPE
                            rjmp      EEPROM_read
                            ; Set up address (r18:r17) in address register
                            out       EEARH, r18
                            out       EEARL, r17
                            ; Start eeprom read by writing EERE
                            sbi       EECR,EERE
                            ; Read data from Data Register
                            in        r16,EEDR
                            ret
         C Code Example
                     unsigned char EEPROM_read(unsigned int uiAddress)
                     {
                            /* Wait for completion of previous write */
                            while(EECR & (1<<EEPE))
                            ;
                            /* Set up address register */
                            EEAR = uiAddress;
                            /* Start eeprom read by writing EERE */
                            EECR |= (1<<EERE);
                            /* Return data from Data Register */
                            return EEDR;
                     }
5.7.6.4 GPIOR2 – General Purpose I/O Register 2
                 Bit        7          6           5         4        3         2          1     0
          0x2B (0x4B)      MSB                                                                  LSB   GPIOR2
           Read/Write      R/W        R/W        R/W       R/W      R/W        R/W       R/W    R/W
           Initial Value    0          0           0         0        0         0          0     0
5.7.6.5 GPIOR1 – General Purpose I/O Register 1
                 Bit        7          6           5         4        3         2          1     0
          0x2A (0x4A)      MSB                                                                  LSB   GPIOR1
           Read/Write      R/W        R/W        R/W       R/W      R/W        R/W        R/W   R/W
           Initial Value    0          0           0         0        0         0          0     0
5.7.6.6 GPIOR0 – General Purpose I/O Register 0
                 Bit        7          6           5         4        3         2          1     0
          0x1E (0x3E)      MSB                                                                  LSB   GPIOR0
           Read/Write      R/W        R/W        R/W       R/W      R/W        R/W        R/W   R/W
           Initial Value    0          0           0         0        0         0          0     0
                                                                                              ATA6614Q [DATASHEET]       47
                                                                                                        9240I–AUTO–03/16


5.8     System Clock and Clock Options
5.8.1   Clock Systems and their Distribution
        Figure 5-10 presents the principal clock systems in the AVR® and their distribution. All of the clocks need not be active at a
        given time. In order to reduce power consumption, the clocks to modules not being used can be halted by using different
        sleep modes, as described in Section 5.9 “Power Management and Sleep Modes” on page 58. The clock systems are
        detailed below.
        Figure 5-10. Clock Distribution
                          Asynchronous     General I/O                                                                    Flash and
                                                                 ADC                 CPU Core              RAM
                          Timer/Counter     Modules                                                                       EEPROM
                                                                      clkADC
                                               clkI/O                                 clkCPU
                                                              AVR Clock
                                                             Control Unit
                                             clkASY                                   clkFLASH
                                                             System Clock
                                                                                        Reset Logic      Watchdog Timer
                                                               Prescaler
                                                                      Source clock               Watchdog clock
                                                                 Clock                                        Watchdog
                                                              Multiplexer                                     Oscillator
                          Timer/Counter                                    Crystal               Low-frequency           Calibrated RC
                                              External Clock
                            Oscillator                                    Oscillator            Crystal Oscillator         Oscillator
5.8.1.1 CPU Clock – clkCPU
        The CPU clock is routed to parts of the system concerned with operation of the AVR core. Examples of such modules are
        the general purpose register File, the status register and the data memory holding the stack pointer. Halting the CPU clock
        inhibits the core from performing general operations and calculations.
5.8.1.2 I/O Clock – clkI/O
        The I/O clock is used by the majority of the I/O modules, like Timer/Counters, SPI, and USART. The I/O clock is also used by
        the External Interrupt module, but note that some external interrupts are detected by asynchronous logic, allowing such
        interrupts to be detected even if the I/O clock is halted. Also note that start condition detection in the USI module is carried
        out asynchronously when clkI/O is halted, TWI address recognition in all sleep modes.
5.8.1.3 Flash Clock – clkFLASH
        The flash clock controls operation of the flash interface. The flash clock is usually active simultaneously with the CPU clock.
5.8.1.4 Asynchronous Timer Clock – clkASY
        The asynchronous timer clock allows the asynchronous Timer/Counter to be clocked directly from an external clock or an
        external 32 kHz clock crystal. The dedicated clock domain allows using this Timer/Counter as a real-time counter even when
        the device is in sleep mode.
48      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.8.1.5 ADC Clock – clkADC
        The ADC is provided with a dedicated clock domain. This allows halting the CPU and I/O clocks in order to reduce noise
        generated by digital circuitry. This gives more accurate ADC conversion results.
5.8.2   Clock Sources
        The device has the following clock source options, selectable by flash fuse bits as shown below. The clock from the selected
        source is input to the AVR® clock generator, and routed to the appropriate modules.
        Table 5-4.     Device Clocking Options Select(1)
         Device Clocking Option                                                                       CKSEL3..0
         Low power crystal oscillator                                                                1111 - 1000
         Full swing crystal oscillator                                                               0111 - 0110
         Low frequency crystal oscillator                                                            0101 - 0100
         Internal 128kHz RC oscillator                                                                   0011
         Calibrated internal RC oscillator                                                               0010
         External clock                                                                                  0000
         Reserved                                                                                        0001
         Note:      1.  For all fuses “1” means unprogrammed while “0” means programmed.
5.8.2.1 Default Clock Source
        The device is shipped with internal RC oscillator at 8.0MHz and with the fuse CKDIV8 programmed, resulting in 1.0MHz
        system clock. The startup time is set to maximum and time-out period enabled. (CKSEL = “0010”, SUT = “10”, CKDIV8 =
        “0”). The default setting ensures that all users can make their desired clock source setting using any available programming
        interface.
5.8.2.2 Clock Startup Sequence
        Any clock source needs a sufficient VCC to start oscillating and a minimum number of oscillating cycles before it can be
        considered stable.
        To ensure sufficient VCC, the device issues an internal reset with a time-out delay (tTOUT) after the device reset is released by
        all other reset sources. Section 5.10 “System Control and Reset” on page 63 describes the start conditions for the internal
        reset. The delay (tTOUT) is timed from the watchdog oscillator and the number of cycles in the delay is set by the SUTx and
        CKSELx fuse bits. The selectable delays are shown in Table 5-5. The frequency of the watchdog oscillator is voltage
        dependent as shown in Section 5.29 “Typical Characteristics” on page 287.
        Table 5-5.     Number of Watchdog Oscillator Cycles
                Typ Time-out (VCC = 5.0V)                   Typ Time-out (VCC = 3.0V)                       Number of Cycles
                             0ms                                       0ms                                            0
                           4.1ms                                      4.3ms                                         512
                            65ms                                      69ms                                       8K (8,192)
        Main purpose of the delay is to keep the AVR in reset until it is supplied with minimum VCC. The delay will not monitor the
        actual voltage and it will be required to select a delay longer than the VCC rise time. If this is not possible, an internal or
        external brown-out detection circuit should be used. A BOD circuit will ensure sufficient VCC before it releases the reset, and
        the time-out delay can be disabled. Disabling the time-out delay without utilizing a brown-out detection circuit is not
        recommended.
        The oscillator is required to oscillate for a minimum number of cycles before the clock is considered stable. An internal ripple
        counter monitors the oscillator output clock, and keeps the internal reset active for a given number of clock cycles. The reset
        is then released and the device will start to execute. The recommended oscillator start-up time is dependent on the clock
        type, and varies from 6 cycles for an externally applied clock to 32K cycles for a low frequency crystal.
        The start-up sequence for the clock includes both the time-out delay and the start-up time when the device starts up from
        reset. When starting up from power-save or power-down mode, VCC is assumed to be at a sufficient level and only the start-
        up time is included.
                                                                                                 ATA6614Q [DATASHEET]                   49
                                                                                                                 9240I–AUTO–03/16


5.8.3 Low Power Crystal Oscillator
      Pins XTAL1 and XTAL2 are input and output, respectively, of an inverting amplifier which can be configured for use as an
      on-chip Oscillator, as shown in Figure 5-11 on page 50. Either a quartz crystal or a ceramic resonator may be used.
      This crystal oscillator is a low power oscillator, with reduced voltage swing on the XTAL2 output. It gives the lowest power
      consumption, but is not capable of driving other clock inputs, and may be more susceptible to noise in noisy environments. In
      these cases, refer to the Section 5.8.4 “Full Swing Crystal Oscillator” on page 51.
      C1 and C2 should always be equal for both crystals and resonators. The optimal value of the capacitors depends on the
      crystal or resonator in use, the amount of stray capacitance, and the electromagnetic noise of the environment. Some initial
      guidelines for choosing capacitors for use with crystals are given in Table 5-6. For ceramic resonators, the capacitor values
      given by the manufacturer should be used.
      Figure 5-11. Crystal Oscillator Connections
                                                             C2
                                                                              XTAL2 (TOSC2)
                                                             C1
                                                                              XTAL1 (TOSC1)
                                                                              GND
      The low power oscillator can operate in three different modes, each optimized for a specific frequency range. The operating
      mode is selected by the fuses CKSEL3..1 as shown in Table 5-6.
      Table 5-6.     Low Power Crystal Oscillator Operating Modes(2)
               Frequency Range                               Recommended Range for
                      (MHz)                                 Capacitors C1 and C2 (pF)                            CKSEL3..1
                    0.4 - 0.9                                             –                                         100(1)
                    0.9 - 3.0                                         12 - 22                                        101
                    3.0 - 8.0                                         12 - 22                                        110
                   8.0 - 16.0                                         12 - 22                                        111
      Notes:    1.   This option should not be used with crystals, only with ceramic resonators.
                2.   If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 fuse can be pro-
                     grammed in order to divide the internal frequency by 8. It must be ensured that the resulting divided clock
                     meets the frequency specification of the device.
50    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


      The CKSEL0 Fuse together with the SUT1..0 fuses select the start-up times as shown in Table 5-7.
      Table 5-7.     Start-up Times for the Low Power Crystal Oscillator Clock Selection
                                                                                     Additional Delay from
          Oscillator Source / Power           Start-up Time from Power-                      Reset
                   Conditions                   down and Power-save                       (VCC = 5.0V)           CKSEL0           SUT1..0
         Ceramic resonator, fast rising
                                                          258 CK                       14CK + 4.1ms(1)               0               00
                      power
       Ceramic resonator, slowly rising
                                                          258 CK                        14CK + 65ms(1)               0               01
                      power
           Ceramic resonator, BOD
                                                           1K CK                            14CK(2)                  0               10
                    enabled
         Ceramic resonator, fast rising
                                                           1K CK                       14CK + 4.1ms(2)               0               11
                      power
       Ceramic resonator, slowly rising
                                                           1K CK                        14CK + 65ms(2)               1               00
                      power
        Crystal Oscillator, BOD enabled                   16K CK                             14CK                    1               01
         Crystal Oscillator, fast rising
                                                          16K CK                         14CK + 4.1ms                1               10
                      power
        Crystal Oscillator, slowly rising
                                                          16K CK                         14CK + 65ms                 1               11
                      power
      Notes:    1.   These options should only be used when not operating close to the maximum frequency of the device, and
                     only if frequency stability at start-up is not important for the application. These options are not suitable for
                     crystals.
                2.   These options are intended for use with ceramic resonators and will ensure frequency stability at start-up. They
                     can also be used with crystals when not operating close to the maximum frequency of the device, and if fre-
                     quency stability at start-up is not important for the application.
5.8.4 Full Swing Crystal Oscillator
      Pins XTAL1 and XTAL2 are input and output, respectively, of an inverting amplifier which can be configured for use as an
      on-chip Oscillator, as shown in Figure 5-11 on page 50. Either a quartz crystal or a ceramic resonator may be used.
      This crystal oscillator is a full swing oscillator, with rail-to-rail swing on the XTAL2 output. This is useful for driving other clock
      inputs and in noisy environments. The current consumption is higher than the Section 5.8.3 “Low Power Crystal Oscillator”
      on page 50. Note that the full swing crystal oscillator will only operate for VCC = 2.7 - 5.5V.
      C1 and C2 should always be equal for both crystals and resonators. The optimal value of the capacitors depends on the
      crystal or resonator in use, the amount of stray capacitance, and the electromagnetic noise of the environment. Some initial
      guidelines for choosing capacitors for use with crystals are given in Table 5-9 on page 52. For ceramic resonators, the
      capacitor values given by the manufacturer should be used.
      The operating mode is selected by the fuses CKSEL3..1 as shown in Table 5-8.
      Table 5-8.     Full Swing Crystal Oscillator Operating Modes(1)
                                                                Recommended Range for
       Frequency Range(1) (MHz)                                Capacitors C1 and C2 (pF)                       CKSEL3..1
                    0.4 - 16                                                 12 - 22                                         011
      Notes:    1.   The frequency ranges are preliminary values. Actual values are TBD.
                2.   If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 fuse can be pro-
                     grammed in order to divide the internal frequency by 8. It must be ensured that the resulting divided clock
                     meets the frequency specification of the device.
                                                                                                    ATA6614Q [DATASHEET]                   51
                                                                                                                  9240I–AUTO–03/16


   Figure 5-12. Crystal Oscillator Connections
                                                           C2
                                                                            XTAL2 (TOSC2)
                                                           C1
                                                                            XTAL1 (TOSC1)
                                                                            GND
   Table 5-9.    Start-up Times for the Full Swing Crystal Oscillator Clock Selection
                                                                            Additional Delay from
      Oscillator Source / Power         Start-up Time from Power-                     Reset
               Conditions                   down and Power-save                    (VCC = 5.0V)            CKSEL0         SUT1..0
     Ceramic resonator, fast rising
                                                     258 CK                      14CK + 4.1ms(1)              0               00
                  power
    Ceramic resonator, slowly rising
                                                     258 CK                      14CK + 65ms(1)               0               01
                  power
        Ceramic resonator, BOD
                                                      1K CK                          14CK(2)                  0               10
                enabled
     Ceramic resonator, fast rising
                                                      1K CK                      14CK + 4.1ms(2)              0               11
                  power
    Ceramic resonator, slowly rising
                                                      1K CK                      14CK + 65ms(2)               1               00
                  power
    Crystal oscillator, BOD enabled                  16K CK                           14CK                    1               01
      Crystal oscillator, fast rising
                                                     16K CK                       14CK + 4.1ms                1               10
                  power
     Crystal oscillator, slowly rising
                                                     16K CK                       14CK + 65ms                 1               11
                  power
   Notes:   1.   These options should only be used when not operating close to the maximum frequency of the device, and
                 only if frequency stability at start-up is not important for the application. These options are not suitable for
                 crystals.
            2.   These options are intended for use with ceramic resonators and will ensure frequency stability at start-up. They
                 can also be used with crystals when not operating close to the maximum frequency of the device, and if fre-
                 quency stability at start-up is not important for the application.
52 ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


5.8.5 Low Frequency Crystal Oscillator
      The low-frequency crystal oscillator is optimized for use with a 32.768kHz watch crystal. When selecting crystals, load
      capacitance and crystal’s equivalent series resistance, ESR must be taken into consideration. Both values are specified by
      the crystal vendor. ATmega328P oscillator is optimized for very low power consumption, and thus when selecting crystals,
      see Table 5-10 for maximum ESR recommendations on 6.5pF, 9.0pF and 12.5pF crystals.
      Table 5-10. Maximum ESR Recommendation for 32.768kHz Crystal
                               Crystal CL (pF)                                                  Max ESR [k](1)
                                     6.5                                                               75
                                     9.0                                                               65
                                    12.5                                                               30
      Note:     1.   Maximum ESR is typical value based on characterization
      The low-frequency crystal oscillator provides an internal load capacitance of typical 6pF at each TOSC pin. The external
      capacitance (C) needed at each TOSC pin can be calculated by using:
       C = 2  CL – C S
      where CL is the load capacitance for a 32.768kHz crystal specified by the crystal vendor and CS is the total stray
      capacitance for one TOSC pin.
      Crystals specifying load capacitance (CL) higher than 6pF, require external capacitors applied as described in Figure 5-11
      on page 50.
      The low-frequency crystal oscillator must be selected by setting the CKSEL Fuses to “0110” or “0111”, as shown in Table 5-
      12. Start-up times are determined by the SUT Fuses as shown in Table 5-11.
      Table 5-11. Start-up Times for the Low-frequency Crystal Oscillator Clock Selection
          SUT1..0              Additional Delay from Reset (VCC = 5.0V)            Recommended Usage
             00                                   4 CK                             Fast rising power or BOD enabled
             01                              4 CK + 4.1ms                          Slowly rising power
             10                              4 CK + 65ms                           Stable frequency at start-up
             11                                                            Reserved
      Table 5-12. Start-up Times for the Low-frequency Crystal Oscillator Clock Selection
                                          Start-up Time from
         CKSEL3..0                  Power-down and Power-save                      Recommended Usage
           0100(1)                               1K CK
            0101                                32K CK                             Stable frequency at start-up
      Note:     1.   This option should only be used if frequency stability at start-up is not important for the application
                                                                                                ATA6614Q [DATASHEET]            53
                                                                                                               9240I–AUTO–03/16


5.8.6 Calibrated Internal RC Oscillator
      By default, the Internal RC oscillator provides an approximate 8.0MHz clock. Though voltage and temperature dependent,
      this clock can be very accurately calibrated by the user. See Table 5-128 on page 279 for more details. The device is
      shipped with the CKDIV8 fuse programmed. See Section 5.8.11 “System Clock Prescaler” on page 56 for more details.
      This clock may be selected as the system clock by programming the CKSEL fuses as shown in Table 5-13. If selected, it will
      operate with no external components. During reset, hardware loads the pre-programmed calibration value into the OSCCAL
      register and thereby automatically calibrates the RC oscillator. The accuracy of this calibration is shown as factory calibration
      in Table 5-128 on page 279.
      By changing the OSCCAL register from SW, see Section 5.8.12.1 “OSCCAL – Oscillator Calibration Register” on page 57, it
      is possible to get a higher calibration accuracy than by using the factory calibration. The accuracy of this calibration is shown
      as User calibration in Table 5-128 on page 279.
      When this oscillator is used as the chip clock, the watchdog oscillator will still be used for the watchdog Timer and for the
      reset time-out. For more information on the pre-programmed calibration value, see the section Section 5.27.4 “Calibration
      Byte” on page 265.
      Table 5-13. Internal Calibrated RC Oscillator Operating Modes(1)(2)
                          Nominal Frequency (MHz)                                                  CKSEL3..0
                                       8                                                              0010
      Notes:    1.   The device is shipped with this option selected.
                2.   If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 Fuse can be pro-
                     grammed in order to divide the internal frequency by 8.
      When this oscillator is selected, start-up times are determined by the SUT fuses as shown in Table 5-14 on page 54.
      Table 5-14. Start-up times for the internal calibrated RC Oscillator clock selection
                                            Start-up Time from Power-down and            Additional Delay from Reset
       Power Conditions                                  Power-save                              (VCC = 5.0V)                SUT1..0
                                                                                                          (1)
       BOD enabled                                           6 CK                                   14CK                        00
       Fast rising power                                     6 CK                               14CK + 4.1ms                    01
                                                                                                              (2)
       Slowly rising power                                   6 CK                              14CK + 65 ms                     10
                                                          Reserved                                                               11
      Note:     1.   If the RSTDISBL fuse is programmed, this start-up time will be increased to 14CK + 4.1 ms to ensure program-
                     ming mode can be entered.
                2.   The device is shipped with this option selected.
54    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.8.7 128 kHz Internal Oscillator
      The 128 kHz internal oscillator is a low power oscillator providing a clock of 128kHz. The frequency is nominal at 3V and
      25°C. This clock may be select as the system clock by programming the CKSEL fuses to “11” as shown in Table 5-15.
      .
      Table 5-15. 128 kHz Internal Oscillator Operating Modes
                                  Nominal Frequency                                                    CKSEL3..0
                                          128kHz                                                          0011
      When this clock source is selected, start-up times are determined by the SUT Fuses as shown in Table 5-16.
      Table 5-16. Start-up Times for the 128 kHz Internal Oscillator
                                           Start-up Time from Power-down and
             Power Conditions                           Power-save                    Additional Delay from Reset        SUT1..0
                                                                                                      (1)
                 BOD enabled                                6 CK                                 14CK                       00
              Fast rising power                             6 CK                               14CK + 4ms                   01
             Slowly rising power                            6 CK                              14CK + 64ms                   10
                                                          Reserved                                                          11
      Note:     1.  If the RSTDISBL fuse is programmed, this start-up time will be increased to 14CK + 4.1ms to ensure program-
                    ming mode can be entered.
5.8.8 External Clock
      To drive the device from an external clock source, XTAL1 should be driven as shown in Figure 5-13. To run the device on an
      external clock, the CKSEL fuses must be programmed to “0000” (see Table 5-17).
      Table 5-17. Crystal Oscillator Clock Frequency
                                        Frequency                                                      CKSEL3..0
                                        0 - 20MHz                                                         0000
      Figure 5-13. External Clock Drive Configuration
                                                                            XTAL2
                                                        NC
                                                   External
                                                                            XTAL1
                                                     Clock
                                                    Signal
                                                                            GND
                                                                                             ATA6614Q [DATASHEET]                55
                                                                                                           9240I–AUTO–03/16


       When this clock source is selected, start-up times are determined by the SUT Fuses as shown in Table 5-18.
       Table 5-18. Start-up Times for the External Clock Selection
                                             Start-up Time from Power-down and          Additional Delay from Reset
                Power Conditions                          Power-save                              (VCC = 5.0V)              SUT1..0
         BOD enabled                                          6 CK                                   14CK                      00
         Fast rising power                                    6 CK                               14CK + 4.1ms                  01
         Slowly rising power                                  6 CK                               14CK + 65ms                   10
                                                            Reserved                                                            11
       When applying an external clock, it is required to avoid sudden changes in the applied clock frequency to ensure stable
       operation of the MCU. A variation in frequency of more than 2% from one clock cycle to the next can lead to unpredictable
       behavior. If changes of more than 2% is required, ensure that the MCU is kept in reset during the changes.
       Note that the System Clock Prescaler can be used to implement run-time changes of the internal clock frequency while still
       ensuring stable operation. Refer to Section 5.8.11 “System Clock Prescaler” on page 56 for details.
5.8.9  Clock Output Buffer
       The device can output the system clock on the CLKO pin. To enable the output, the CKOUT Fuse has to be programmed.
       This mode is suitable when the chip clock is used to drive other circuits on the system. The clock also will be output during
       reset, and the normal operation of I/O pin will be overridden when the fuse is programmed. Any clock source, including the
       internal RC oscillator, can be selected when the clock is output on CLKO. If the system clock prescaler is used, it is the
       divided system clock that is output.
5.8.10 Timer/Counter Oscillator
       ATmega328P uses the same crystal oscillator for low-frequency oscillator and Timer/Counter oscillator. See Section 5.8.5
       “Low Frequency Crystal Oscillator” on page 53 for details on the oscillator and crystal requirements.
       ATmega328P share the Timer/Counter oscillator pins (TOSC1 and TOSC2) with XTAL1 and XTAL2. When using the
       Timer/Counter oscillator, the system clock needs to be four times the oscillator frequency. Due to this and the pin sharing,
       the Timer/Counter oscillator can only be used when the calibrated Internal RC oscillator is selected as system clock source.
       Applying an external clock source to TOSC1 can be done if EXTCLK in the ASSR register is written to logic one. See Section
       5.17.9 “Asynchronous Operation of Timer/Counter2” on page 148 for further description on selecting external clock as input
       instead of a 32.768kHz watch crystal.
5.8.11 System Clock Prescaler
       The ATmega328P has a system clock prescaler, and the system clock can be divided by setting the Section 5.8.12.2
       “CLKPR – Clock Prescale Register” on page 57. This feature can be used to decrease the system clock frequency and the
       power consumption when the requirement for processing power is low. This can be used with all clock source options, and it
       will affect the clock frequency of the CPU and all synchronous peripherals. clkI/O, clkADC, clkCPU, and clkFLASH are divided by
       a factor as shown in Table 5-131 on page 280.
       When switching between prescaler settings, the system clock prescaler ensures that no glitches occurs in the clock system.
       It also ensures that no intermediate frequency is higher than neither the clock frequency corresponding to the previous
       setting, nor the clock frequency corresponding to the new setting. The ripple counter that implements the prescaler runs at
       the frequency of the undivided clock, which may be faster than the CPU's clock frequency. Hence, it is not possible to
       determine the state of the prescaler - even if it were readable, and the exact time it takes to switch from one clock division to
       the other cannot be exactly predicted. From the time the CLKPS values are written, it takes between T1 + T2 and T1 + 2 * T2
       before the new clock frequency is active. In this interval, 2 active clock edges are produced. Here, T1 is the previous clock
       period, and T2 is the period corresponding to the new prescaler setting.
       To avoid unintentional changes of clock frequency, a special write procedure must be followed to change the CLKPS bits:
          1. Write the clock prescaler change enable (CLKPCE) bit to one and all other bits in CLKPR to zero.
          2.   Within four cycles, write the desired value to CLKPS while writing a zero to CLKPCE.
       Interrupts must be disabled when changing prescaler setting to make sure the write procedure is not interrupted.
56     ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.8.12 Register Description
5.8.12.1 OSCCAL – Oscillator Calibration Register
                  Bit          7         6         5          4           3           2          1         0
               (0x66)       CAL7       CAL6       CAL5      CAL4        CAL3        CAL2      CAL1       CAL0  OSCCAL
            Read/Write       R/W        R/W       R/W        R/W         R/W         R/W       R/W       R/W
            Initial Value                            Device Specific Calibration Value
        • Bits 7..0 – CAL7..0: Oscillator Calibration Value
        The oscillator calibration register is used to trim the calibrated internal RC oscillator to remove process variations from the
        oscillator frequency. A pre-programmed calibration value is automatically written to this register during chip reset, giving the
        factory calibrated frequency as specified in Table 5-128 on page 279. The application software can write this register to
        change the oscillator frequency. The oscillator can be calibrated to frequencies as specified in Table 5-128 on page 279.
        Calibration outside that range is not guaranteed.
        Note that this oscillator is used to time EEPROM and flash write accesses, and these write times will be affected accordingly.
        If the EEPROM or flash are written, do not calibrate to more than 8.8 MHz. Otherwise, the EEPROM or flash write may fail.
        The CAL7 bit determines the range of operation for the oscillator. Setting this bit to 0 gives the lowest frequency range,
        setting this bit to 1 gives the highest frequency range. The two frequency ranges are overlapping, in other words a setting of
        OSCCAL = 0x7F gives a higher frequency than OSCCAL = 0x80.
        The CAL6..0 bits are used to tune the frequency within the selected range. A setting of 0x00 gives the lowest frequency in
        that range, and a setting of 0x7F gives the highest frequency in the range.
5.8.12.2 CLKPR – Clock Prescale Register
                  Bit          7         6          5         4            3          2          1         0
               (0x61)      CLKPCE        –          –         –       CLKPS3      CLKPS2     CLKPS1     CLKPS0  CLKPR
            Read/Write       R/W         R          R         R          R/W         R/W       R/W        R/W
            Initial Value      0         0          0         0                    See Bit Description
        • Bit 7 – CLKPCE: Clock Prescaler Change Enable
        The CLKPCE bit must be written to logic one to enable change of the CLKPS bits. The CLKPCE bit is only updated when the
        other bits in CLKPR are simultaneously written to zero. CLKPCE is cleared by hardware four cycles after it is written or when
        CLKPS bits are written. Rewriting the CLKPCE bit within this time-out period does neither extend the time-out period, nor
        clear the CLKPCE bit.
        • Bits 3..0 – CLKPS3..0: Clock Prescaler Select Bits 3 - 0
        These bits define the division factor between the selected clock source and the internal system clock. These bits can be
        written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input
        to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used. The division factors are
        given in Table 5-19 on page 58.
        The CKDIV8 Fuse determines the initial value of the CLKPS bits. If CKDIV8 is unprogrammed, the CLKPS bits will be reset
        to “0000”. If CKDIV8 is programmed, CLKPS bits are reset to “0011”, giving a division factor of 8 at start up. This feature
        should be used if the selected clock source has a higher frequency than the maximum frequency of the device at the present
        operating conditions. Note that any value can be written to the CLKPS bits regardless of the CKDIV8 fuse setting. The
        application software must ensure that a sufficient division factor is chosen if the selected clock source has a higher
        frequency than the maximum frequency of the device at the present operating conditions. The device is shipped with the
        CKDIV8 fuse programmed.
                                                                                                       ATA6614Q [DATASHEET]           57
                                                                                                                 9240I–AUTO–03/16


         Table 5-19. Clock Prescaler Select
              CLKPS3                    CLKPS2                               CLKPS1                                   CLKPS0                                       Clock Division Factor
                  0                             0                                 0                                        0                                                       1
                  0                             0                                 0                                        1                                                       2
                  0                             0                                 1                                        0                                                       4
                  0                             0                                 1                                        1                                                       8
                  0                             1                                 0                                        0                                                       16
                  0                             1                                 0                                        1                                                       32
                  0                             1                                 1                                        0                                                       64
                  0                             1                                 1                                        1                                                       128
                  1                             0                                 0                                        0                                                       256
                  1                             0                                 0                                        1                                               Reserved
                  1                             0                                 1                                        0                                               Reserved
                  1                             0                                 1                                        1                                               Reserved
                  1                             1                                 0                                        0                                               Reserved
                  1                             1                                 0                                        1                                               Reserved
                  1                             1                                 1                                        0                                               Reserved
                  1                             1                                 1                                        1                                               Reserved
5.9      Power Management and Sleep Modes
         Sleep modes enable the application to shut down unused modules in the MCU, thereby saving power. The AVR® provides
         various sleep modes allowing the user to tailor the power consumption to the application’s requirements.
         When enabled, the Brown-out Detector (BOD) actively monitors the power supply voltage during the sleep periods. To
         further save power, it is possible to disable the BOD in some sleep modes. See “BOD Disable” on page 59 for more details.
5.9.1    Sleep Modes
         Figure 5-10 on page 48 presents the different clock systems in the ATmega328P, and their distribution. The figure is helpful
         in selecting an appropriate sleep mode. Table 5-20 shows the different sleep modes, their wake up sources BOD disable
         ability.
Table 5-20. Active Clock Domains and Wake-up Sources in the Different Sleep Modes.
                             Active Clock Domains                                 Oscillators                                                     Wake-up Sources
                                                                                  Main Clock       Timer Oscillator    INT1, INT0 and
                                                                                                                                        TWI Address                   SPM/EEPROM                              Software
Sleep Mode
                            clkCPU   clkFLASH
                                                    clkIO   clkADC       clkASY   Source Enabled   Enabled             Pin Change       Match             Timer2      Ready             ADC   WDT   Other/O   BOD Disable
Idle                                            X           X        X             X               X(2)                 X                X            X                X            X         X     X
                                                                                                      (2)               (3)                           (2)
ADC noise reduction                                         X        X             X               X                   X                 X            X                X            X         X
                                                                                                                        (3)
Power-down                                                                                                             X                 X                                                    X                 X
                                                                                                      (2)               (3)
Power-save                                                           X                             X                   X                 X            X                                       X                 X
Standby(1)                                                                         X                                   X(3)              X                                                    X                 X
                                                                     (2)                              (2)               (3)
Extended standby                                                     X             X               X                   X                 X            X                                       X                 X
Notes:   1. Only recommended with external crystal or resonator selected as clock source.
         2. If Timer/Counter2 is running in asynchronous mode.
         3. For INT1 and INT0, only level interrupt.
58       ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


      To enter any of the six sleep modes, the SE bit in SMCR must be written to logic one and a SLEEP instruction must be
      executed. The SM2, SM1, and SM0 bits in the SMCR register select which sleep mode (Idle, ADC noise reduction,
      power-down, power-save, standby, or extended standby) will be activated by the SLEEP instruction. See Table 5-21 on page
      62 for a summary.
      If an enabled interrupt occurs while the MCU is in a sleep mode, the MCU wakes up. The MCU is then halted for four cycles
      in addition to the start-up time, executes the interrupt routine, and resumes execution from the instruction following SLEEP.
      The contents of the register File and SRAM are unaltered when the device wakes up from sleep. If a reset occurs during
      sleep mode, the MCU wakes up and executes from the reset vector.
5.9.2 BOD Disable
      When the brown-out detector (BOD) is enabled by BODLEVEL fuses, Table 5-117 on page 265, the BOD is actively
      monitoring the power supply voltage during a sleep period. To save power, it is possible to disable the BOD by software for
      some of the sleep modes, see Table 5-20 on page 58. The sleep mode power consumption will then be at the same level as
      when BOD is globally disabled by fuses. If BOD is disabled in software, the BOD function is turned off immediately after
      entering the sleep mode. Upon wake-up from sleep, BOD is automatically enabled again. This ensures safe operation in
      case the VCC level has dropped during the sleep period.
      When the BOD has been disabled, the wake-up time from sleep mode will be approximately 60 µs to ensure that the BOD is
      working correctly before the MCU continues executing code.
      BOD disable is controlled by bit 6, BODS (BOD sleep) in the control register MCUCR, see Section 5.9.11.2 “MCUCR – MCU
      Control Register” on page 62. Writing this bit to one turns off the BOD in relevant sleep modes, while a zero in this bit keeps
      BOD active. Default setting keeps BOD active, i.e. BODS set to zero.
      Writing to the BODS bit is controlled by a timed sequence and an enable bit, see Section 5.9.11.2 “MCUCR – MCU Control
      Register” on page 62.
5.9.3 Idle Mode
      When the SM2..0 bits are written to 000, the SLEEP instruction makes the MCU enter Idle mode, stopping the CPU but
      allowing the SPI, USART, analog comparator, ADC, 2-wire serial interface, Timer/Counters, watchdog, and the interrupt
      system to continue operating. This sleep mode basically halts clkCPU and clkFLASH, while allowing the other clocks to run.
      Idle mode enables the MCU to wake up from external triggered interrupts as well as internal ones like the timer overflow and
      USART transmit complete interrupts. If wake-up from the analog comparator interrupt is not required, the analog comparator
      can be powered down by setting the ACD bit in the analog comparator control and status register – ACSR. This will reduce
      power consumption in Idle mode. If the ADC is enabled, a conversion starts automatically when this mode is entered.
5.9.4 ADC Noise Reduction Mode
      When the SM2..0 bits are written to 001, the SLEEP instruction makes the MCU enter ADC noise reduction mode, stopping
      the CPU but allowing the ADC, the external interrupts, the 2-wire Serial Interface address watch, Timer/Counter2(1), and the
      watchdog to continue operating (if enabled). This sleep mode basically halts clkI/O, clkCPU, and clkFLASH, while allowing the
      other clocks to run.
      This improves the noise environment for the ADC, enabling higher resolution measurements. If the ADC is enabled, a
      conversion starts automatically when this mode is entered. Apart from the ADC conversion complete interrupt, only an
      external reset, a watchdog system reset, a watchdog interrupt, a brown-out reset, a 2-wire serial interface address match, a
      Timer/Counter2 interrupt, an SPM/EEPROM ready interrupt, an external level interrupt on INT0 or INT1 or a pin change
      interrupt can wake up the MCU from ADC noise reduction mode.
      Note:     1.   Timer/Counter2 will only keep running in asynchronous mode, see Section 5.17 “8-bit Timer/Counter2 with
                     PWM and Asynchronous Operation” on page 139 for details.
                                                                                             ATA6614Q [DATASHEET]                  59
                                                                                                           9240I–AUTO–03/16


5.9.5   Power-down Mode
        When the SM2..0 bits are written to 010, the SLEEP instruction makes the MCU enter power-down mode. In this mode, the
        external oscillator is stopped, while the external interrupts, the 2-wire serial interface address watch, and the watchdog
        continue operating (if enabled). Only an external reset, a watchdog system reset, a watchdog interrupt, a brown-out reset, a
        2-wire serial Interface address match, an external level interrupt on INT0 or INT1, or a pin change interrupt can wake up the
        MCU. This sleep mode basically halts all generated clocks, allowing operation of asynchronous modules only.
        Note that if a level triggered interrupt is used for wake-up from power-down mode, the changed level must be held for some
        time to wake up the MCU. Refer to Section 5.12 “External Interrupts” on page 77 for details.
        When waking up from power-down mode, there is a delay from the wake-up condition occurs until the wake-up becomes
        effective. This allows the clock to restart and become stable after having been stopped. The wake-up period is defined by the
        same CKSEL Fuses that define the reset time-out period, as described in Section 5.8.2 “Clock Sources” on page 49.
5.9.6   Power-save Mode
        When the SM2..0 bits are written to 011, the SLEEP instruction makes the MCU enter power-save mode. This mode is
        identical to power-down, with one exception:
        If Timer/Counter2 is enabled, it will keep running during sleep. The device can wake up from either timer overflow or output
        compare event from Timer/Counter2 if the corresponding Timer/Counter2 interrupt enable bits are set in TIMSK2, and the
        Global Interrupt Enable bit in SREG is set.
        If Timer/Counter2 is not running, Power-down mode is recommended instead of power-save mode.
        The Timer/Counter2 can be clocked both synchronously and asynchronously in power-save mode. If Timer/Counter2 is not
        using the asynchronous clock, the Timer/Counter oscillator is stopped during sleep. If Timer/Counter2 is not using the
        synchronous clock, the clock source is stopped during sleep. Note that even if the synchronous clock is running in power-
        save, this clock is only available for Timer/Counter2.
5.9.7   Standby Mode
        When the SM2..0 bits are 110 and an external crystal/resonator clock option is selected, the SLEEP instruction makes the
        MCU enter standby mode. This mode is identical to power-down with the exception that the oscillator is kept running. From
        standby mode, the device wakes up in six clock cycles.
5.9.8   Extended Standby Mode
        When the SM2..0 bits are 111 and an external crystal/resonator clock option is selected, the SLEEP instruction makes the
        MCU enter extended standby mode. This mode is identical to power-save with the exception that the oscillator is kept
        running. From extended standby mode, the device wakes up in six clock cycles.
5.9.9   Power Reduction Register
        The power reduction register (PRR), see Section 5.9.11.3 “PRR – Power Reduction Register” on page 63, provides a
        method to stop the clock to individual peripherals to reduce power consumption. The current state of the peripheral is frozen
        and the I/O registers can not be read or written. Resources used by the peripheral when stopping the clock will remain
        occupied, hence the peripheral should in most cases be disabled before stopping the clock. Waking up a module, which is
        done by clearing the bit in PRR, puts the module in the same state as before shutdown.
        Module shutdown can be used in idle mode and active mode to significantly reduce the overall power consumption. In all
        other sleep modes, the clock is already stopped.
5.9.10 Minimizing Power Consumption
        There are several possibilities to consider when trying to minimize the power consumption in an AVR® controlled system. In
        general, sleep modes should be used as much as possible, and the sleep mode should be selected so that as few as
        possible of the device’s functions are operating. All functions not needed should be disabled. In particular, the following
        modules may need special consideration when trying to achieve the lowest possible power consumption.
5.9.10.1 Analog to Digital Converter
        If enabled, the ADC will be enabled in all sleep modes. To save power, the ADC should be disabled before entering any
        sleep mode. When the ADC is turned off and on again, the next conversion will be an extended conversion. Refer to Section
        5.23 “Analog-to-Digital Converter” on page 226 for details on ADC operation.
60      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.9.10.2 Analog Comparator
        When entering Idle mode, the analog comparator should be disabled if not used. When entering ADC noise reduction mode,
        the analog comparator should be disabled. In other sleep modes, the analog comparator is automatically disabled. However,
        if the analog comparator is set up to use the internal voltage reference as input, the analog comparator should be disabled in
        all sleep modes. Otherwise, the internal voltage reference will be enabled, independent of sleep mode. Refer to Section 5.22
        “Analog Comparator” on page 223 for details on how to configure the analog comparator.
5.9.10.3 Brown-out Detector
        If the brown-out detector is not needed by the application, this module should be turned off. If the brown-out detector is
        enabled by the BODLEVEL Fuses, it will be enabled in all sleep modes, and hence, always consume power. In the deeper
        sleep modes, this will contribute significantly to the total current consumption. Refer to Section 5.10.5 “Brown-out Detection”
        on page 66 for details on how to configure the brown-out detector.
5.9.10.4 Internal Voltage Reference
        The internal voltage reference will be enabled when needed by the brown-out detection, the analog comparator or the ADC.
        If these modules are disabled as described in the sections above, the internal voltage reference will be disabled and it will
        not be consuming power. When turned on again, the user must allow the reference to start up before the output is used. If
        the reference is kept on in sleep mode, the output can be used immediately. Refer to Section 5.10.7 “Internal Voltage
        Reference” on page 67 for details on the start-up time.
5.9.10.5 Watchdog Timer
        If the watchdog timer is not needed in the application, the module should be turned off. If the watchdog Timer is enabled, it
        will be enabled in all sleep modes and hence always consume power. In the deeper sleep modes, this will contribute
        significantly to the total current consumption. Refer to Section 5.10.8 “Watchdog Timer” on page 68 for details on how to
        configure the watchdog timer.
5.9.10.6 Port Pins
        When entering a sleep mode, all port pins should be configured to use minimum power. The most important is then to ensure
        that no pins drive resistive loads. In sleep modes where both the I/O clock (clkI/O) and the ADC clock (clkADC) are stopped,
        the input buffers of the device will be disabled. This ensures that no power is consumed by the input logic when not needed.
        In some cases, the input logic is needed for detecting wake-up conditions, and it will then be enabled. Refer to Section
        5.13.2.5 “Digital Input Enable and Sleep Modes” on page 86 for details on which pins are enabled. If the input buffer is
        enabled and the input signal is left floating or have an analog signal level close to VCC/2, the input buffer will use excessive
        power.
        For analog input pins, the digital input buffer should be disabled at all times. An analog signal level close to VCC/2 on an input
        pin can cause significant current even in active mode. Digital input buffers can be disabled by writing to the digital input
        disable registers (DIDR1 and DIDR0). Refer to Section 5.22.3.3 “DIDR1 – Digital Input Disable Register 1” on page 225 and
        Section 5.23.9.7 “DIDR0 – Digital Input Disable Register 0” on page 241 for details.
5.9.10.7 On-chip Debug System
        If the on-chip debug system is enabled by the DWEN fuse and the chip enters sleep mode, the main clock source is enabled
        and hence always consumes power. In the deeper sleep modes, this will contribute significantly to the total current
        consumption.
                                                                                                 ATA6614Q [DATASHEET]                   61
                                                                                                                 9240I–AUTO–03/16


5.9.11 Register Description
5.9.11.1 SMCR – Sleep Mode Control Register
        The Sleep Mode Control Register contains control bits for power management.
                 Bit           7       6         5           4          3         2         1         0
           0x33 (0x53)         –       –         –           –         SM2       SM1      SM0        SE       SMCR
           Read/Write          R       R         R           R         R/W       R/W       R/W      R/W
           Initial Value       0       0         0           0          0         0         0         0
        • Bits 7..4 Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bits 3..1 – SM2..0: Sleep Mode Select Bits 2, 1, and 0
        These bits select between the five available sleep modes as shown in Table 5-21.
        Table 5-21. Sleep Mode Select
                    SM2               SM1                   SM0            Sleep Mode
                     0                  0                     0            Idle
                     0                  0                     1            ADC noise reduction
                     0                  1                     0            Power-down
                     0                  1                     1            Power-save
                     1                  0                     0            Reserved
                     1                  0                     1            Reserved
                     1                  1                     0            Standby(1)
                     1                  1                     1            External standby(1)
        Note:        1.  Standby mode is only recommended for use with external crystals or resonators.
        • Bit 0 – SE: Sleep Enable
        The SE bit must be written to logic one to make the MCU enter the sleep mode when the SLEEP instruction is executed. To
        avoid the MCU entering the sleep mode unless it is the programmer’s purpose, it is recommended to write the sleep enable
        (SE) bit to one just before the execution of the SLEEP instruction and to clear it immediately after waking up.
5.9.11.2 MCUCR – MCU Control Register
                Bit          7        6           5            4          3          2         1       0
         0x35 (0x55)         –      BODS       BODSE        PUD           –          –     IVSEL     IVCE     MCUCR
          Read/Write         R        R          R           R/W          R          R      R/W       R/W
          Initial Value      0        0           0            0          0          0         0       0
        • Bit 6 – BODS: BOD Sleep
        The BODS bit must be written to logic one in order to turn off BOD during sleep, see Table 5-20 on page 58. Writing to the
        BODS bit is controlled by a timed sequence and an enable bit, BODSE in MCUCR. To disable BOD in relevant sleep modes,
        both BODS and BODSE must first be set to one. Then, to set the BODS bit, BODS must be set to one and BODSE must be
        set to zero within four clock cycles.
        The BODS bit is active three clock cycles after it is set. A sleep instruction must be executed while BODS is active in order to
        turn off the BOD for the actual sleep mode. The BODS bit is automatically cleared after three clock cycles.
        • Bit 5 – BODSE: BOD Sleep Enable
        BODSE enables setting of BODS control bit, as explained in BODS bit description. BOD disable is controlled by a timed
        sequence.
62      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.9.11.3 PRR – Power Reduction Register
                Bit         7         6          5            4          3         2           1           0
             (0x64)      PRTWI     PRTIM2     PRTIM0          –       PRTIM1     PRSPI   PRUSART0      PRADC       PRR
          Read/Write      R/W       R/W        R/W            R        R/W        R/W        R/W         R/W
          Initial Value     0         0          0            0          0         0           0           0
        • Bit 7 - PRTWI: Power Reduction TWI
        Writing a logic one to this bit shuts down the TWI by stopping the clock to the module. When waking up the TWI again, the
        TWI should be re initialized to ensure proper operation.
        • Bit 6 - PRTIM2: Power Reduction Timer/Counter2
        Writing a logic one to this bit shuts down the Timer/Counter2 module in synchronous mode (AS2 is 0). When the
        Timer/Counter2 is enabled, operation will continue like before the shutdown.
        • Bit 5 - PRTIM0: Power Reduction Timer/Counter0
        Writing a logic one to this bit shuts down the Timer/Counter0 module. When the Timer/Counter0 is enabled, operation will
        continue like before the shutdown.
        • Bit 4 - Res: Reserved bit
        This bit is reserved in ATmega328P and will always read as zero.
        • Bit 3 - PRTIM1: Power Reduction Timer/Counter1
        Writing a logic one to this bit shuts down the Timer/Counter1 module. When the Timer/Counter1 is enabled, operation will
        continue like before the shutdown.
        • Bit 2 - PRSPI: Power Reduction Serial Peripheral Interface
        If using debugWIRE on-chip debug system, this bit should not be written to one.
        Writing a logic one to this bit shuts down the serial peripheral interface by stopping the clock to the module. When waking up
        the SPI again, the SPI should be re initialized to ensure proper operation.
        • Bit 1 - PRUSART0: Power Reduction USART0
        Writing a logic one to this bit shuts down the USART by stopping the clock to the module. When waking up the USART
        again, the USART should be re initialized to ensure proper operation.
        • Bit 0 - PRADC: Power Reduction ADC
        Writing a logic one to this bit shuts down the ADC. The ADC must be disabled before shut down. The analog comparator
        cannot use the ADC input MUX when the ADC is shut down.
5.10    System Control and Reset
5.10.1 Resetting the AVR
        During reset, all I/O registers are set to their initial values, and the program starts execution from the reset vector. For the
        ATmega328P, the instruction placed at the reset vector must be an RJMP – relative jump – instruction to the reset handling
        routine. If the program never enables an interrupt source, the interrupt vectors are not used, and regular program code can
        be placed at these locations. This is also the case if the reset vector is in the application section while the interrupt vectors
        are in the boot section. The circuit diagram in Figure 5-14 on page 64 shows the reset logic. Table 5-131 on page 280
        defines the electrical parameters of the reset circuitry.
        The I/O ports of the AVR® are immediately reset to their initial state when a reset source goes active. This does not require
        any clock source to be running.
                                                                                                  ATA6614Q [DATASHEET]                  63
                                                                                                                 9240I–AUTO–03/16


      After all reset sources have gone inactive, a delay counter is invoked, stretching the internal reset. This allows the power to
      reach a stable level before normal operation starts. The time-out period of the delay counter is defined by the user through
      the SUT and CKSEL Fuses. The different selections for the delay period are presented in Section 5.8.2 “Clock Sources” on
      page 49.
5.10.2 Reset Sources
      The ATmega328P has four sources of reset:
       ● Power-on reset. The MCU is reset when the supply voltage is below the power-on reset threshold (VPOT).
        ●    External reset. The MCU is reset when a low level is present on the RESET pin for longer than the minimum pulse
             length.
        ●    Watchdog system reset. The MCU is reset when the watchdog timer period expires and the watchdog system reset
             mode is enabled.
        ●    Brown-out reset. The MCU is reset when the supply voltage VCC is below the brown-out reset threshold (VBOT) and the
             brown-out detector is enabled.
      Figure 5-14. Reset Logic
                                                                                   DATA BUS
                                                                             MCU Status
                                                                           Register (MCUSR)
                                                                            PORF   BORF   EXTRF   WDRF
                                                         Power-on Reset
                         VCC
                                                            Circuit
                                                            Brown-out
                                                           Reset Circuit
               BODLEVEL[2..0]
                                                                                                                                                        INTERNAL RESET
                                  Pull-up Resistor
                                                                                                                                                    Q
                                                           Reset Circuit                                                                        S
                                                                                                                                                R
                                                                                                                          COUNTER RESET
                                      Spike                 Watchdog
                      RESET
                                      Filter                 Timer
                    RSTDISBL
                                                            Watchdog
                                                            Oscillator
                                                                           CK                            Delay Counters
                                                             Clock
                                                                                                                                          TIMEOUT
                                                            Generator
                                                     CKSEL[3..0]
                                                       SUT[1..0]
64    ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.10.3 Power-on Reset
       A power-on Reset (POR) pulse is generated by an on-chip detection circuit. The detection level is defined in Section 5.28.5
       “System and Reset Characteristics” on page 280. The POR is activated whenever VCC is below the detection level. The POR
       circuit can be used to trigger the start-up reset, as well as to detect a failure in supply voltage.
       A power-on reset (POR) circuit ensures that the device is reset from power-on. Reaching the power-on reset threshold
       voltage invokes the delay counter, which determines how long the device is kept in RESET after VCC rise. The RESET signal
       is activated again, without any delay, when VCC decreases below the detection level.
       Figure 5-15. MCU Start-up, RESET Tied to VCC
                             VCC                 VPOT
                           RESET                 VRST
                                                       tTOUT
                       TIME-OUT
                       INTERNAL
                           RESET
       Figure 5-16. . MCU Start-up, RESET Extended Externally
                              VCC               VPOT
                                                                        V RST
                            RESET
                                                                              tTOUT
                         TIME-OUT
                        INTERNAL
                            RESET
       Table 5-22. Power On Reset Specifications
        Parameter                                                              Symbol          Min          Typ        Max       Units
        Power-on reset threshold voltage (rising)                                                           1.4                    V
                                                                                 VPOT
        Power-on reset threshold voltage (falling)(1)                                          1.0          1.3         1.6        V
        VCC Max. start voltage to ensure internal power-on reset
                                                                               VPORMAX                                  0.4        V
        signal
        VCC Min. start voltage to ensure internal power-on reset
                                                                               VPORMIN         -0.1                                V
        signal
        VCC rise rate to ensure power-on reset                                  VCCRR          0.01                              V/ms
       Note:     1.  Before rising, the supply has to be between VPORMIN and VPORMAX to ensure a reset
                                                                                                  ATA6614Q [DATASHEET]               65
                                                                                                                9240I–AUTO–03/16


5.10.4 External Reset
       An external reset is generated by a low level on the RESET pin. Reset pulses longer than the minimum pulse width (see
       Section 5.28.5 “System and Reset Characteristics” on page 280) will generate a reset, even if the clock is not running.
       Shorter pulses are not guaranteed to generate a reset. When the applied signal reaches the reset threshold voltage – VRST –
       on its positive edge, the delay counter starts the MCU after the time-out period – tTOUT – has expired. The external reset can
       be disabled by the RSTDISBL fuse, see Table 5-117 on page 265.
       Figure 5-17. External Reset During Operation
                               V CC
                            RESET
                                                  V RST
                                                                    tTOUT
                         TIME-OUT
                         INTERNAL
                            RESET
5.10.5 Brown-out Detection
       ATmega328P has an on-chip brown-out detection (BOD) circuit for monitoring the VCC level during operation by comparing it
       to a fixed trigger level. The trigger level for the BOD can be selected by the BODLEVEL fuses. The trigger level has a
       hysteresis to ensure spike free brown-out detection. The hysteresis on the detection level should be interpreted as VBOT+ =
       VBOT + VHYST/2 and VBOT- = VBOT - VHYST/2.When the BOD is enabled, and VCC decreases to a value below the trigger level
       (VBOT- in
       Figure 5-18 on page 66), the brown-out reset is immediately activated. When VCC increases above the trigger level (VBOT+ in
       Figure 5-18 on page 66), the delay counter starts the MCU after the time-out period tTOUT has expired.
       The BOD circuit will only detect a drop in VCC if the voltage stays below the trigger level for longer than tBOD given in Section
       5.28.5 “System and Reset Characteristics” on page 280.
       Figure 5-18. Brown-out Reset During Operation
                                         VCC
                                                                                        VBOT+
                                                              VBOT-
                                       RESET
                                                                                         tTOUT
                                    TIME-OUT
                                   INTERNAL
                                       RESET
66     ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.10.6 Watchdog System Reset
        When the watchdog times out, it will generate a short reset pulse of one CK cycle duration. On the falling edge of this pulse,
        the delay timer starts counting the Time-out period tTOUT. Refer to Section 5.10.8 “Watchdog Timer” on page 68 for details on
        operation of the watchdog timer.
        Figure 5-19. Watchdog System Reset During Operation
                               VCC
                             RESET
                                                          1 CK Cycle
                               WDT
                         TIME-OUT
                                                             tTOUT
                             RESET
                          Time-OUT
                         INTERNAL
                             RESET
5.10.7 Internal Voltage Reference
        ATmega328P features an internal bandgap reference. This reference is used for brown-out detection, and it can be used as
        an input to the analog comparator or the ADC.
5.10.7.1 Voltage Reference Enable Signals and Start-up Time
        The voltage reference has a start-up time that may influence the way it should be used. The start-up time is given in Section
        5.28.5 “System and Reset Characteristics” on page 280. To save power, the reference is not always turned on. The
        reference is on during the following situations:
          1. When the BOD is enabled (by programming the BODLEVEL [2:0] fuses).
          2.   When the bandgap reference is connected to the analog comparator (by setting the ACBG bit in ACSR).
          3.   When the ADC is enabled.
        Thus, when the BOD is not enabled, after setting the ACBG bit or enabling the ADC, the user must always allow the
        reference to start up before the output from the analog comparator or ADC is used. To reduce power consumption in power-
        down mode, the user can avoid the three conditions above to ensure that the reference is turned off before entering power-
        down mode.
                                                                                              ATA6614Q [DATASHEET]                  67
                                                                                                            9240I–AUTO–03/16


5.10.8 Watchdog Timer
5.10.8.1 Features
        ●    Clocked from separate on-chip oscillator
        ●    3 operating modes
                ●   Interrupt
                ●   System reset
                ●   Interrupt and system reset
        ●    Selectable time-out period from 16ms to 8s
        ●    Possible hardware fuse watchdog always on (WDTON) for fail-safe mode
5.10.8.2 Overview
       ATmega328P has an enhanced watchdog timer (WDT). The WDT is a timer counting cycles of a separate on-chip 128kHz
       oscillator. The WDT gives an interrupt or a system reset when the counter reaches a given time-out value. In normal
       operation mode, it is required that the system uses the WDR - watchdog timer reset - instruction to restart the counter before
       the time-out value is reached. If the system doesn't restart the counter, an interrupt or system reset will be issued.
       Figure 5-20. Watchdog Timer
                                       128kHz                                             Watchdog
                                      Oscillator                                          Prescaler
                                                         OSC/2K   OSC/4K   OSC/8K   OSC/16K   OSC/32K   OSC/64K   OSC/128K   OSC/256K   OSC/512K   OSC/1024K
                                                                                                                                                               WDP0
                                                                                                                                                               WDP1
                                   WATCHDOG                                                                                                                    WDP2
                                       RESET                                                                                                                   WDP3
                                         WDE
                                                                                                                                                                 MCU RESET
                                         WDIF
                                                                                                                                                                 INTERRUPT
                                         WDIE
       In interrupt mode, the WDT gives an interrupt when the timer expires. This interrupt can be used to wake the device from
       sleep-modes, and also as a general system timer. One example is to limit the maximum time allowed for certain operations,
       giving an interrupt when the operation has run longer than expected. In system reset mode, the WDT gives a reset when the
       timer expires. This is typically used to prevent system hang-up in case of runaway code. The third mode, interrupt and
       system reset mode, combines the other two modes by first giving an interrupt and then switch to system reset mode. This
       mode will for instance allow a safe shutdown by saving critical parameters before a system reset.
       The watchdog always on (WDTON) fuse, if programmed, will force the watchdog timer to system reset mode. With the fuse
       programmed the system reset mode bit (WDE) and Interrupt mode bit (WDIE) are locked to 1 and 0 respectively. To further
       ensure program security, alterations to the watchdog set-up must follow timed sequences.
       The sequence for clearing WDE and changing time-out configuration is as follows:
        1. In the same operation, write a logic one to the watchdog change enable bit (WDCE) and WDE. A logic one must
             be written to WDE regardless of the previous value of the WDE bit.
        2.   Within the next four clock cycles, write the WDE and watchdog prescaler bits (WDP) as desired, but with the
             WDCE bit cleared. This must be done in one operation.
68     ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


The following code example shows one assembly and one C function for turning off the watchdog timer. The example
assumes that interrupts are controlled (e.g. by disabling interrupts globally) so that no interrupts will occur during the
execution of these functions.
 Assembly Code Example(1)
          WDT_off:
                    ; Turn off global interrupt
                    cli
                    ; Reset Watchdog Timer
                    wdr
                    ; Clear WDRF in MCUSR
                    in       r16, MCUSR
                    andi r16, (0xff & (0<<WDRF))
                    out      MCUSR, r16
                    ; Write logical one to WDCE and WDE
                    ; Keep old prescaler setting to prevent unintentional time-out
                    lds r16, WDTCSR
                    ori      r16, (1<<WDCE) | (1<<WDE)
                    sts WDTCSR, r16
                    ; Turn off WDT
                    ldi      r16, (0<<WDE)
                    sts WDTCSR, r16
                    ; Turn on global interrupt
                    sei
                    ret
 C Code Example(1)
          void WDT_off(void)
          {
                    __disable_interrupt();
                    __watchdog_reset();
                    /* Clear WDRF in MCUSR */
                    MCUSR &= ~(1<<WDRF);
                    /* Write logical one to WDCE and WDE */
                    /* Keep old prescaler setting to prevent unintentional time-out */
                    WDTCSR |= (1<<WDCE) | (1<<WDE);
                    /* Turn off WDT */
                    WDTCSR = 0x00;
                    __enable_interrupt();
          }
Notes:   1.   See Section 5.5 “About Code Examples” on page 32.
         2.   If the watchdog is accidentally enabled, for example by a runaway pointer or brown-out condition, the device
              will be reset and the watchdog timer will stay enabled. If the code is not set up to handle the watchdog, this
              might lead to an eternal loop of time-out resets. To avoid this situation, the application software should always
              clear the watchdog system reset flag (WDRF) and the WDE control bit in the initialization routine, even if the
              watchdog is not in use.
                                                                                         ATA6614Q [DATASHEET]                69
                                                                                                        9240I–AUTO–03/16


   The following code example shows one assembly and one C function for changing the time-out value of the watchdog timer.
    Assembly Code Example(1)
             WDT_Prescaler_Change:
                       ; Turn off global interrupt
                       cli
                       ; Reset Watchdog Timer
                       wdr
                       ; Start timed sequence
                       lds r16, WDTCSR
                       ori      r16, (1<<WDCE) | (1<<WDE)
                       sts WDTCSR, r16
                       ; -- Got four cycles to set the new values from here -
                       ; Set new prescaler(time-out) value = 64K cycles (~0.5 s)
                       ldi      r16, (1<<WDE) | (1<<WDP2) | (1<<WDP0)
                       sts WDTCSR, r16
                       ; -- Finished setting new values, used 2 cycles -
                       ; Turn on global interrupt
                       sei
                       ret
    C Code Example(1)
             void WDT_Prescaler_Change(void)
             {
                       __disable_interrupt();
                       __watchdog_reset();
                       /* Start timed equence */
                       WDTCSR |= (1<<WDCE) | (1<<WDE);
                       /* Set new prescaler(time-out) value = 64K cycles (~0.5 s) */
                       WDTCSR = (1<<WDE) | (1<<WDP2) | (1<<WDP0);
                       __enable_interrupt();
             }
   Notes:   1.   See Section 5.5 “About Code Examples” on page 32.
            2.   The watchdog timer should be reset before any change of the WDP bits, since a change in the WDP bits can
                 result in a time-out when switching to a shorter time-out period.
70 ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


5.10.9 Register Description
5.10.9.1 MCUSR – MCU Status Register
        The MCU status register provides information on which reset source caused an MCU reset.
                 Bit           7          6         5          4          3            2         1         0
           0x35 (0x55)         –          –         –          –       WDRF        BORF      EXTRF      PORF      MCUSR
           Read/Write          R         R         R           R        R/W          R/W       R/W       R/W
           Initial Value       0          0         0          0                  See Bit Description
        • Bit 7..4: Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 3 – WDRF: Watchdog System Reset Flag
        This bit is set if a watchdog system reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.
        • Bit 2 – BORF: Brown-out Reset Flag
        This bit is set if a brown-out reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.
        • Bit 1 – EXTRF: External Reset Flag
        This bit is set if an external reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.
        • Bit 0 – PORF: Power-on Reset Flag
        This bit is set if a power-on reset occurs. The bit is reset only by writing a logic zero to the flag.
        To make use of the reset flags to identify a reset condition, the user should read and then reset the MCUSR as early as
        possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by
        examining the reset flags.
5.10.9.2 WDTCSR – Watchdog Timer Control Register
                 Bit           7         6         5          4          3           2         1         0
              (0x60)         WDIF      WDIE     WDP3        WDCE       WDE        WDP2       WDP1      WDP0      WDTCSR
           Read/Write        R/W        R/W      R/W         R/W       R/W         R/W        R/W       R/W
           Initial Value       0         0         0          0          X           0         0         0
        • Bit 7 - WDIF: Watchdog Interrupt Flag
        This bit is set when a time-out occurs in the watchdog timer and the watchdog timer is configured for interrupt. WDIF is
        cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, WDIF is cleared by writing a
        logic one to the flag. When the I-bit in SREG and WDIE are set, the watchdog time-out Interrupt is executed.
        • Bit 6 - WDIE: Watchdog Interrupt Enable
        When this bit is written to one and the I-bit in the status register is set, the watchdog interrupt is enabled. If WDE is cleared in
        combination with this setting, the watchdog timer is in interrupt mode, and the corresponding interrupt is executed if time-out
        in the watchdog timer occurs. If WDE is set, the watchdog timer is in interrupt and system reset mode. The first time-out in
        the watchdog timer will set WDIF.
        Executing the corresponding interrupt vector will clear WDIE and WDIF automatically by hardware (the watchdog goes to
        system reset mode). This is useful for keeping the watchdog timer security while using the interrupt. To stay in Interrupt and
        system reset mode, WDIE must be set after each interrupt. This should however not be done within the interrupt service
        routine itself, as this might compromise the safety-function of the watchdog system reset mode. If the interrupt is not
        executed before the next time-out, a system reset will be applied.
                                                                                                     ATA6614Q [DATASHEET]                71
                                                                                                                  9240I–AUTO–03/16


   Table 5-23. Watchdog Timer Configuration
       WDTON(1)            WDE            WDIE        Mode                                   Action on Time-out
            1                0              0         Stopped                                None
            1                0              1         Interrupt mode                         Interrupt
            1                1              0         System reset mode                      Reset
                                                                                             Interrupt, then go to system reset
            1                1              1         Interrupt and system reset mode
                                                                                             mode
            0                x              x         System reset mode                      Reset
   Note:      1.  WDTON fuse set to “0” means programmed and “1” means unprogrammed.
   • Bit 4 - WDCE: Watchdog Change Enable
   This bit is used in timed sequences for changing WDE and prescaler bits. To clear the WDE bit, and/or change the prescaler
   bits, WDCE must be set.
   Once written to one, hardware will clear WDCE after four clock cycles.
   • Bit 3 - WDE: Watchdog System Reset Enable
   WDE is overridden by WDRF in MCUSR. This means that WDE is always set when WDRF is set. To clear WDE, WDRF
   must be cleared first. This feature ensures multiple resets during conditions causing failure, and a safe start-up after the
   failure.
   • Bit 5, 2..0 - WDP3..0: Watchdog Timer Prescaler 3, 2, 1 and 0
   The WDP3..0 bits determine the watchdog timer prescaling when the watchdog timer is running. The different prescaling
   values and their corresponding time-out periods are shown in Table 5-24.
   Table 5-24. Watchdog Timer Prescale Select
                                                                                                      Typical Time-out at
       WDP3        WDP2         WDP1        WDP0       Number of WDT Oscillator Cycles                     VCC = 5.0V
         0             0          0           0                  2K (2048) cycles                             16ms
         0             0          0           1                  4K (4096) cycles                             32ms
         0             0          1           0                  8K (8192) cycles                             64ms
         0             0          1           1                 16K (16384) cycles                           0.125s
         0             1          0           0                 32K (32768) cycles                            0.25s
         0             1          0           1                 64K (65536) cycles                             0.5s
         0             1          1           0               128K (131072) cycles                             1.0s
         0             1          1           1               256K (262144) cycles                             2.0s
         1             0          0           0               512K (524288) cycles                             4.0s
         1             0          0           1              1024K (1048576) cycles                            8.0s
         1             0          1           0
         1             0          1           1
         1             1          0           0
                                                                                      Reserved
         1             1          0           1
         1             1          1           0
         1             1          1           1
72 ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


5.11   Interrupts
       This section describes the specifics of the interrupt handling as performed in ATmega328P. For a general explanation of the
       AVR® interrupt handling, refer to Section 5.6.7 “Reset and Interrupt Handling” on page 39.
         ● Each interrupt vector occupies two instruction words in ATmega328P.
         ●    In ATmega328P, the reset vector is affected by the BOOTRST fuse, and the interrupt vector start address is affected
              by the IVSEL bit in MCUCR.
5.11.1 Interrupt Vectors in ATmega328P
       Table 5-25. Reset and Interrupt Vectors in ATmega328P
        Vector No.     Program Address       Source                    Interrupt Definition
                                                                       External pin, power-on reset, brown-out reset and watchdog
              1             0x0000           RESET
                                                                       system reset
              2              0x002           INT0                      External interrupt request 0
              3             0x0004           INT1                      External interrupt request 1
              4             0x0006           PCINT0                    Pin change interrupt request 0
              5             0x0008           PCINT1                    Pin change interrupt request 1
              6             0x000A           PCINT2                    Pin change interrupt request 2
              7             0x000C           WDT                       Watchdog time-out interrupt
              8             0x000E           TIMER2 COMPA              Timer/Counter2 compare match A
              9             0x0010           TIMER2 COMPB              Timer/Counter2 compare match B
             10             0x0012           TIMER2 OVF                Timer/Counter2 overflow
             11             0x0014           TIMER1 CAPT               Timer/Counter1 capture event
             12             0x0016           TIMER1 COMPA              Timer/Counter1 compare match A
             13             0x0018           TIMER1 COMPB              Timer/Counter1 compare match B
             14             0x001A           TIMER1 OVF                Timer/Counter1 overflow
             15             0x001C           TIMER0 COMPA              Timer/Counter0 compare match A
             16             0x001E           TIMER0 COMPB              Timer/Counter0 compare match B
             17             0x0020           TIMER0 OVF                Timer/Counter0 overflow
             18             0x0022           SPI, STC                  SPI serial transfer complete
             19             0x0024           USART, RX                 USART Rx complete
             20             0x0026           USART, UDRE               USART, data register empty
             21             0x0028           USART, TX                 USART, Tx complete
             22             0x002A           ADC                       ADC conversion complete
             23             0x002C           EE READY                  EEPROM ready
             24             0x002E           ANALOG COMP               Analog comparator
             25             0x0030           TWI                       2-wire serial interface
             26             0x0032           SPM READY                 Store program memory ready
                                                                                               ATA6614Q [DATASHEET]              73
                                                                                                            9240I–AUTO–03/16


   Table 5-26 on page 74 shows reset and interrupt vectors placement for the various combinations of BOOTRST and IVSEL
   settings. If the program never enables an interrupt source, the interrupt vectors are not used, and regular program code can
   be placed at these locations. This is also the case if the reset vector is in the application section while the interrupt vectors
   are in the boot section or vice versa.
   Table 5-26. Reset and Interrupt Vectors Placement in ATmega328P(1)
         BOOTRST             IVSEL       Reset Address                       Interrupt Vectors Start Address
              1                 0        0x000                               0x002
              1                 1        0x000                               Boot Reset Address + 0x0002
              0                 0        Boot Reset Address                  0x002
              0                 1        Boot Reset Address                  Boot Reset Address + 0x0002
   Note:     1.    For the BOOTRST Fuse “1” means unprogrammed while “0” means programmed.
   The most typical and general program setup for the Reset and Interrupt Vector Addresses in ATmega328P is:
             Address            Labels Code                           Comments
             0x0000             jmp      RESET                        ; Reset Handler
             0x0002             jmp      EXT_INT0                     ; IRQ0 Handler
             0x0004             jmp      EXT_INT1                     ; IRQ1 Handler
             0x0006             jmp      PCINT0                       ; PCINT0 Handler
             0x0008             jmp      PCINT1                       ; PCINT1 Handler
             0x000A             jmp      PCINT2                       ; PCINT2 Handler
             0x000C             jmp      WDT                          ; Watchdog Timer Handler
             0x000E             jmp      TIM2_COMPA                   ; Timer2 Compare A Handler
             0x0010             jmp      TIM2_COMPB                   ; Timer2 Compare B Handler
             0x0012             jmp      TIM2_OVF                     ; Timer2 Overflow Handler
             0x0014             jmp      TIM1_CAPT                    ; Timer1 Capture Handler
             0x0016             jmp      TIM1_COMPA                   ; Timer1 Compare A Handler
             0x0018             jmp      TIM1_COMPB                   ; Timer1 Compare B Handler
             0x001A             jmp      TIM1_OVF                     ; Timer1 Overflow Handler
             0x001C             jmp      TIM0_COMPA                   ; Timer0 Compare A Handler
             0x001E             jmp      TIM0_COMPB                   ; Timer0 Compare B Handler
             0x0020             jmp      TIM0_OVF                     ; Timer0 Overflow Handler
             0x0022             jmp      SPI_STC                      ; SPI Transfer Complete Handler
             0x0024             jmp      USART_RXC                    ; USART, RX Complete Handler
             0x0026             jmp      USART_UDRE                   ; USART, UDR Empty Handler
             0x0028             jmp      USART_TXC                    ; USART, TX Complete Handler
             0x002A             jmp      ADC                          ; ADC Conversion Complete Handler
             0x002C             jmp      EE_RDY                       ; EEPROM Ready Handler
             0x002E             jmp      ANA_COMP                     ; Analog Comparator Handler
             0x0030             jmp      TWI                          ; 2-wire Serial Interface Handler
             0x0032             jmp      SPM_RDY                      ; Store Program Memory Ready Handler
             ;
             0x0033 RESET: ldi           r16, high(RAMEND)            ; Main program start
             0x0034             out      SPH,r16                      ; Set Stack Pointer to top of RAM
             0x0035             ldi      r16, low(RAMEND)
             0x0036             out      SPL,r16
             0x0037             sei                                   ; Enable interrupts
             0x0038             <instr> xxx
             ...                ...      ...                          ...
74 ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


When the BOOTRST fuse is unprogrammed, the boot section size set to 2Kbytes and the IVSEL bit in the MCUCR register
is set before any interrupts are enabled, the most typical and general program setup for the reset and interrupt vector
addresses in ATmega328P is:
          Address            Labels Code                         Comments
          0x0000 RESET: ldi           r16,high(RAMEND)           ; Main program start
          0x0001             out      SPH,r16                    ; Set Stack Pointer to top of RAM
          0x0002             ldi      r16,low(RAMEND)
          0x0003             out      SPL,r16
          0x0004             sei                                 ; Enable interrupts
          0x0005             <instr> xxx
          ;
          .org 0x3C02
          0x3C02             jmp      EXT_INT0                   ; IRQ0 Handler
          0x3C04             jmp      EXT_INT1                   ; IRQ1 Handler
          ...                ...      ...                        ;
          0x3C32             jmp      SPM_RDY                    ; Store Program Memory Ready Handler
When the BOOTRST fuse is programmed and the boot section size set to 2Kbytes, the most typical and general program
setup for the reset and interrupt vector addresses in ATmega328P is:
          Address            Labels Code                         Comments
          .org 0x0002
          0x0002             jmp      EXT_INT0                   ; IRQ0 Handler
          0x0004             jmp      EXT_INT1                   ; IRQ1 Handler
          ...                ...      ...                        ;
          0x0032             jmp      SPM_RDY                    ; Store Program Memory Ready Handler
          ;
          .org 0x3C00
          0x3C00 RESET: ldi           r16,high(RAMEND)           ; Main program start
          0x3C01             out      SPH,r16                    ; Set Stack Pointer to top of RAM
          0x3C02             ldi      r16,low(RAMEND)
          0x3C03             out      SPL,r16
          0x3C04             sei                                 ; Enable interrupts
          0x3C05             <instr> xxx
When the BOOTRST Fuse is programmed, the boot section size set to 2Kbytes and the IVSEL bit in the MCUCR register is
set before any interrupts are enabled, the most typical and general program setup for the reset and interrupt vector
addresses in ATmega328P is:
          Address            Labels Code                         Comments
          ;
          .org 0x3C00
          0x3C00             jmp      RESET                      ; Reset handler
          0x3C02             jmp      EXT_INT0                   ; IRQ0 Handler
          0x3C04             jmp      EXT_INT1                   ; IRQ1 Handler
          ...                ...      ...                        ;
          0x3C32             jmp      SPM_RDY                    ; Store Program Memory Ready Handler
          ;
          0x3C33 RESET: ldi           r16,high(RAMEND)           ; Main program start
          0x3C34             out      SPH,r16                    ; Set Stack Pointer to top of RAM
          0x3C35             ldi      r16,low(RAMEND)
          0x3C36             out      SPL,r16
          0x3C37             sei                                 ; Enable interrupts
          0x3C38             <instr> xxx
                                                                                     ATA6614Q [DATASHEET]               75
                                                                                                    9240I–AUTO–03/16


5.11.2 Register Description
5.11.2.1 Moving Interrupts Between Application and Boot Space
        The MCU control register controls the placement of the interrupt vector table.
5.11.2.2 MCUCR – MCU Control Register
                 Bit             7         6          5         4         3          2         1          0
           0x35 (0x55)           –       BODS      BODSE       PUD        –          –      IVSEL       IVCE     MCUCR
           Read/Write           R          R         R         R/W        R          R       R/W         R/W
           Initial Value         0         0          0         0         0          0         0          0
        • Bit 1 – IVSEL: Interrupt Vector Select
        When the IVSEL bit is cleared (zero), the interrupt vectors are placed at the start of the Flash memory. When this bit is set
        (one), the interrupt vectors are moved to the beginning of the boot loader section of the flash. The actual address of the start
        of the boot flash section is determined by the BOOTSZ fuses. Refer to Section 5.26 “Boot Loader Support – Read-while-
        write Self-programming” on page 250 for details. To avoid unintentional changes of interrupt vector tables, a special write
        procedure must be followed to change the IVSEL bit:
          a. Write the interrupt vector change enable (IVCE) bit to one.
          b.     Within four cycles, write the desired value to IVSEL while writing a zero to IVCE.
        Interrupts will automatically be disabled while this sequence is executed. Interrupts are disabled in the cycle IVCE is set, and
        they remain disabled until after the instruction following the write to IVSEL. If IVSEL is not written, interrupts remain disabled
        for four cycles. The I-bit in the status register is unaffected by the automatic disabling.
        Note:            If interrupt vectors are placed in the boot loader section and boot lock bit BLB02 is programmed, interrupts are
                         disabled while executing from the application section. If interrupt vectors are placed in the application section
                         and boot lock bit BLB12 is programed, interrupts are disabled while executing from the boot loader section.
                         Refer to Section 5.26 “Boot Loader Support – Read-while-write Self-programming” on page 250 for details on
                         boot lock bits.
        This bit is not available in ATmega328P.
        • Bit 0 – IVCE: Interrupt Vector Change Enable
        The IVCE bit must be written to logic one to enable change of the IVSEL bit. IVCE is cleared by hardware four cycles after it
        is written or when IVSEL is written. Setting the IVCE bit will disable interrupts, as explained in the IVSEL description above.
        See code example below.
         Assembly Code Example
                     Move_interrupts:
                                ; Enable change of Interrupt Vectors
                                ldi                 r16, (1<<IVCE)
                                out                 MCUCR, r16
                                ; Move interrupts to Boot Flash section
                                ldi                 r16, (1<<IVSEL)
                                out                 MCUCR, r16
                                ret
         C Code Example
                     void Move_interrupts(void)
                     {
                                /* Enable change of Interrupt Vectors */
                                MCUCR = (1<<IVCE);
                                /* Move interrupts to Boot Flash section */
                                MCUCR = (1<<IVSEL);
                     }
        This bit is not available in ATmega328P.
76      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.12   External Interrupts
       The external interrupts are triggered by the INT0 and INT1 pins or any of the PCINT23..0 pins. Observe that, if enabled, the
       interrupts will trigger even if the INT0 and INT1 or PCINT23..0 pins are configured as outputs. This feature provides a way of
       generating a software interrupt. The pin change interrupt PCI2 will trigger if any enabled PCINT23..16 pin toggles. The pin
       change interrupt PCI1 will trigger if any enabled PCINT14..8 pin toggles. The pin change interrupt PCI0 will trigger if any
       enabled PCINT7..0 pin toggles. The PCMSK2, PCMSK1 and PCMSK0 registers control which pins contribute to the pin
       change interrupts. Pin change interrupts on PCINT23..0 are detected asynchronously. This implies that these interrupts can
       be used for waking the part also from sleep modes other than Idle mode.
       The INT0 and INT1 interrupts can be triggered by a falling or rising edge or a low level. This is set up as indicated in the
       specification for the external interrupt control register A – EICRA. When the INT0 or INT1 interrupts are enabled and are
       configured as level triggered, the interrupts will trigger as long as the pin is held low. Note that recognition of falling or rising
       edge interrupts on INT0 or INT1 requires the presence of an I/O clock, described in Section 5.8.1 “Clock Systems and their
       Distribution” on page 48. Low level interrupt on INT0 and INT1 is detected asynchronously. This implies that this interrupt
       can be used for waking the part also from sleep modes other than Idle mode. The I/O clock is halted in all sleep modes
       except Idle mode.
       Note that if a level triggered interrupt is used for wake-up from power-down, the required level must be held long enough for
       the MCU to complete the wake-up to trigger the level interrupt. If the level disappears before the end of the start-up time, the
       MCU will still wake up, but no interrupt will be generated. The start-up time is defined by the SUT and CKSEL Fuses as
       described in Section 5.8 “System Clock and Clock Options” on page 48.
5.12.1 Pin Change Interrupt Timing
       An example of timing of a pin change interrupt is shown in Figure 5-21.
       Figure 5-21. Timing of Pin Change Interrupts
                                                                                              0
                                                                                                         pcint_sync   pcint_set/flag
                                         pin_lat     pin_sync                     pcint_in(0)
               PCINT(0)                          D Q                                                D  Q          D Q           D    Q PCIF
                  pin
                                 LE                                                           x
                                                             PCINT(0) in PCMSK(x)
                      clk                                                                       clk
                                     clk
                              PCINT(0)
                                 pin_lat
                              pin_sync
                             pcint_in(0)
                             pcint_sync
                          pcint_set/flag
                                   PCIF
                                                                                                      ATA6614Q [DATASHEET]                  77
                                                                                                                      9240I–AUTO–03/16


5.12.2 Register Description
5.12.2.1 EICRA – External Interrupt Control Register A
        The external interrupt control register A contains control bits for interrupt sense control.
                 Bit        7           6         5          4         3          2         1          0
              (0x69)        –           –         –          –      ISC11       ISC10     ISC01      ISC00    EICRA
           Read/Write       R           R         R         R        R/W         R/W       R/W        R/W
           Initial Value    0           0         0          0         0          0         0          0
        • Bit 7..4 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 3, 2 – ISC11, ISC10: Interrupt Sense Control 1 Bit 1 and Bit 0
        The external interrupt 1 is activated by the external pin INT1 if the SREG I-flag and the corresponding interrupt mask are set.
        The level and edges on the external INT1 pin that activate the interrupt are defined in Table 5-27. The value on the INT1 pin
        is sampled before detecting edges. If edge or toggle interrupt is selected, pulses that last longer than one clock period will
        generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt. If low level interrupt is selected, the low
        level must be held until the completion of the currently executing instruction to generate an interrupt.
        Table 5-27. Interrupt 1 Sense Control
               ISC11          ISC10         Description
                   0             0          The low level of INT1 generates an interrupt request.
                   0             1          Any logical change on INT1 generates an interrupt request.
                   1             0          The falling edge of INT1 generates an interrupt request.
                   1             1          The rising edge of INT1 generates an interrupt request.
        • Bit 1, 0 – ISC01, ISC00: Interrupt Sense Control 0 Bit 1 and Bit 0
        The external interrupt 0 is activated by the external pin INT0 if the SREG I-flag and the corresponding interrupt mask are set.
        The level and edges on the external INT0 pin that activate the interrupt are defined in Table 5-28. The value on the INT0 pin
        is sampled before detecting edges. If edge or toggle interrupt is selected, pulses that last longer than one clock period will
        generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt. If low level interrupt is selected, the low
        level must be held until the completion of the currently executing instruction to generate an interrupt.
        Table 5-28. Interrupt 0 Sense Control
               ISC01          ISC00         Description
                   0             0          The low level of INT0 generates an interrupt request.
                   0             1          Any logical change on INT0 generates an interrupt request.
                   1             0          The falling edge of INT0 generates an interrupt request.
                   1             1          The rising edge of INT0 generates an interrupt request.
78      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.12.2.2 EIMSK – External Interrupt Mask Register
                 Bit         7           6          5         4          3          2          1          0
          0x1D (0x3D)        –           –          –         –          –          –        INT1       INT0       EIMSK
           Read/Write        R           R          R         R          R         R         R/W        R/W
           Initial Value     0           0          0         0          0          0          0          0
        • Bit 7..2 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 1 – INT1: External Interrupt Request 1 Enable
        When the INT1 bit is set (one) and the I-bit in the status register (SREG) is set (one), the external pin interrupt is enabled.
        The interrupt sense control1 bits 1/0 (ISC11 and ISC10) in the external interrupt control register A (EICRA) define whether
        the external interrupt is activated on rising and/or falling edge of the INT1 pin or level sensed. Activity on the pin will cause an
        interrupt request even if INT1 is configured as an output. The corresponding interrupt of external interrupt request 1 is
        executed from the INT1 interrupt vector.
        • Bit 0 – INT0: External Interrupt Request 0 Enable
        When the INT0 bit is set (one) and the I-bit in the status register (SREG) is set (one), the external pin interrupt is enabled.
        The interrupt sense control0 bits 1/0 (ISC01 and ISC00) in the external interrupt control register A (EICRA) define whether
        the external interrupt is activated on rising and/or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an
        interrupt request even if INT0 is configured as an output. The corresponding interrupt of external interrupt request 0 is
        executed from the INT0 interrupt vector.
5.12.2.3 EIFR – External Interrupt Flag Register
                 Bit         7           6          5         4          3          2          1          0
          0x1C (0x3C)        –           –          –         –          –          –       INTF1      INTF0        EIFR
           Read/Write        R           R          R         R          R         R         R/W        R/W
           Initial Value     0           0          0         0          0          0          0          0
        • Bit 7..2 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 1 – INTF1: External Interrupt Flag 1
        When an edge or logic change on the INT1 pin triggers an interrupt request, INTF1 becomes set (one). If the I-bit in SREG
        and the INT1 bit in EIMSK are set (one), the MCU will jump to the corresponding interrupt vector. The flag is cleared when
        the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. This flag is always cleared
        when INT1 is configured as a level interrupt.
        • Bit 0 – INTF0: External Interrupt Flag 0
        When an edge or logic change on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-bit in SREG
        and the INT0 bit in EIMSK are set (one), the MCU will jump to the corresponding interrupt vector. The flag is cleared when
        the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. This flag is always cleared
        when INT0 is configured as a level interrupt.
                                                                                                   ATA6614Q [DATASHEET]                    79
                                                                                                                   9240I–AUTO–03/16


5.12.2.4 PCICR – Pin Change Interrupt Control Register
                 Bit          7        6          5           4         3         2          1          0
              (0x68)          –        –          –           –         –       PCIE2      PCIE1     PCIE0        PCICR
           Read/Write         R        R          R           R         R        R/W        R/W       R/W
           Initial Value      0        0          0           0         0         0          0          0
        • Bit 7..3 - Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 2 - PCIE2: Pin Change Interrupt Enable 2
        When the PCIE2 bit is set (one) and the I-bit in the status register (SREG) is set (one), pin change interrupt 2 is enabled. Any
        change on any enabled PCINT23..16 pin will cause an interrupt. The corresponding interrupt of pin change interrupt request
        is executed from the PCI2 interrupt vector. PCINT23..16 pins are enabled individually by the PCMSK2 register.
        • Bit 1 - PCIE1: Pin Change Interrupt Enable 1
        When the PCIE1 bit is set (one) and the I-bit in the status register (SREG) is set (one), pin change interrupt 1 is enabled. Any
        change on any enabled PCINT14..8 pin will cause an interrupt. The corresponding interrupt of pin change interrupt request is
        executed from the PCI1 Interrupt Vector. PCINT14..8 pins are enabled individually by the PCMSK1 register.
        • Bit 0 - PCIE0: Pin Change Interrupt Enable 0
        When the PCIE0 bit is set (one) and the I-bit in the status register (SREG) is set (one), pin change interrupt 0 is enabled. Any
        change on any enabled PCINT7..0 pin will cause an interrupt. The corresponding interrupt of pin change interrupt request is
        executed from the PCI0 Interrupt vector. PCINT7..0 pins are enabled individually by the PCMSK0 register.
5.12.2.5 PCIFR – Pin Change Interrupt Flag Register
                 Bit          7        6          5           4         3         2          1          0
          0x1B (0x3B)         –        –          –           –         –       PCIF2      PCIF1     PCIF0        PCIFR
           Read/Write         R        R          R           R         R        R/W        R/W       R/W
           Initial Value      0        0          0           0         0         0          0          0
        • Bit 7..3 - Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 2 - PCIF2: Pin Change Interrupt Flag 2
        When a logic change on any PCINT23..16 pin triggers an interrupt request, PCIF2 becomes set (one). If the I-bit in SREG
        and the PCIE2 bit in PCICR are set (one), the MCU will jump to the corresponding Interrupt vector. The flag is cleared when
        the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.
        • Bit 1 - PCIF1: Pin Change Interrupt Flag 1
        When a logic change on any PCINT14..8 pin triggers an interrupt request, PCIF1 becomes set (one). If the I-bit in SREG and
        the PCIE1 bit in PCICR are set (one), the MCU will jump to the corresponding interrupt vector. The flag is cleared when the
        interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.
        • Bit 0 - PCIF0: Pin Change Interrupt Flag 0
        When a logic change on any PCINT7..0 pin triggers an interrupt request, PCIF0 becomes set (one). If the I-bit in SREG and
        the PCIE0 bit in PCICR are set (one), the MCU will jump to the corresponding interrupt vector. The flag is cleared when the
        interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.
80      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.12.2.6 PCMSK2 – Pin Change Mask Register 2
                Bit         7         6        5          4         3         2         1           0
             (0x6D)      PCINT23  PCINT22   PCINT21   PCINT20    PCINT19   PCINT18   PCINT17   PCINT16    PCMSK2
          Read/Write       R/W      R/W       R/W        R/W       R/W       R/W       R/W        R/W
          Initial Value     0         0        0          0         0         0         0           0
        • Bit 7..0 – PCINT23..16: Pin Change Enable Mask 23..16
        Each PCINT23..16-bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT23..16 is set
        and the PCIE2 bit in PCICR is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT23..16 is cleared,
        pin change interrupt on the corresponding I/O pin is disabled.
5.12.2.7 PCMSK1 – Pin Change Mask Register 1
                 Bit          7         6        5          4         3         2        1          0
               (0x6C)         –     PCINT14 PCINT13 PCINT12 PCINT11 PCINT10           PCINT9    PCINT8    PCMSK1
           Read/Write         R        R/W      R/W       R/W       R/W       R/W       R/W        R/W
           Initial Value      0         0        0          0         0         0        0          0
        • Bit 7 – Res: Reserved Bit
        This bit is an unused bit in the ATmega328P, and will always read as zero.
        • Bit 6..0 – PCINT14..8: Pin Change Enable Mask 14..8
        Each PCINT14..8-bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT14..8 is set and
        the PCIE1 bit in PCICR is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT14..8 is cleared, pin
        change interrupt on the corresponding I/O pin is disabled.
5.12.2.8 PCMSK0 – Pin Change Mask Register 0
                  Bit         7         6        5          4        3         2         1          0
               (0x6B)      PCINT7    PCINT6   PCINT5    PCINT4    PCINT3    PCINT2    PCINT1   PCINT0     PCMSK0
            Read/Write       R/W       R/W     R/W        R/W       R/W      R/W       R/W        R/W
           Initial Value      0         0        0          0        0         0         0          0
        • Bit 7..0 – PCINT7..0: Pin Change Enable Mask 7..0
        Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the
        PCIE0 bit in PCICR is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change
        interrupt on the corresponding I/O pin is disabled.
                                                                                             ATA6614Q [DATASHEET]                  81
                                                                                                            9240I–AUTO–03/16


5.13   I/O-Ports
5.13.1 Overview
       All AVR® ports have true read-modify-write functionality when used as general digital I/O ports. This means that the direction
       of one port pin can be changed without unintentionally changing the direction of any other pin with the SBI and CBI
       instructions. The same applies when changing drive value (if configured as output) or enabling/disabling of pull-up resistors
       (if configured as input). Each output buffer has symmetrical drive characteristics with both high sink and source capability.
       The pin driver is strong enough to drive LED displays directly. All port pins have individually selectable pull-up resistors with
       a supply-voltage invariant resistance. All I/O pins have protection diodes to both VCC and Ground as indicated in Figure 5-22.
       Refer to Section 5.28 “Electrical Characteristics” on page 278 for a complete list of parameters.
       Figure 5-22. I/O Pin Equivalent Schematic
                                                                                       Rpu
                                                Pxn
                                                                                                   Logic
                                                                                  See Figure
                                                                      Cpin    ”General Digital I/O”
                                                                                  for Details
       All registers and bit references in this section are written in general form. A lower case “x” represents the numbering letter for
       the port, and a lower case “n” represents the bit number. However, when using the register or bit defines in a program, the
       precise form must be used. For example, PORTB3 for bit no. 3 in Port B, here documented generally as PORTxn. The
       physical I/O Registers and bit locations are listed in Section 5.13.4 “Register Description” on page 96.
       Three I/O memory address locations are allocated for each port, one each for the data register – PORTx, data direction
       register – DDRx, and the port input pins – PINx. The port input pins I/O location is read only, while the data register and the
       data direction register are read/write. However, writing a logic one to a bit in the PINx register, will result in a toggle in the
       corresponding bit in the data register. In addition, the pull-up disable – PUD bit in MCUCR disables the pull-up function for all
       pins in all ports when set.
       Using the I/O port as General Digital I/O is described in Section 5.13.2 “Ports as General Digital I/O” on page 83. Most port
       pins are multiplexed with alternate functions for the peripheral features on the device. How each alternate function interferes
       with the port pin is described in Section 5.13.3 “Alternate Port Functions” on page 87. Refer to the individual module sections
       for a full description of the alternate functions. Note that enabling the alternate function of some of the port pins does not
       affect the use of the other pins in the port as general digital I/O.
82     ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.13.2 Ports as General Digital I/O
       The ports are bi-directional I/O ports with optional internal pull-ups. Figure 5-23 shows a functional description of one I/O-
       port pin, here generically called Pxn.
       Figure 5-23. General Digital I/O(1)
                                                                                                            PUD
                                                                                           Q          D
                                                                                               DDxn
                                                                                           Q
                                                                                               CLR
                                                                                                            WDx
                                                                                            RESET
                                                                                                            RDx
                                                                                                                  1
                                                                                                                                        DATA BUS
                     Pnx                                                                   Q          D
                                                                                                                  0
                                                                                            PORTxn
                                                                                           Q
                                                                                               CLR
                                                                                                                                WPx
                                                                                            RESET
                                                  SLEEP                                                               WRx
                                                                                                            RRx
                                                                   Synchronizer
                                                                                                            RPx
                                                             D       Q       D       Q
                                                                                 PINxn
                                                             L       Q               Q
                                                                                                            CLKI/O
                                        PUD:      PULLUP DISABLE                  WDx:   WRITE DDRx
                                        SLEEP:    SLEEP CONTROL                   RDx:   READ DDRx
                                        CLKI/O:   I/O CLOCK                       WRx:   WRITE PORTx
                                                                                  RRx:   READ PORTx REGISTER
                                                                                  RPx:   READ PORTx PIN
                                                                                  WPx:   WRITE PINx REGISTER
       Note:    1.   WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O, SLEEP, and PUD
                     are common to all ports.
5.13.2.1 Configuring the Pin
       Each port pin consists of three register bits: DDxn, PORTxn, and PINxn. As shown in Section 5.13.4 “Register Description”
       on page 96, the DDxn bits are accessed at the DDRx I/O address, the PORTxn bits at the PORTx I/O address, and the
       PINxn bits at the PINx I/O address.
       The DDxn bit in the DDRx Register selects the direction of this pin. If DDxn is written logic one, Pxn is configured as an
       output pin. If DDxn is written logic zero, Pxn is configured as an input pin.
       If PORTxn is written logic one when the pin is configured as an input pin, the pull-up resistor is activated. To switch the pull-
       up resistor off, PORTxn has to be written logic zero or the pin has to be configured as an output pin. The port pins are tri-
       stated when reset condition becomes active, even if no clocks are running.
       If PORTxn is written logic one when the pin is configured as an output pin, the port pin is driven high (one). If PORTxn is
       written logic zero when the pin is configured as an output pin, the port pin is driven low (zero).
                                                                                                          ATA6614Q [DATASHEET]                     83
                                                                                                                            9240I–AUTO–03/16


5.13.2.2 Toggling the Pin
        Writing a logic one to PINxn toggles the value of PORTxn, independent on the value of DDRxn. Note that the SBI instruction
        can be used to toggle one single bit in a port.
5.13.2.3 Switching Between Input and Output
        When switching between tri-state ({DDxn, PORTxn} = 0b00) and output high ({DDxn, PORTxn} = 0b11), an intermediate
        state with either pull-up enabled {DDxn, PORTxn} = 0b01) or output low ({DDxn, PORTxn} = 0b10) must occur. Normally, the
        pull-up enabled state is fully acceptable, as a high-impedance environment will not notice the difference between a strong
        high driver and a pull-up. If this is not the case, the PUD bit in the MCUCR Register can be set to disable all pull-ups in all
        ports.
        Switching between input with pull-up and output low generates the same problem. The user must use either the tri-state
        ({DDxn, PORTxn} = 0b00) or the output high state ({DDxn, PORTxn} = 0b11) as an intermediate step.
        Table 5-29 summarizes the control signals for the pin value.
        Table 5-29. Port Pin Configurations
                                              PUD
           DDxn          PORTxn           (in MCUCR)            I/O           Pull-up       Comment
              0              0                  X              Input            No          Tri-state (Hi-Z)
              0              1                   0             Input           Yes          Pxn will source current if ext. pulled low.
              0              1                   1             Input            No          Tri-state (Hi-Z)
              1              0                  X             Output            No          Output low (sink)
              1              1                  X             Output            No          Output high (source)
5.13.2.4 Reading the Pin Value
        Independent of the setting of data direction bit DDxn, the port pin can be read through the PINxn register bit. As shown in
        Figure 5-23 on page 83, the PINxn register bit and the preceding latch constitute a synchronizer. This is needed to avoid
        metastability if the physical pin changes value near the edge of the internal clock, but it also introduces a delay. Figure 5-24
        shows a timing diagram of the synchronization when reading an externally applied pin value. The maximum and minimum
        propagation delays are denoted tpd,max and tpd,min respectively.
        Figure 5-24. Synchronization when Reading an Externally Applied Pin Value
                                      SYSTEM CLK
                                   INSTRUCTIONS                XXX              XXX           in r17, PINx
                                      SYNC LATCH
                                               PINxn
                                                  r17                     0x00                                0xFF
                                                                     tpd, max
                                                                                   tpd, min
        Consider the clock period starting shortly after the first falling edge of the system clock. The latch is closed when the clock is
        low, and goes transparent when the clock is high, as indicated by the shaded region of the “SYNC LATCH” signal. The signal
        value is latched when the system clock goes low. It is clocked into the PINxn register at the succeeding positive clock edge.
        As indicated by the two arrows tpd,max and tpd,min, a single signal transition on the pin will be delayed between ½ and 1½
        system clock period depending upon the time of assertion.
        When reading back a software assigned pin value, a nop instruction must be inserted as indicated in Figure 5-25. The out
        instruction sets the “SYNC LATCH” signal at the positive edge of the clock. In this case, the delay tpd through the
        synchronizer is 1 system clock period.
84      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


Figure 5-25. Synchronization when Reading a Software Assigned Pin Value
                              SYSTEM CLK
                                         r16                           0xFF
                            INSTRUCTIONS           out PORTx, r16       nop         in r17, PINx
                               SYNC LATCH
                                       PINxn
                                         r17                           0x00                          0xFF
                                                                        tpd
The following code example shows how to set port B pins 0 and 1 high, 2 and 3 low, and define the port pins from 4 to 7 as
input with pull-ups assigned to port pins 6 and 7. The resulting pin values are read back again, but as previously discussed,
a nop instruction is included to be able to read back the value recently assigned to some of the pins.
 Assembly Code Example(1)
                     ...
                     ; Define pull-ups and set outputs high
                     ; Define directions for port pins
                     ldi       r16,(1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0)
                     ldi       r17,(1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0)
                     out       PORTB,r16
                     out       DDRB,r17
                     ; Insert nop for synchronization
                     nop
                     ; Read port pins
                     in                            r16,PINB
                     ...
 C Code Example
           unsigned char i;
                     ...
                     /* Define pull-ups and set outputs high */
                     /* Define directions for port pins */
                     PORTB = (1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0);
                     DDRB = (1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0);
                     /* Insert nop for synchronization*/
                     __no_operation();
                     /* Read port pins */
                     i = PINB;
                     ...
Note:     1.   For the assembly program, two temporary registers are used to minimize the time from pull-ups are set on pins
               0, 1, 6, and 7, until the direction bits are correctly set, defining bit 2 and 3 as low and redefining bits 0 and 1 as
               strong high drivers.
                                                                                                ATA6614Q [DATASHEET]               85
                                                                                                            9240I–AUTO–03/16


5.13.2.5 Digital Input Enable and Sleep Modes
        As shown in Figure 5-23 on page 83, the digital input signal can be clamped to ground at the input of the Schmitt Trigger.
        The signal denoted SLEEP in the figure, is set by the MCU sleep controller in power-down mode, power-save mode, and
        standby mode to avoid high power consumption if some input signals are left floating, or have an analog signal level close to
        VCC/2.
        SLEEP is overridden for port pins enabled as external interrupt pins. If the external interrupt request is not enabled, SLEEP
        is active also for these pins. SLEEP is also overridden by various other alternate functions as described in Section 5.13.3
        “Alternate Port Functions” on page 87.
        If a logic high level (“one”) is present on an asynchronous external interrupt pin configured as “Interrupt on Rising Edge,
        Falling Edge, or Any Logic Change on Pin” while the external interrupt is not enabled, the corresponding external interrupt
        flag will be set when resuming from the above mentioned sleep mode, as the clamping in these sleep mode produces the
        requested logic change.
5.13.2.6 Unconnected Pins
        If some pins are unused, it is recommended to ensure that these pins have a defined level. Even though most of the digital
        inputs are disabled in the deep sleep modes as described above, floating inputs should be avoided to reduce current
        consumption in all other modes where the digital inputs are enabled (reset, active mode and idle mode).
        The simplest method to ensure a defined level of an unused pin, is to enable the internal pull-up. In this case, the pull-up will
        be disabled during reset. If low power consumption during reset is important, it is recommended to use an external pull-up or
        pull-down. Connecting unused pins directly to VCC or GND is not recommended, since this may cause excessive currents if
        the pin is accidentally configured as an output.
86      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.13.3 Alternate Port Functions
       Most port pins have alternate functions in addition to being general digital I/Os. Figure 5-26 shows how the port pin control
       signals from the simplified Figure 5-23 on page 83 can be overridden by alternate functions. The overriding signals may not
       be present in all port pins, but the figure serves as a generic description applicable to all port pins in the AVR®
       microcontroller family.
       Figure 5-26. Alternate Port Functions(1)
                                                            PUOExn
                                             1              PUOVxn
                                                                                                                       PUD
                                             0
                                                            DDOExn
                                             1              DDOVxn
                                             0                                                        Q          D
                                                                                                          DDxn
                                                                                                      Q
                                                                                                          CLR
                                                                                                                       WDx
                                                                                                      RESET
                                                                                                                       RDx
                                                            PVOExn
                                             1              PVOVxn
                 Pxn                                                                                                         1
                                                                                                                                                       DATA BUS
                                             0                                                        Q          D
                                                                                                                             0
                                                                                                      PORTxn
                                                            DIEOExn                                   Q                                 PTOExn
                                                                                                          CLR
                                             1              DIEOVxn                                   RESET
                                                                                                                                 WRx             WPx
                                             0              SLEEP                                                      RRx
                                                                      Synchronizer
                                                                                                                       RPx
                                                               D SET Q          D       Q
                                                                                    PINxn
                                                               L CLR Q               CLR Q
                                                                                                                       CLKI/O
                                                                                                                       DIxn
                                                                                                                       AIOxn
                     PUOExn:    Pxn PULL-UP OVERRIDE ENABLE                                 PUD:      PULL-UP DISABLE
                     PUOVxn:    Pxn PULL-UP OVERRIDE VALUE                                  WDx:      WRITE DDRx
                     DDOExn:    Pxn DATA DIRECTION OVERRIDE ENABLE                          RDx:      READ DDRx
                     DDOVxn:    Pxn DATA DIRECTION OVERRIDE VALUE                           RRx:      READ PORTx REGISTER
                     PVOExn:    Pxn PORT VALUE OVERRIDE ENABLE                              WRx:      WRITE PORTx
                     PVOVxn:    Pxn PORT VALUE OVERRIDE VALUE                               RPx:      READ PORTx PIN
                     DIEOExn:   Pxn DIGITAL INPUT ENABLE OVERRIDE ENABLE                    WPx:      WRITE PINx
                     DIEOVxn:   Pxn DIGITAL INPUT ENABLE OVERRIDE VALUE                     CLK:I/O   I/O CLOCK
                     SLEEP:     SLEEP CONTROL                                               DIxn:     DIGITAL INPUT PIN n ON PORTx
                     PTOExn:    Pxn, PORT TOGGLE OVERRIDE ENABLE                            AIOxn:    ANALOG INPUT/OUTPUT PIN n ON PORTx
       Note:    1.     WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O, SLEEP, and PUD
                       are common to all ports. All other signals are unique for each pin.
                                                                                                                     ATA6614Q [DATASHEET]                         87
                                                                                                                                       9240I–AUTO–03/16


   Table 5-30 summarizes the function of the overriding signals. The pin and port indexes from Figure 5-26 on page 87 are not
   shown in the succeeding tables. The overriding signals are generated internally in the modules having the alternate function.
   Table 5-30. Generic Description of Overriding Signals for Alternate Functions
       Signal Name        Full Name                   Description
                                                      If this signal is set, the pull-up enable is controlled by the PUOV signal. If
           PUOE           Pull-up override enable     this signal is cleared, the pull-up is enabled when
                                                      {DDxn, PORTxn, PUD} = 0b010.
                                                      If PUOE is set, the pull-up is enabled/disabled when PUOV is set/cleared,
           PUOV           Pull-up override value
                                                      regardless of the setting of the DDxn, PORTxn, and PUD register bits.
                                                      If this signal is set, the output driver enable is controlled by the DDOV
                          Data direction override
           DDOE                                       signal. If this signal is cleared, the output driver is enabled by the DDxn
                          enable
                                                      register bit.
                          Data direction override     If DDOE is set, the output driver is enabled/disabled when DDOV is
           DDOV
                          value                       set/cleared, regardless of the setting of the DDxn register bit.
                                                      If this signal is set and the output driver is enabled, the port value is
                          Port value override
           PVOE                                       controlled by the PVOV signal. If PVOE is cleared, and the output driver is
                          enable
                                                      enabled, the port value is controlled by the PORTxn register bit.
                          Port value override         If PVOE is set, the port value is set to PVOV, regardless of the setting of
           PVOV
                          value                       the PORTxn Register bit.
                          Port toggle override
           PTOE                                       If PTOE is set, the PORTxn register bit is inverted.
                          enable
                                                      If this bit is set, the digital input enable is controlled by the DIEOV signal. If
                          Digital input enable
          DIEOE                                       this signal is cleared, the digital input enable is determined by MCU state
                          override enable
                                                      (normal mode, sleep mode).
                          Digital input enable        If DIEOE is set, the digital input is enabled/disabled when DIEOV is
          DIEOV
                          override value              set/cleared, regardless of the MCU state (normal mode, sleep mode).
                                                      This is the digital Input to alternate functions. In the figure, the signal is
                                                      connected to the output of the Schmitt Trigger but before the synchronizer.
             DI           Digital input
                                                      Unless the digital input is used as a clock source, the module with the
                                                      alternate function will use its own synchronizer.
                                                      This is the analog input/output to/from alternate functions. The signal is
            AIO           Analog input/output
                                                      connected directly to the pad, and can be used bi-directionally.
   The following subsections shortly describe the alternate functions for each port, and relate the overriding signals to the
   alternate function. Refer to the alternate function description for further details.
88 ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


5.13.3.1 Alternate Functions of Port B
        The Port B pins with alternate functions are shown in Table 5-31
        Table 5-31. Port B Pins Alternate Functions
              Port Pin         Alternate Functions
                               XTAL2 (chip clock oscillator pin 2)
                PB7            TOSC2 (timer oscillator pin 2)
                               PCINT7 (pin change interrupt 7)
                               XTAL1 (chip clock oscillator pin 1 or external clock input)
                PB6            TOSC1 (timer oscillator pin 1)
                               PCINT6 (pin change interrupt 6)
                               SCK (SPI bus master clock Input)
                PB5
                               PCINT5 (pin change interrupt 5)
                               MISO (SPI bus master input/slave output)
                PB4
                               PCINT4 (pin change interrupt 4)
                               MOSI (SPI bus master output/slave input)
                PB3            OC2A (Timer/Counter2 output compare match A output)
                               PCINT3 (pin change interrupt 3)
                               SS (SPI bus master slave select)
                PB2            OC1B (Timer/Counter1 output compare match B output)
                               PCINT2 (pin change interrupt 2)
                               OC1A (Timer/Counter1 output compare match A output)
                PB1
                               PCINT1 (pin change interrupt 1)
                               ICP1 (Timer/Counter1 input capture input)
                PB0            CLKO (divided system clock output)
                               PCINT0 (pin change interrupt 0)
        The alternate pin configuration is as follows:
        • XTAL2/TOSC2/PCINT7 – Port B, Bit 7
        XTAL2: Chip clock oscillator pin 2. Used as clock pin for crystal oscillator or low-frequency crystal oscillator. When used as a
        clock pin, the pin can not be used as an I/O pin.
        TOSC2: Timer oscillator pin 2. Used only if internal calibrated RC oscillator is selected as chip clock source, and the
        asynchronous timer is enabled by the correct setting in ASSR. When the AS2 bit in ASSR is set (one) and the EXCLK bit is
        cleared (zero) to enable asynchronous clocking of Timer/Counter2 using the crystal oscillator, pin PB7 is disconnected from
        the port, and becomes the inverting output of the oscillator amplifier. In this mode, a crystal oscillator is connected to this pin,
        and the pin cannot be used as an I/O pin.
        PCINT7: Pin change interrupt source 7. The PB7 pin can serve as an external interrupt source.
        If PB7 is used as a clock pin, DDB7, PORTB7 and PINB7 will all read 0.
        • XTAL1/TOSC1/PCINT6 – Port B, Bit 6
        XTAL1: Chip clock oscillator pin 1. Used for all chip clock sources except internal calibrated RC oscillator. When used as a
        clock pin, the pin can not be used as an I/O pin.
        TOSC1: Timer oscillator pin 1. Used only if internal calibrated RC oscillator is selected as chip clock source, and the
        asynchronous timer is enabled by the correct setting in ASSR. When the AS2 bit in ASSR is set (one) to enable
        asynchronous clocking of Timer/Counter2, pin PB6 is disconnected from the port, and becomes the input of the inverting
        oscillator amplifier. In this mode, a crystal oscillator is connected to this pin, and the pin can not be used as an I/O pin.
        PCINT6: Pin change interrupt source 6. The PB6 pin can serve as an external interrupt source.
        If PB6 is used as a clock pin, DDB6, PORTB6 and PINB6 will all read 0.
                                                                                                   ATA6614Q [DATASHEET]                  89
                                                                                                                 9240I–AUTO–03/16


   • SCK/PCINT5 – Port B, Bit 5
   SCK: Master clock output, slave clock input pin for SPI channel. When the SPI is enabled as a slave, this pin is configured as
   an input regardless of the setting of DDB5. When the SPI is enabled as a master, the data direction of this pin is controlled
   by DDB5. When the pin is forced by the SPI to be an input, the pull-up can still be controlled by the PORTB5 bit.
   PCINT5: Pin change interrupt source 5. The PB5 pin can serve as an external interrupt source.
   • MISO/PCINT4 – Port B, Bit 4
   MISO: Master data input, slave data output pin for SPI channel. When the SPI is enabled as a master, this pin is configured
   as an input regardless of the setting of DDB4. When the SPI is enabled as a slave, the data direction of this pin is controlled
   by DDB4. When the pin is forced by the SPI to be an input, the pull-up can still be controlled by the PORTB4 bit.
   PCINT4: Pin change interrupt source 4. The PB4 pin can serve as an external interrupt source.
   • MOSI/OC2/PCINT3 – Port B, Bit 3
   MOSI: SPI master data output, slave data input for SPI channel. When the SPI is enabled as a Slave, this pin is configured
   as an input regardless of the setting of DDB3. When the SPI is enabled as a master, the data direction of this pin is
   controlled by DDB3. When the pin is forced by the SPI to be an input, the pull-up can still be controlled by the PORTB3 bit.
   OC2, output compare match output: The PB3 pin can serve as an external output for the Timer/Counter2 compare match.
   The PB3 pin has to be configured as an output (DDB3 set (one)) to serve this function. The OC2 pin is also the output pin for
   the PWM mode timer function.
   PCINT3: Pin change interrupt source 3. The PB3 pin can serve as an external interrupt source.
   • SS/OC1B/PCINT2 – Port B, Bit 2
   SS: Slave select input. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of
   DDB2. As a slave, the SPI is activated when this pin is driven low. When the SPI is enabled as a master, the data direction
   of this pin is controlled by DDB2. When the pin is forced by the SPI to be an input, the pull-up can still be controlled by the
   PORTB2 bit.
   OC1B, Output compare match output: The PB2 pin can serve as an external output for the Timer/Counter1 compare match
   B. The PB2 pin has to be configured as an output (DDB2 set (one)) to serve this function. The OC1B pin is also the output
   pin for the PWM mode timer function.
   PCINT2: Pin change interrupt source 2. The PB2 pin can serve as an external interrupt source.
   • OC1A/PCINT1 – Port B, Bit 1
   OC1A, Output compare match output: The PB1 pin can serve as an external output for the Timer/Counter1 compare match
   A. The PB1 pin has to be configured as an output (DDB1 set (one)) to serve this function. The OC1A pin is also the output
   pin for the PWM mode timer function.
   PCINT1: Pin change interrupt source 1. The PB1 pin can serve as an external interrupt source.
   • ICP1/CLKO/PCINT0 – Port B, Bit 0
   ICP1, input capture pin: The PB0 pin can act as an input capture pin for Timer/Counter1.
   CLKO, divided system clock: The divided system clock can be output on the PB0 pin. The divided system clock will be output
   if the CKOUT Fuse is programmed, regardless of the PORTB0 and DDB0 settings. It will also be output during reset.
   PCINT0: Pin change interrupt source 0. The PB0 pin can serve as an external interrupt source.
   Table 5-32 and Table 5-33 on page 91 relate the alternate functions of Port B to the overriding signals shown in Figure 5-26
   on page 87. SPI MSTR INPUT and SPI SLAVE OUTPUT constitute the MISO signal, while MOSI is divided into SPI MSTR
   OUTPUT and SPI SLAVE INPUT.
90 ATA6614Q [DATASHEET]
   9240I–AUTO–03/16


Table 5-32. Overriding Signals for Alternate Functions in PB7..PB4
   Signal            PB7/XTAL2/                  PB6/XTAL1/                PB5/SCK/                  PB4/MISO/
   Name           TOSC2/PCINT7(1)             TOSC1/PCINT6(1)               PCINT5                    PCINT4
   PUOE         INTRC  EXTCK+ AS2              INTRC + AS2               SPE  MSTR                SPE  MSTR
   PUOV                    0                            0               PORTB5 PUD              PORTB4  PUD
   DDOE         INTRC  EXTCK+ AS2              INTRC + AS2               SPE  MSTR                SPE  MSTR
   DDOV                    0                            0                       0                        0
   PVOE                    0                            0                 SPE  MSTR                SPE  MSTR
   PVOV                    0                            0                SCK OUTPUT            SPI SLAVE OUTPUT
               INTRC  EXTCK + AS2         INTRC + AS2 + PCINT6
   DIEOE                                                                PCINT5  PCIE0            PCINT4  PCIE0
                  + PCINT7  PCIE0                   PCIE0
   DIEOV      (INTRC + EXTCK)  AS2             INTRC  AS2                     1                        1
                                                                         PCINT5 INPUT              PCINT4 INPUT
     DI             PCINT7 INPUT               PCINT6 INPUT
                                                                          SCK INPUT              SPI MSTR INPUT
    AIO            Oscillator output         Oscillator/clock input             –                        –
Notes:  1.  INTRC means that one of the internal RC oscillators are selected (by the CKSEL fuses), EXTCK means that
            external clock is selected (by the CKSEL fuses)
Table 5-33. Overriding Signals for Alternate Functions in PB3..PB0
   Signal             PB3/MOSI/                    PB2/SS/                 PB1/OC1A/                 PB0/ICP1/
   Name              OC2/PCINT3                OC1B/PCINT2                  PCINT1                    PCINT0
   PUOE              SPE  MSTR                 SPE  MSTR                      0                        0
   PUOV            PORTB3  PUD                PORTB2  PUD                     0                        0
   DDOE              SPE  MSTR                 SPE  MSTR                      0                        0
   DDOV                    0                           0                        0                        0
                    SPE  MSTR +
   PVOE                                        OC1B ENABLE              OC1A ENABLE                      0
                   OC2A ENABLE
                SPI MSTR OUTPUT +
   PVOV                                              OC1B                    OC1A                        0
                        OC2A
   DIEOE           PCINT3  PCIE0             PCINT2  PCIE0            PCINT1  PCIE0            PCINT0  PCIE0
   DIEOV                   1                           1                        1                        1
                    PCINT3 INPUT               PCINT2 INPUT                                        PCINT0 INPUT
     DI                                                                  PCINT1 INPUT
                  SPI SLAVE INPUT                   SPI SS                                          ICP1 INPUT
    AIO                    –                           –                        –                        –
                                                                                   ATA6614Q [DATASHEET]           91
                                                                                              9240I–AUTO–03/16


5.13.3.2 Alternate Functions of Port C
        The Port C pins with alternate functions are shown in Table 5-34.
        Table 5-34. Port C Pins Alternate Functions
                 Port Pin          Alternate Function
                                   RESET (reset pin)
                    PC6
                                   PCINT14 (pin change interrupt 14)
                                   ADC5 (ADC input channel 5)
                    PC5            SCL (2-wire serial bus clock line)
                                   PCINT13 (pin change interrupt 13)
                                   ADC4 (ADC input channel 4)
                    PC4            SDA (2-wire serial bus data input/output line)
                                   PCINT12 (pin change interrupt 12)
                                   ADC3 (ADC input channel 3)
                    PC3
                                   PCINT11 (pin change interrupt 11)
                                   ADC2 (ADC input channel 2)
                    PC2
                                   PCINT10 (pin change interrupt 10)
                                   ADC1 (ADC input channel 1)
                    PC1
                                   PCINT9 (pin change interrupt 9)
                                   ADC0 (ADC input channel 0)
                    PC0
                                   PCINT8 (pin change interrupt 8)
        The alternate pin configuration is as follows:
        • RESET/PCINT14 – Port C, Bit 6
        RESET, Reset pin: When the RSTDISBL Fuse is programmed, this pin functions as an input pin, and the part will have to
        rely on power-on reset and brown-out reset as its reset sources. When the RSTDISBL Fuse is unprogrammed, the reset
        circuitry is connected to the pin, and the pin can not be used as an input pin.
        If PC6 is used as a reset pin, DDC6, PORTC6 and PINC6 will all read 0.
        PCINT14: Pin Change Interrupt source 14. The PC6 pin can serve as an external interrupt source.
        • SCL/ADC5/PCINT13 – Port C, Bit 5
        SCL, 2-wire serial interface clock: When the TWEN bit in TWCR is set (one) to enable the 2-wire serial interface, pin PC5 is
        disconnected from the port and becomes the serial clock I/O pin for the 2-wire serial interface. In this mode, there is a spike
        filter on the pin to suppress spikes shorter than 50 ns on the input signal, and the pin is driven by an open drain driver with
        slew-rate limitation.
        PC5 can also be used as ADC input channel 5. Note that ADC input channel 5 uses digital power.
        PCINT13: Pin change interrupt source 13. The PC5 pin can serve as an external interrupt source.
        • SDA/ADC4/PCINT12 – Port C, Bit 4
        SDA, 2-wire serial interface data: When the TWEN bit in TWCR is set (one) to enable the 2-wire serial interface, pin PC4 is
        disconnected from the port and becomes the serial data I/O pin for the 2-wire serial interface. In this mode, there is a spike
        filter on the pin to suppress spikes shorter than 50ns on the input signal, and the pin is driven by an open drain driver with
        slew-rate limitation.
        PC4 can also be used as ADC input channel 4. Note that ADC input channel 4 uses digital power.
        PCINT12: Pin change interrupt source 12. The PC4 pin can serve as an external interrupt source.
        • ADC3/PCINT11 – Port C, Bit 3
        PC3 can also be used as ADC input channel 3. Note that ADC input channel 3 uses analog power.
        PCINT11: Pin change interrupt source 11. The PC3 pin can serve as an external interrupt source.
92      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


• ADC2/PCINT10 – Port C, Bit 2
PC2 can also be used as ADC input channel 2. Note that ADC input channel 2 uses analog power.
PCINT10: Pin change interrupt source 10. The PC2 pin can serve as an external interrupt source.
• ADC1/PCINT9 – Port C, Bit 1
PC1 can also be used as ADC input Channel 1. Note that ADC input channel 1 uses analog power.
PCINT9: Pin change interrupt source 9. The PC1 pin can serve as an external interrupt source.
• ADC0/PCINT8 – Port C, Bit 0
PC0 can also be used as ADC input channel 0. Note that ADC input channel 0 uses analog power.
PCINT8: Pin change interrupt source 8. The PC0 pin can serve as an external interrupt source.
Table 5-35 and Table 5-36 relate the alternate functions of Port C to the overriding signals shown in Figure 5-26 on page 87.
Table 5-35. Overriding Signals for Alternate Functions in PC6..PC4(1)
   Signal
   Name           PC6/RESET/PCINT14                    PC5/SCL/ADC5/PCINT13                    PC4/SDA/ADC4/PCINT12
   PUOE                 RSTDISBL                                  TWEN                                  TWEN
   PUOV                      1                               PORTC5  PUD                          PORTC4  PUD
   DDOE                 RSTDISBL                                  TWEN                                  TWEN
   DDOV                      0                                   SCL_OUT                              SDA_OUT
   PVOE                      0                                    TWEN                                  TWEN
   PVOV                      0                                       0                                     0
  DIEOE      RSTDISBL + PCINT14  PCIE1               PCINT13  PCIE1 + ADC5D                 PCINT12  PCIE1 + ADC4D
  DIEOV                 RSTDISBL                            PCINT13  PCIE1                       PCINT12  PCIE1
      DI             PCINT14 INPUT                           PCINT13 INPUT                         PCINT12 INPUT
    AIO               RESET INPUT                     ADC5 INPUT / SCL INPUT                  ADC4 INPUT / SDA INPUT
Note:    1.  When enabled, the 2-wire serial Interface enables slew-rate controls on the output pins PC4 and PC5. This is
             not shown in the figure. In addition, spike filters are connected between the AIO outputs shown in the port fig-
             ure and the digital logic of the TWI module.
Table 5-36. Overriding Signals for Alternate Functions in PC3..PC0
   Signal           PC3/ADC3/                      PC2/ADC2/                    PC1/ADC1/                  PC0/ADC0/
   Name               PCINT11                       PCINT10                      PCINT9                      PCINT8
   PUOE                   0                             0                            0                          0
   PUOV                   0                             0                            0                          0
   DDOE                   0                             0                            0                          0
   DDOV                   0                             0                            0                          0
   PVOE                   0                             0                            0                          0
   PVOV                   0                             0                            0                          0
                PCINT11  PCIE1 +              PCINT10  PCIE1 +           PCINT9  PCIE1 +            PCINT8  PCIE1 +
   DIEOE
                       ADC3D                         ADC2D                       ADC1D                       ADC0D
   DIEOV         PCINT11  PCIE1                PCINT10  PCIE1              PCINT9  PCIE1             PCINT8  PCIE1
      DI          PCINT11 INPUT                  PCINT10 INPUT                PCINT9 INPUT               PCINT8 INPUT
    AIO            ADC3 INPUT                     ADC2 INPUT                   ADC1 INPUT                 ADC0 INPUT
                                                                                        ATA6614Q [DATASHEET]               93
                                                                                                     9240I–AUTO–03/16


5.13.3.3 Alternate Functions of Port D
        The Port D pins with alternate functions are shown in Table 5-37.
        Table 5-37. Port D Pins Alternate Functions
                  Port Pin           Alternate Function
                                     AIN1 (analog comparator negative input)
                    PD7
                                     PCINT23 (pin change interrupt 23)
                                     AIN0 (analog comparator positive input)
                    PD6              OC0A (Timer/Counter0 output compare match A output)
                                     PCINT22 (pin change interrupt 22)
                                     T1 (Timer/Counter 1 external counter input)
                    PD5              OC0B (Timer/Counter0 output compare match B output)
                                     PCINT21 (pin change interrupt 21)
                                     XCK (USART external clock input/output)
                    PD4              T0 (Timer/Counter 0 external counter input)
                                     PCINT20 (pin change interrupt 20)
                                     INT1 (external interrupt 1 input)
                    PD3              OC2B (Timer/Counter2 output compare match B output)
                                     PCINT19 (pin change interrupt 19)
                                     INT0 (external interrupt 0 input)
                    PD2
                                     PCINT18 (pin change interrupt 18)
                                     TXD (USART output pin)
                    PD1
                                     PCINT17 (pin change interrupt 17)
                                     RXD (USART input pin)
                    PD0
                                     PCINT16 (pin change interrupt 16)
        The alternate pin configuration is as follows:
        • AIN1/OC2B/PCINT23 – Port D, Bit 7
        AIN1, analog comparator negative input. Configure the port pin as input with the internal pull-up switched off to avoid the
        digital port function from interfering with the function of the analog comparator.
        PCINT23: Pin change interrupt source 23. The PD7 pin can serve as an external interrupt source.
        • AIN0/OC0A/PCINT22 – Port D, Bit 6
        AIN0, analog comparator positive input. Configure the port pin as input with the internal pull-up switched off to avoid the
        digital port function from interfering with the function of the analog comparator.
        OC0A, output compare match output: The PD6 pin can serve as an external output for the Timer/Counter0 compare match
        A. The PD6 pin has to be configured as an output (DDD6 set (one)) to serve this function. The OC0A pin is also the output
        pin for the PWM mode timer function.
        PCINT22: Pin change interrupt source 22. The PD6 pin can serve as an external interrupt source.
        • T1/OC0B/PCINT21 – Port D, Bit 5
        T1, Timer/Counter1 counter source.
        OC0B, output compare match output: The PD5 pin can serve as an external output for the Timer/Counter0 compare match
        B. The PD5 pin has to be configured as an output (DDD5 set (one)) to serve this function. The OC0B pin is also the output
        pin for the PWM mode timer function.
        PCINT21: Pin change interrupt source 21. The PD5 pin can serve as an external interrupt source.
94      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


• XCK/T0/PCINT20 – Port D, Bit 4
XCK, USART external clock.
T0, Timer/Counter0 counter source.
PCINT20: Pin change interrupt source 20. The PD4 pin can serve as an external interrupt source.
• INT1/OC2B/PCINT19 – Port D, Bit 3
INT1, external interrupt source 1: The PD3 pin can serve as an external interrupt source.
OC2B, output compare match output: The PD3 pin can serve as an external output for the Timer/Counter0 compare match
B. The PD3 pin has to be configured as an output (DDD3 set (one)) to serve this function. The OC2B pin is also the output
pin for the PWM mode timer function.
PCINT19: Pin change interrupt source 19. The PD3 pin can serve as an external interrupt source.
• INT0/PCINT18 – Port D, Bit 2
INT0, external interrupt source 0: The PD2 pin can serve as an external interrupt source.
PCINT18: Pin change interrupt source 18. The PD2 pin can serve as an external interrupt source.
• TXD/PCINT17 – Port D, Bit 1
TXD, transmit data (data output pin for the USART). When the USART transmitter is enabled, this pin is configured as an
output regardless of the value of DDD1.
PCINT17: Pin change interrupt source 17. The PD1 pin can serve as an external interrupt source.
• RXD/PCINT16 – Port D, Bit 0
RXD, receive data (data input pin for the USART). When the USART Receiver is enabled this pin is configured as an input
regardless of the value of DDD0. When the USART forces this pin to be an input, the pull-up can still be controlled by the
PORTD0 bit.
PCINT16: Pin change interrupt source 16. The PD0 pin can serve as an external interrupt source.
Table 5-38 and Table 5-39 relate the alternate functions of Port D to the overriding signals shown in Figure 5-26 on page 87.
Table 5-38. Overriding Signals for Alternate Functions PD7..PD4
   Signal              PD7/AIN1                   PD6/AIN0/                  PD5/T1/OC0B/                   PD4/XCK/
    Name               /PCINT23                 OC0A/PCINT22                    PCINT21                    T0/PCINT20
   PUOE                    0                           0                             0                          0
     PUO                   0                           0                             0                          0
   DDOE                    0                           0                             0                          0
   DDOV                    0                           0                             0                          0
    PVOE                   0                    OC0A ENABLE                 OC0B ENABLE                      UMSEL
    PVOV                   0                         OC0A                         OC0B                    XCK OUTPUT
   DIEOE          PCINT23  PCIE2             PCINT22  PCIE2              PCINT21  PCIE2              PCINT20  PCIE2
   DIEOV                   1                           1                             1                          1
                                                                                                         PCINT20 INPUT
                                                                            PCINT21 INPUT
      DI           PCINT23 INPUT               PCINT22 INPUT                                               XCK INPUT
                                                                                T1 INPUT
                                                                                                            T0 INPUT
     AIO              AIN1 INPUT                 AIN0 INPUT                          –                          –
                                                                                        ATA6614Q [DATASHEET]               95
                                                                                                     9240I–AUTO–03/16


        Table 5-39. Overriding Signals for Alternate Functions in PD3..PD0
            Signal          PD3/OC2B/INT1/                   PD2/INT0/                   PD1/TXD/                 PD0/RXD/
            Name                PCINT19                       PCINT18                     PCINT17                 PCINT16
            PUOE                    0                             0                          TXEN                   RXEN
             PUO                    0                             0                             0              PORTD0  PUD
            DDOE                    0                             0                          TXEN                   RXEN
            DDOV                    0                             0                             1                      0
            PVOE             OC2B ENABLE                          0                          TXEN                      0
            PVOV                  OC2B                            0                           TXD                      0
                            INT1 ENABLE +                 INT0 ENABLE +
            DIEOE                                                                     PCINT17  PCIE2         PCINT16  PCIE2
                           PCINT19  PCIE2               PCINT18  PCIE1
            DIEOV                   1                             1                             1                      1
                            PCINT19 INPUT                 PCINT18 INPUT                                        PCINT16 INPUT
               DI                                                                      PCINT17 INPUT
                              INT1 INPUT                    INT0 INPUT                                               RXD
              AIO                   –                             –                             –                      –
5.13.4 Register Description
5.13.4.1 MCUCR – MCU Control Register
               Bit         7          6            5           4          3         2          1       0
         0x35 (0x55)       –        BODS       BODSE         PUD          –         –       IVSEL    IVCE   MCUCR
         Read/Write        R          R            R         R/W          R         R        R/W      R/W
         Initial Value     0          0            0           0          0         0          0       0
        • Bit 4 – PUD: Pull-up Disable
        When this bit is written to one, the pull-ups in the I/O ports are disabled even if the DDxn and PORTxn registers are
        configured to enable the pull-ups ({DDxn, PORTxn} = 0b01). See Section 5.13.2.1 “Configuring the Pin” on page 83 for more
        details about this feature.
5.13.4.2 PORTB – The Port B Data Register
                Bit         7         6           5          4          3         2           1        0
         0x05 (0x25)    PORTB7     PORTB6     PORTB5     PORTB4     PORTB3     PORTB2    PORTB1    PORTB0   PORTB
          Read/Write      R/W        R/W        R/W         R/W       R/W        R/W        R/W      R/W
          Initial Value     0         0           0          0          0         0           0        0
5.13.4.3 DDRB – The Port B Data Direction Register
                Bit         7         6           5          4          3         2           1        0
         0x04 (0x24)     DDB7       DDB6       DDB5        DDB4      DDB3       DDB2       DDB1     DDB0     DDRB
          Read/Write      R/W        R/W        R/W         R/W       R/W        R/W        R/W      R/W
          Initial Value     0         0           0          0          0         0           0        0
96      ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.13.4.4 PINB – The Port B Input Pins Address
                Bit        7      6      5      4      3      2      1        0
         0x03 (0x23)     PINB7  PINB6  PINB5  PINB4  PINB3  PINB2  PINB1    PINB0   PINB
          Read/Write       R      R      R      R      R      R      R        R
          Initial Value   N/A    N/A    N/A    N/A    N/A    N/A    N/A      N/A
5.13.4.5 PORTC – The Port C Data Register
                Bit        7      6      5      4      3      2      1        0
         0x08 (0x28)       –   PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1   PORTC0  PORTC
          Read/Write       R     R/W    R/W    R/W    R/W    R/W    R/W      R/W
          Initial Value    0      0      0      0      0      0      0        0
5.13.4.6 DDRC – The Port C Data Direction Register
                Bit        7      6      5      4      3      2      1        0
         0x07 (0x27)       –    DDC6   DDC5   DDC4   DDC3   DDC2   DDC1     DDC0   DDRC
          Read/Write       R     R/W    R/W    R/W    R/W    R/W    R/W      R/W
          Initial Value    0      0      0      0      0      0      0        0
5.13.4.7 PINC – The Port C Input Pins Address
                Bit        7      6      5      4      3      2      1        0
         0x06 (0x26)       –    PINC6  PINC5  PINC4  PINC3  PINC2  PINC1    PINC0   PINC
          Read/Write       R      R      R      R      R      R      R        R
          Initial Value    0     N/A    N/A    N/A    N/A    N/A    N/A      N/A
5.13.4.8 PORTD – The Port D Data Register
                Bit        7      6      5      4      3      2      1        0
         0x0B (0x2B)    PORTD7 PORTD6 PORTD5 PORTD4 PORTD3 PORTD2 PORTD1   PORTD0  PORTD
          Read/Write      R/W    R/W    R/W    R/W    R/W    R/W    R/W      R/W
          Initial Value    0      0      0      0      0      0      0        0
5.13.4.9 DDRD – The Port D Data Direction Register
                Bit        7      6      5      4      3      2      1        0
         0x0A (0x2A)     DDD7   DDD6   DDD5   DDD4   DDD3   DDD2   DDD1     DDD0   DDRD
          Read/Write      R/W    R/W    R/W    R/W    R/W    R/W    R/W      R/W
          Initial Value    0      0      0      0      0      0      0        0
5.13.4.10 PIND – The Port D Input Pins Address
                Bit        7      6      5      4      3      2      1        0
         0x09 (0x29)     PIND7  PIND6  PIND5  PIND4  PIND3  PIND2  PIND1    PIND0   PIND
          Read/Write       R      R      R      R      R      R      R        R
          Initial Value   N/A    N/A    N/A    N/A    N/A    N/A    N/A      N/A
                                                                         ATA6614Q [DATASHEET]       97
                                                                                   9240I–AUTO–03/16


5.14   8-bit Timer/Counter0 with PWM
5.14.1 Features
        ●    Two independent output compare units
        ●    Double buffered output compare registers
        ●    Clear timer on compare match (auto reload)
        ●    Glitch free, phase correct pulse width modulator (PWM)
        ●    Variable PWM period
        ●    Frequency generator
        ●    Three independent interrupt sources (TOV0, OCF0A, and OCF0B)
5.14.2 Overview
       Timer/Counter0 is a general purpose 8-bit Timer/Counter module, with two independent output compare Units, and with
       PWM support. It allows accurate program execution timing (event management) and wave generation.
       A simplified block diagram of the 8-bit Timer/Counter is shown in Figure 5-27. The device-specific I/O register and bit
       locations are listed in Section 5.14.9 “Register Description” on page 107.
       The PRTIM0 bit in Section 5.9.10 “Minimizing Power Consumption” on page 60 must be written to zero to enable
       Timer/Counter0 module.
       Figure 5-27. 8-bit Timer/Counter Block Diagram
                                                   Count
                                                                                                   TOVn (Int. Req.)
                                                   Clear
                                                              Control Logic     clkTn
                                                  Direction                                      Clock Select
                                                                                                   Edge
                                                                                                                       Tn
                                                                                                  Detector
                                                                TOP      BOTTOM
                                                                                               (from Prescaler)
                                  Timer/Counter
                                     TCNTn
                                                                  =              =      0
                                                                                               OCnA (Int. Req.)
                                                                                                 Waveform
                                       =                                                         Generation
                                                                                                                      OCnA
                                     OCRnA
                                                                        Fixed
                                                                        TOP
                 DATA BUS
                                                                        Value                  OCnB (Int. Req.)
                                                                                                 Waveform
                                       =                                                         Generation
                                                                                                                      OCnB
                                     OCRnB
                                    TCCRnA                        TCCRnB
98     ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.14.2.1 Definitions
        Many register and bit references in this section are written in general form. A lower case “n” replaces the Timer/Counter
        number, in this case 0. A lower case “x” replaces the output compare unit, in this case compare unit A or compare unit B.
        However, when using the register or bit defines in a program, the precise form must be used, i.e., TCNT0 for accessing
        Timer/Counter0 counter value and so on.
        The definitions in Table 5-40 are also used extensively throughout the document.
        Table 5-40. Definitions
               Case         Definition
             BOTTOM         The counter reaches the BOTTOM when it becomes 0x00.
               MAX          The counter reaches its MAXimum when it becomes 0xFF (decimal 255).
                            The counter reaches the TOP when it becomes equal to the highest value in the count sequence. The
               TOP          TOP value can be assigned to be the fixed value 0xFF (MAX) or the value stored in the OCR0A register.
                            The assignment is dependent on the mode of operation.
5.14.2.2 Registers
        The Timer/Counter (TCNT0) and output compare registers (OCR0A and OCR0B) are 8-bit registers. Interrupt request
        (abbreviated to int.req. in the figure) signals are all visible in the timer interrupt flag register (TIFR0). All interrupts are
        individually masked with the timer interrupt mask register (TIMSK0). TIFR0 and TIMSK0 are not shown in the figure.
        The Timer/Counter can be clocked internally, via the prescaler, or by an external clock source on the T0 pin. The clock select
        logic block controls which clock source and edge the Timer/Counter uses to increment (or decrement) its value. The
        Timer/Counter is inactive when no clock source is selected. The output from the clock select logic is referred to as the timer
        clock (clkT0).
        The double buffered output compare registers (OCR0A and OCR0B) are compared with the Timer/Counter value at all
        times. The result of the compare can be used by the waveform generator to generate a PWM or variable frequency output on
        the output compare pins (OC0A and OC0B). See Section 5.15.7.3 “Using the Output Compare Unit” on page 122 for details.
        The compare match event will also set the compare flag (OCF0A or OCF0B) which can be used to generate an output
        compare interrupt request.
5.14.3 Timer/Counter Clock Sources
        The Timer/Counter can be clocked by an internal or an external clock source. The clock source is selected by the clock
        select logic which is controlled by the Clock Select (CS02:0) bits located in the Timer/Counter control register (TCCR0B). For
        details on clock sources and prescaler, see Section 5.16 “Timer/Counter0 and Timer/Counter1 Prescalers” on page 137.
5.14.4 Counter Unit
        The main part of the 8-bit Timer/Counter is the programmable bi-directional counter unit. Figure 5-28 shows a block diagram
        of the counter and its surroundings.
        Figure 5-28. Counter Unit Block Diagram
                                                                                      TOVn
                                DATA BUS                                              (Int. Req.)
                                                                                                          Clock Select
                                                           count                                            Edge
                                                                                                                                Tn
                                                           clear                          clkTn            Detector
                                   TCNTn                               Control Logic
                                                           direction
                                                                                                       (from Prescaler)
                                                                  bottom          top
                                                                                                      ATA6614Q [DATASHEET]               99
                                                                                                                       9240I–AUTO–03/16


       Signal description (internal signals):
              count                        Increment or decrement TCNT0 by 1.
              direction                    Select between increment and decrement.
              clear                        Clear TCNT0 (set all bits to zero).
              clkTn                        Timer/Counter clock, referred to as clkT0 in the following.
              top                          Signalize that TCNT0 has reached maximum value.
              bottom                       Signalize that TCNT0 has reached minimum value (zero).
       Depending of the mode of operation used, the counter is cleared, incremented, or decremented at each timer clock (clkT0).
       clkT0 can be generated from an external or internal clock source, selected by the clock select bits (CS02:0). When no clock
       source is selected (CS02:0 = 0) the timer is stopped. However, the TCNT0 value can be accessed by the CPU, regardless of
       whether clkT0 is present or not. A CPU write overrides (has priority over) all counter clear or count operations.
       The counting sequence is determined by the setting of the WGM01 and WGM00 bits located in the Timer/Counter control
       register (TCCR0A) and the WGM02 bit located in the Timer/Counter control register B (TCCR0B). There are close
       connections between how the counter behaves (counts) and how waveforms are generated on the output compare outputs
       OC0A and OC0B. For more details about advanced counting sequences and waveform generation, see Section 5.14.7
       “Modes of Operation” on page 102.
       The Timer/Counter overflow flag (TOV0) is set according to the mode of operation selected by the WGM02:0 bits. TOV0 can
       be used for generating a CPU interrupt.
5.14.5 Output Compare Unit
       The 8-bit comparator continuously compares TCNT0 with the output compare registers (OCR0A and OCR0B). Whenever
       TCNT0 equals OCR0A or OCR0B, the comparator signals a match. A match will set the output compare flag (OCF0A or
       OCF0B) at the next timer clock cycle. If the corresponding interrupt is enabled, the output compare flag generates an output
       compare interrupt. The output compare flag is automatically cleared when the interrupt is executed. Alternatively, the flag
       can be cleared by software by writing a logical one to its I/O bit location. The waveform generator uses the match signal to
       generate an output according to operating mode set by the WGM02:0 bits and compare output mode (COM0x1:0) bits. The
       max and bottom signals are used by the waveform generator for handling the special cases of the extreme values in some
       modes of operation (Section 5.14.7 “Modes of Operation” on page 102).
       Figure 5-29 shows a block diagram of the output compare unit.
       Figure 5-29. Output Compare Unit, Block Diagram
                                                                 DATA BUS
                                                OCRnx                                    TCNTn
                                                             =  (8-bit Comparator)
                                                                                          OCFnx (Int. Req.)
                                            top
                                        bottom               Waveform Generator                    OCnx
                                         FOCn
                                                           WGMn[1:0]        COMnX[1:0]
100    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


        The OCR0x registers are double buffered when using any of the pulse width modulation (PWM) modes. For the normal and
        clear timer on compare (CTC) modes of operation, the double buffering is disabled. The double buffering synchronizes the
        update of the OCR0x compare registers to either top or bottom of the counting sequence. The synchronization prevents the
        occurrence of odd-length, non-symmetrical PWM pulses, thereby making the output glitch-free.
        The OCR0x register access may seem complex, but this is not case. When the double buffering is enabled, the CPU has
        access to the OCR0x buffer register, and if double buffering is disabled the CPU will access the OCR0x directly.
5.14.5.1 Force Output Compare
        In non-PWM waveform generation modes, the match output of the comparator can be forced by writing a one to the force
        output compare (FOC0x) bit. Forcing compare match will not set the OCF0x Flag or reload/clear the timer, but the OC0x pin
        will be updated as if a real compare match had occurred (the COM0x1:0 bits settings define whether the OC0x pin is set,
        cleared or toggled).
5.14.5.2 Compare Match Blocking by TCNT0 Write
        All CPU write operations to the TCNT0 Register will block any compare match that occur in the next timer clock cycle, even
        when the timer is stopped. This feature allows OCR0x to be initialized to the same value as TCNT0 without triggering an
        interrupt when the Timer/Counter clock is enabled.
5.14.5.3 Using the Output Compare Unit
        Since writing TCNT0 in any mode of operation will block all compare matches for one timer clock cycle, there are risks
        involved when changing TCNT0 when using the output compare unit, independently of whether the Timer/Counter is running
        or not. If the value written to TCNT0 equals the OCR0x value, the compare match will be missed, resulting in incorrect
        waveform generation. Similarly, do not write the TCNT0 value equal to BOTTOM when the counter is downcounting.
        The setup of the OC0x should be performed before setting the data direction register for the port pin to output. The easiest
        way of setting the OC0x value is to use the force output compare (FOC0x) strobe bits in normal mode. The OC0x registers
        keep their values even when changing between waveform generation modes.
        Be aware that the COM0x1:0 bits are not double buffered together with the compare value. Changing the COM0x1:0 bits will
        take effect immediately.
5.14.6 Compare Match Output Unit
        The compare output mode (COM0x1:0) bits have two functions. The waveform generator uses the COM0x1:0 bits for
        defining the output compare (OC0x) state at the next compare match. Also, the COM0x1:0 bits control the OC0x pin output
        source. Figure 5-30 on page 102 shows a simplified schematic of the logic affected by the COM0x1:0 bit setting. The I/O
        Registers, I/O bits, and I/O pins in the figure are shown in bold. Only the parts of the general I/O port control registers (DDR
        and PORT) that are affected by the COM0x1:0 bits are shown. When referring to the OC0x state, the reference is for the
        internal OC0x Register, not the OC0x pin. If a system reset occur, the OC0x register is reset to “0”.
                                                                                                 ATA6614Q [DATASHEET]                 101
                                                                                                               9240I–AUTO–03/16


      Figure 5-30. Compare Match Output Unit, Schematic
                            COMnx1
                            COMnx0            Waveform
                                              Generator           D          Q
                            FOCn
                                                                                    1
                                                                                                       OCnx
                                                                      OCnx                              Pin
                                                                                    0
                                                                  D          Q
                                                      DATA BUS
                                                                   PORT
                                                                  D          Q
                                                                      DDR
                          clkI/O
      The general I/O port function is overridden by the output compare (OC0x) from the waveform generator if either of the
      COM0x1:0 bits are set. However, the OC0x pin direction (input or output) is still controlled by the data direction register
      (DDR) for the port pin. The data direction register bit for the OC0x pin (DDR_OC0x) must be set as output before the OC0x
      value is visible on the pin. The port override function is independent of the waveform generation mode.
      The design of the output compare pin logic allows initialization of the OC0x state before the output is enabled. Note that
      some COM0x1:0 bit settings are reserved for certain modes of operation. See Section 5.14.9 “Register Description” on page
      107.
5.14.6.1 Compare Output Mode and Waveform Generation
      The waveform generator uses the COM0x1:0 bits differently in Normal, CTC, and PWM modes. For all modes, setting the
      COM0x1:0 = 0 tells the waveform generator that no action on the OC0x register is to be performed on the next compare
      match. For compare output actions in the non-PWM modes refer to Table 5-41 on page 108. For fast PWM mode, refer to
      Table 5-42 on page 108, and for phase correct PWM refer to Table 5-43 on page 108.
      A change of the COM0x1:0 bits state will have effect at the first compare match after the bits are written. For non-PWM
      modes, the action can be forced to have immediate effect by using the FOC0x strobe bits.
5.14.7 Modes of Operation
      The mode of operation, i.e., the behavior of the Timer/Counter and the output compare pins, is defined by the combination of
      the waveform generation mode (WGM02:0) and compare output mode (COM0x1:0) bits. The compare output mode bits do
      not affect the counting sequence, while the waveform generation mode bits do. The COM0x1:0 bits control whether the
      PWM output generated should be inverted or not (inverted or non-inverted PWM). For non-PWM modes the COM0x1:0 bits
      control whether the output should be set, cleared, or toggled at a compare match (See Section 5.14.6 “Compare Match
      Output Unit” on page 101).
      For detailed timing information refer to Section 5.14.8 “Timer/Counter Timing Diagrams” on page 106.
102   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.14.7.1 Normal Mode
        The simplest mode of operation is the normal mode (WGM02:0 = 0). In this mode the counting direction is always up
        (incrementing), and no counter clear is performed. The counter simply OverRuns when it passes its maximum 8-bit value
        (TOP = 0xFF) and then restarts from the bottom (0x00). In normal operation the Timer/Counter overflow flag (TOV0) will be
        set in the same timer clock cycle as the TCNT0 becomes zero. The TOV0 flag in this case behaves like a ninth bit, except
        that it is only set, not cleared. However, combined with the timer overflow interrupt that automatically clears the TOV0 flag,
        the timer resolution can be increased by software. There are no special cases to consider in the Normal mode, a new
        counter value can be written anytime.
        The output compare unit can be used to generate interrupts at some given time. Using the output compare to generate
        waveforms in normal mode is not recommended, since this will occupy too much of the CPU time.
5.14.7.2 Clear Timer on Compare Match (CTC) Mode
        In clear timer on compare or CTC mode (WGM02:0 = 2), the OCR0A register is used to manipulate the counter resolution. In
        CTC mode the counter is cleared to zero when the counter value (TCNT0) matches the OCR0A. The OCR0A defines the top
        value for the counter, hence also its resolution. This mode allows greater control of the compare match output frequency. It
        also simplifies the operation of counting external events.
        The timing diagram for the CTC mode is shown in Figure 5-31. The counter value (TCNT0) increases until a compare match
        occurs between TCNT0 and OCR0A, and then counter (TCNT0) is cleared.
        Figure 5-31. CTC Mode, Timing Diagram
                                                                                                             OCnx Interrupt
                                                                                                                Flag Set
                      TCNTn
                        OCnx                                                                              (COMnx1:0 = 1)
                     (Toggle)
                                                                1   2   3         4
                       Period
        An interrupt can be generated each time the counter value reaches the TOP value by using the OCF0A Flag. If the interrupt
        is enabled, the interrupt handler routine can be used for updating the TOP value. However, changing TOP to a value close to
        BOTTOM when the counter is running with none or a low prescaler value must be done with care since the CTC mode does
        not have the double buffering feature. If the new value written to OCR0A is lower than the current value of TCNT0, the
        counter will miss the compare match. The counter will then have to count to its maximum value (0xFF) and wrap around
        starting at 0x00 before the compare match can occur.
        For generating a waveform output in CTC mode, the OC0A output can be set to toggle its logical level on each compare
        match by setting the Compare Output mode bits to toggle mode (COM0A1:0 = 1). The OC0A value will not be visible on the
        port pin unless the data direction for the pin is set to output. The waveform generated will have a maximum frequency of fOC0
        = fclk_I/O/2 when OCR0A is set to zero (0x00). The waveform frequency is defined by the following equation:
                                  f clk_I/O
         f OCnx = -------------------------------------------------
                     2  N   1 + OCRnx 
        The N variable represents the prescale factor (1, 8, 64, 256, or 1024).
        As for the Normal mode of operation, the TOV0 Flag is set in the same timer clock cycle that the counter counts from MAX to
        0x00.
                                                                                                ATA6614Q [DATASHEET]               103
                                                                                                              9240I–AUTO–03/16


5.14.7.3 Fast PWM Mode
        The fast pulse width modulation or fast PWM mode (WGM02:0 = 3 or 7) provides a high frequency PWM waveform
        generation option. The fast PWM differs from the other PWM option by its single-slope operation. The counter counts from
        BOTTOM to TOP then restarts from BOTTOM. TOP is defined as 0xFF when WGM2:0 = 3, and OCR0A when WGM2:0 = 7.
        In non-inverting compare output mode, the output compare (OC0x) is cleared on the compare match between TCNT0 and
        OCR0x, and set at BOTTOM. In inverting compare output mode, the output is set on compare match and cleared at
        BOTTOM. Due to the single-slope operation, the operating frequency of the fast PWM mode can be twice as high as the
        phase correct PWM mode that use dual-slope operation. This high frequency makes the fast PWM mode well suited for
        power regulation, rectification, and DAC applications. High frequency allows physically small sized external components
        (coils, capacitors), and therefore reduces total system cost.
        In fast PWM mode, the counter is incremented until the counter value matches the TOP value. The counter is then cleared at
        the following timer clock cycle. The timing diagram for the fast PWM mode is shown in Figure 5-32. The TCNT0 value is in
        the timing diagram shown as a histogram for illustrating the single-slope operation. The diagram includes non-inverted and
        inverted PWM outputs. The small horizontal line marks on the TCNT0 slopes represent compare matches between OCR0x
        and TCNT0.
        Figure 5-32. Fast PWM Mode, Timing Diagram
                                                                                                          OCRnx Interrupt
                                                                                                              Flag Set
                                                                                                         OCRnx Update and
                                                                                                       TOVn Interrupt Flag Set
                  TCNTn
                    OCnx                                                                              (COMnx1:0 = 2)
                    OCnx                                                                              (COMnx1:0 = 3)
                                       1    2         3        4        5       6         7
                   Period
        The Timer/Counter overflow flag (TOV0) is set each time the counter reaches TOP. If the interrupt is enabled, the interrupt
        handler routine can be used for updating the compare value.
        In fast PWM mode, the compare unit allows generation of PWM waveforms on the OC0x pins. Setting the COM0x1:0 bits to
        two will produce a non-inverted PWM and an inverted PWM output can be generated by setting the COM0x1:0 to three:
        Setting the COM0A1:0 bits to one allows the OC0A pin to toggle on compare matches if the WGM02 bit is set. This option is
        not available for the OC0B pin (see Table 5-45 on page 109). The actual OC0x value will only be visible on the port pin if the
        data direction for the port pin is set as output. The PWM waveform is generated by setting (or clearing) the OC0x register at
        the compare match between OCR0x and TCNT0, and clearing (or setting) the OC0x register at the timer clock cycle the
        counter is cleared (changes from TOP to BOTTOM).
        The PWM frequency for the output can be calculated by the following equation:
                         f clk_I/O
         f OCnxPWM = -----------------
                         N  256
        The N variable represents the prescale factor (1, 8, 64, 256, or 1024).
        The extreme values for the OCR0A register represents special cases when generating a PWM waveform output in the fast
        PWM mode. If the OCR0A is set equal to BOTTOM, the output will be a narrow spike for each MAX+1 timer clock cycle.
        Setting the OCR0A equal to MAX will result in a constantly high or low output (depending on the polarity of the output set by
        the COM0A1:0 bits.)
104     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        A frequency (with 50% duty cycle) waveform output in fast PWM mode can be achieved by setting OC0x to toggle its logical
        level on each compare match (COM0x1:0 = 1). The waveform generated will have a maximum frequency of fOC0 = fclk_I/O/2
        when OCR0A is set to zero. This feature is similar to the OC0A toggle in CTC mode, except the double buffer feature of the
        output compare unit is enabled in the fast PWM mode.
5.14.7.4 Phase Correct PWM Mode
        The phase correct PWM mode (WGM02:0 = 1 or 5) provides a high resolution phase correct PWM waveform generation
        option. The phase correct PWM mode is based on a dual-slope operation. The counter counts repeatedly from BOTTOM to
        TOP and then from TOP to BOTTOM. TOP is defined as 0xFF when WGM2:0 = 1, and OCR0A when WGM2:0 = 5. In non-
        inverting compare output mode, the output compare (OC0x) is cleared on the compare match between TCNT0 and OCR0x
        while upcounting, and set on the compare match while downcounting. In inverting output compare mode, the operation is
        inverted. The dual-slope operation has lower maximum operation frequency than single slope operation. However, due to
        the symmetric feature of the dual-slope PWM modes, these modes are preferred for motor control applications.
        In phase correct PWM mode the counter is incremented until the counter value matches TOP. When the counter reaches
        TOP, it changes the count direction. The TCNT0 value will be equal to TOP for one timer clock cycle. The timing diagram for
        the phase correct PWM mode is shown on Figure 5-33. The TCNT0 value is in the timing diagram shown as a histogram for
        illustrating the dual-slope operation. The diagram includes non-inverted and inverted PWM outputs. The small horizontal line
        marks on the TCNT0 slopes represent compare matches between OCR0x and TCNT0.
        Figure 5-33. Phase Correct PWM Mode, Timing Diagram
                                                                                                            OCnx Interrupt
                                                                                                               Flag Set
                                                                                                            OCRnx Update
                                                                                                            TOVn Interrupt
                                                                                                               Flag Set
                   TCNTn
                     OCnx                                                                              (COMnx1:0 = 2)
                     OCnx                                                                              (COMnx1:0 = 3)
                                                  1                    2                3
                    Period
        The Timer/Counter overflow flag (TOV0) is set each time the counter reaches BOTTOM. The interrupt flag can be used to
        generate an interrupt each time the counter reaches the BOTTOM value.
        In phase correct PWM mode, the compare unit allows generation of PWM waveforms on the OC0x pins. Setting the
        COM0x1:0 bits to two will produce a non-inverted PWM. An inverted PWM output can be generated by setting the
        COM0x1:0 to three: Setting the COM0A0 bits to one allows the OC0A pin to toggle on compare matches if the WGM02 bit is
        set. This option is not available for the OC0B pin (see Table 5-46 on page 109). The actual OC0x value will only be visible on
        the port pin if the data direction for the port pin is set as output. The PWM waveform is generated by clearing (or setting) the
        OC0x register at the compare match between OCR0x and TCNT0 when the counter increments, and setting (or clearing) the
        OC0x register at compare match between OCR0x and TCNT0 when the counter decrements. The PWM frequency for the
        output when using phase correct PWM can be calculated by the following equation:
                             f clk_I/O
         f OCnxPCPWM = -----------------
                             N  510
        The N variable represents the prescale factor (1, 8, 64, 256, or 1024).
                                                                                                ATA6614Q [DATASHEET]                105
                                                                                                             9240I–AUTO–03/16


       The extreme values for the OCR0A register represent special cases when generating a PWM waveform output in the phase
       correct PWM mode. If the OCR0A is set equal to BOTTOM, the output will be continuously low and if set equal to MAX the
       output will be continuously high for non-inverted PWM mode. For inverted PWM the output will have the opposite logic
       values.
       At the very start of period 2 in Figure 5-33 OCnx has a transition from high to low even though there is no compare match.
       The point of this transition is to guarantee symmetry around BOTTOM. There are two cases that give a transition without
       compare match.
         ● OCRnx changes its value from MAX, like in Figure 5-33. When the OCR0A value is MAX the OCn pin value is the
              same as the result of a down-counting compare match. To ensure symmetry around BOTTOM the OCnx value at
              MAX must correspond to the result of an up-counting compare match.
         ●    The timer starts counting from a value higher than the one in OCRnx, and for that reason misses the compare match
              and hence the OCnx change that would have happened on the way up.
5.14.8 Timer/Counter Timing Diagrams
       The Timer/Counter is a synchronous design and the timer clock (clkT0) is therefore shown as a clock enable signal in the
       following figures. The figures include information on when interrupt flags are set. Figure 5-34 contains timing data for basic
       Timer/Counter operation. The figure shows the count sequence close to the MAX value in all modes other than phase
       correct PWM mode.
       Figure 5-34. Timer/Counter Timing Diagram, no Prescaling
                            clkI/O
                            clkTn
                        (clkI/O/1)
                         TCNTn                MAX - 1             MAX                BOTTOM             BOTTOM + 1
                           TOVn
       Figure 5-35 shows the same timing data, but with the prescaler enabled.
       Figure 5-35. Timer/Counter Timing Diagram, with Prescaler (fclk_I/O/8)
                            clkI/O
                            clkTn
                        (clkI/O/8)
                         TCNTn                MAX - 1             MAX                BOTTOM             BOTTOM + 1
                           TOVn
106    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


        Figure 5-36 shows the setting of OCF0B in all modes and OCF0A in all modes except CTC mode and PWM mode, where
        OCR0A is TOP.
        Figure 5-36. Timer/Counter Timing Diagram, Setting of OCF0x, with Prescaler (fclk_I/O/8)
                             clkI/O
                             clkTn
                         (clkI/O/8)
                          TCNTn            OCRnx - 1                 OCRnx             OCRnx + 1           OCRnx + 2
                          OCRnx                                            OCRnx Value
                          OCFnx
        Figure 5-37 shows the setting of OCF0A and the clearing of TCNT0 in CTC mode and fast PWM mode where OCR0A is
        TOP.
        Figure 5-37. Timer/Counter Timing Diagram, Clear Timer on Compare Match mode, with Prescaler (fclk_I/O/8)
                             clkI/O
                             clkTn
                         (clkI/O/8)
                          TCNTn
                            (CTC)           TOP - 1                   TOP              BOTTOM             BOTTOM + 1
                          OCRnx                                                TOP
                          OCFnx
5.14.9 Register Description
5.14.9.1 TCCR0A – Timer/Counter Control Register A
                 Bit           7       6          5          4           3         2        1          0
          0x24 (0x44)    COM0A1     COM0A0    COM0B1 COM0B0              –         –     WGM01     WGM00     TCCR0A
           Read/Write       R/W      R/W        R/W         R/W          R         R      R/W       R/W
           Initial Value       0       0          0          0           0         0        0          0
        • Bits 7:6 – COM0A1:0: Compare Match Output A Mode
        These bits control the output compare pin (OC0A) behavior. If one or both of the COM0A1:0 bits are set, the OC0A output
        overrides the normal port functionality of the I/O pin it is connected to. However, note that the data direction register (DDR)
        bit corresponding to the OC0A pin must be set in order to enable the output driver.
                                                                                                 ATA6614Q [DATASHEET]                107
                                                                                                               9240I–AUTO–03/16


    When OC0A is connected to the pin, the function of the COM0A1:0 bits depends on the WGM02:0 bit setting. Table 5-41
    shows the COM0A1:0 bit functionality when the WGM02:0 bits are set to a normal or CTC mode (non-PWM).
    Table 5-41. Compare Output Mode, non-PWM Mode
         COM0A1             COM0A0           Description
              0                  0           Normal port operation, OC0A disconnected.
              0                  1           Toggle OC0A on compare match
              1                  0           Clear OC0A on compare match
              1                  1           Set OC0A on compare match
    Table 5-42 shows the COM0A1:0 bit functionality when the WGM01:0 bits are set to fast PWM mode.
    Table 5-42. Compare Output Mode, Fast PWM Mode(1)
         COM0A1             COM0A0           Description
              0                  0           Normal port operation, OC0A disconnected.
                                             WGM02 = 0: Normal port operation, OC0A disconnected.
              0                  1
                                             WGM02 = 1: Toggle OC0A on compare match.
              1                  0           Clear OC0A on compare match, set OC0A at BOTTOM, (non-inverting mode).
              1                  1           Set OC0A on compare match, clear OC0A at BOTTOM, (inverting mode).
    Note:     1.  A special case occurs when OCR0A equals TOP and COM0A1 is set. In this case, the compare match is
                  ignored, but the set or clear is done at BOTTOM. See Section 5.14.7.3 “Fast PWM Mode” on page 104 for
                  more details.
    Table 5-43 shows the COM0A1:0 bit functionality when the WGM02:0 bits are set to phase correct PWM mode.
    Table 5-43. Compare Output Mode, Phase Correct PWM Mode(1)
        COM0A1          COM0A0        Description
            0               0         Normal port operation, OC0A disconnected.
                                      WGM02 = 0: Normal port operation, OC0A disconnected.
            0               1
                                      WGM02 = 1: Toggle OC0A on compare match.
                                      Clear OC0A on compare match when up-counting. Set OC0A on compare match when
            1               0
                                      down-counting.
                                      Set OC0A on compare match when up-counting. Clear OC0A on compare match when
            1               1
                                      down-counting.
    Note:     1.  A special case occurs when OCR0A equals TOP and COM0A1 is set. In this case, the compare match is
                  ignored, but the set or clear is done at TOP. See Section 5.15.9.4 “Phase Correct PWM Mode” on page 126 for
                  more details.
    • Bits 5:4 – COM0B1:0: Compare Match Output B Mode
    These bits control the output compare pin (OC0B) behavior. If one or both of the COM0B1:0 bits are set, the OC0B output
    overrides the normal port functionality of the I/O pin it is connected to. However, note that the data direction register (DDR)
    bit corresponding to the OC0B pin must be set in order to enable the output driver.
    When OC0B is connected to the pin, the function of the COM0B1:0 bits depends on the WGM02:0 bit setting. Table 5-44
    shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to a normal or CTC mode (non-PWM).
    Table 5-44. Compare Output Mode, non-PWM Mode
         COM0B1             COM0B0           Description
              0                  0           Normal port operation, OC0B disconnected.
              0                  1           Toggle OC0B on compare match
              1                  0           Clear OC0B on compare match
              1                  1           Set OC0B on compare match
108 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


Table 5-45 shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to fast PWM mode.
Table 5-45. Compare Output Mode, Fast PWM Mode(1)
     COM0B1             COM0B0           Description
         0                   0           Normal port operation, OC0B disconnected.
         0                   1           Reserved
         1                   0           Clear OC0B on compare match, set OC0B at BOTTOM, (non-inverting mode)
         1                   1           Set OC0B on compare match, clear OC0B at BOTTOM, (inverting mode).
Note:    1.   A special case occurs when OCR0B equals TOP and COM0B1 is set. In this case, the compare match is
              ignored, but the set or clear is done at TOP. See Section 5.14.7.3 “Fast PWM Mode” on page 104 for more
              details.
Table 5-46 shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to phase correct PWM mode.
Table 5-46. Compare Output Mode, Phase Correct PWM Mode(1)
     COM0B1             COM0B0           Description
         0                   0           Normal port operation, OC0B disconnected.
         0                   1           Reserved
                                         Clear OC0B on compare match when up-counting. Set OC0B on compare match
         1                   0
                                         when down-counting.
                                         Set OC0B on compare match when up-counting. Clear OC0B on compare match
         1                   1
                                         when down-counting.
Note:    1.   A special case occurs when OCR0B equals TOP and COM0B1 is set. In this case, the compare match is
              ignored, but the set or clear is done at TOP. See Section 5.14.7.4 “Phase Correct PWM Mode” on page 105 for
              more details.
• Bits 3, 2 – Res: Reserved Bits
These bits are reserved bits in the ATmega328P and will always read as zero.
• Bits 1:0 – WGM01:0: Waveform Generation Mode
Combined with the WGM02 bit found in the TCCR0B register, these bits control the counting sequence of the counter, the
source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 5-47. Modes of
operation supported by the Timer/Counter unit are: Normal mode (counter), clear timer on compare match (CTC) mode, and
two types of pulse width modulation (PWM) modes (see Section 5.14.7 “Modes of Operation” on page 102).
Table 5-47. Waveform Generation Mode Bit Description
                                                            Timer/Counter                    Update of        TOV Flag
  Mode         WGM02          WGM01           WGM00      Mode of Operation        TOP        OCRx at          Set on(1)(2)
     0            0              0               0             Normal             0xFF      Immediate            MAX
                                                             PWM, Phase
     1            0              0               1                                0xFF          TOP           BOTTOM
                                                               Correct
     2            0              1               0               CTC             OCRA       Immediate            MAX
     3            0              1               1            Fast PWM            0xFF       BOTTOM              MAX
     4            1              0               0            Reserved              –            –                 –
                                                             PWM, Phase
     5            1              0               1                               OCRA           TOP           BOTTOM
                                                               Correct
     6            1              1               0            Reserved              –            –                 –
     7            1              1               1            Fast PWM           OCRA        BOTTOM              TOP
Notes:   1.   MAX = 0xFF
         2.   BOTTOM = 0x00
                                                                                      ATA6614Q [DATASHEET]               109
                                                                                                   9240I–AUTO–03/16


5.14.9.2 TCCR0B – Timer/Counter Control Register B
                 Bit        7          6           5         4           3        2         1        0
           0x25 (0x45)   FOC0A      FOC0B          –         –        WGM02      CS02     CS01     CS00     TCCR0B
           Read/Write      W           W           R         R         R/W       R/W      R/W      R/W
           Initial Value    0          0           0         0           0        0         0        0
        • Bit 7 – FOC0A: Force Output Compare A
        The FOC0A bit is only active when the WGM bits specify a non-PWM mode.
        However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0B is written when operating
        in PWM mode. When writing a logical one to the FOC0A bit, an immediate compare match is forced on the waveform
        generation unit. The OC0A output is changed according to its COM0A1:0 bits setting. Note that the FOC0A bit is
        implemented as a strobe. Therefore it is the value present in the COM0A1:0 bits that determines the effect of the forced
        compare.
        A FOC0A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR0A as TOP.
        The FOC0A bit is always read as zero.
        • Bit 6 – FOC0B: Force Output Compare B
        The FOC0B bit is only active when the WGM bits specify a non-PWM mode.
        However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0B is written when operating
        in PWM mode. When writing a logical one to the FOC0B bit, an immediate compare match is forced on the waveform
        generation unit. The OC0B output is changed according to its COM0B1:0 bits setting. Note that the FOC0B bit is
        implemented as a strobe. Therefore it is the value present in the COM0B1:0 bits that determines the effect of the forced
        compare.
        A FOC0B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR0B as TOP.
        The FOC0B bit is always read as zero.
        • Bits 5:4 – Res: Reserved Bits
        These bits are reserved bits in the ATmega328P and will always read as zero.
        • Bit 3 – WGM02: Waveform Generation Mode
        See the description in the Section 5.14.9.1 “TCCR0A – Timer/Counter Control Register A” on page 107.
        • Bits 2:0 – CS02:0: Clock Select
        The three clock select bits select the clock source to be used by the Timer/Counter.
        Table 5-48. Clock Select Bit Description
               CS02           CS01            CS00        Description
                  0             0                0        No clock source (Timer/Counter stopped)
                  0             0                1        clkI/O/(no prescaling)
                  0             1                0        clkI/O/8 (from prescaler)
                  0             1                1        clkI/O/64 (from prescaler)
                  1             0                0        clkI/O/256 (from prescaler)
                  1             0                1        clkI/O/1024 (from prescaler)
                  1             1                0        External clock source on T0 pin. Clock on falling edge.
                  1             1                1        External clock source on T0 pin. Clock on rising edge.
        If external pin modes are used for the Timer/Counter0, transitions on the T0 pin will clock the counter even if the pin is
        configured as an output. This feature allows software control of the counting.
110     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.14.9.3 TCNT0 – Timer/Counter Register
                 Bit        7         6           5         4          3         2            1        0
           0x26 (0x46)                                      TCNT0[7:0]                                         TCNT0
           Read/Write      R/W       R/W        R/W        R/W       R/W        R/W         R/W       R/W
           Initial Value    0         0           0         0          0         0            0        0
        The Timer/Counter register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter.
        Writing to the TCNT0 register blocks (removes) the compare match on the following timer clock. Modifying the counter
        (TCNT0) while the counter is running, introduces a risk of missing a compare match between TCNT0 and the OCR0x
        registers.
5.14.9.4 OCR0A – Output Compare Register A
                 Bit        7         6           5         4          3         2            1        0
           0x27 (0x47)                                      OCR0A[7:0]                                         OCR0A
           Read/Write      R/W       R/W        R/W        R/W       R/W        R/W         R/W       R/W
           Initial Value    0         0           0         0          0         0            0        0
        The output compare register A contains an 8-bit value that is continuously compared with the counter value (TCNT0). A
        match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0A pin.
5.14.9.5 OCR0B – Output Compare Register B
                 Bit        7         6           5         4          3         2            1        0
           0x28 (0x48)                                      OCR0B[7:0]                                         OCR0B
           Read/Write      R/W       R/W        R/W        R/W       R/W        R/W         R/W       R/W
           Initial Value    0         0           0         0          0         0            0        0
        The output compare register B contains an 8-bit value that is continuously compared with the counter value (TCNT0). A
        match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0B pin.
5.14.9.6 TIMSK0 – Timer/Counter Interrupt Mask Register
                 Bit        7         6          5          4         3          2            1        0
              (0x6E)        –         –          –          –         –       OCIE0B     OCIE0A      TOIE0     TIMSK0
           Read/Write       R         R          R          R         R         R/W         R/W       R/W
           Initial Value    0         0          0          0         0          0            0        0
        • Bits 7..3 – Res: Reserved Bits
        These bits are reserved bits in the ATmega328P and will always read as zero.
        • Bit 2 – OCIE0B: Timer/Counter Output Compare Match B Interrupt Enable
        When the OCIE0B bit is written to one, and the I-bit in the status register is set, the Timer/Counter compare match B interrupt
        is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter occurs, i.e., when the OCF0B bit is
        set in the Timer/Counter interrupt flag register – TIFR0.
        • Bit 1 – OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable
        When the OCIE0A bit is written to one, and the I-bit in the status register is set, the Timer/Counter0 compare match A
        interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter0 occurs, i.e., when the
        OCF0A bit is set in the Timer/Counter 0 interrupt flag register – TIFR0.
        • Bit 0 – TOIE0: Timer/Counter0 Overflow Interrupt Enable
        When the TOIE0 bit is written to one, and the I-bit in the status register is set, the Timer/Counter0 overflow interrupt is
        enabled. The corresponding interrupt is executed if an overflow in Timer/Counter0 occurs, i.e., when the TOV0 bit is set in
        the Timer/Counter 0 interrupt flag register – TIFR0.
                                                                                                  ATA6614Q [DATASHEET]              111
                                                                                                                9240I–AUTO–03/16


5.14.9.7 TIFR0 – Timer/Counter 0 Interrupt Flag Register
                 Bit          7         6          5        4           3       2        1          0
           0x15 (0x35)        –         –          –        –           –    OCF0B    OCF0A       TOV0       TIFR0
           Read/Write        R         R           R       R            R      R/W      R/W        R/W
           Initial Value      0         0          0        0           0       0        0          0
        • Bits 7..3 – Res: Reserved Bits
        These bits are reserved bits in the ATmega328P and will always read as zero.
        • Bit 2 – OCF0B: Timer/Counter 0 Output Compare B Match Flag
        The OCF0B bit is set when a compare match occurs between the Timer/Counter and the data in OCR0B – output compare
        register0 B. OCF0B is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively,
        OCF0B is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0B (Timer/Counter compare B match
        interrupt Enable), and OCF0B are set, the Timer/Counter compare match interrupt is executed.
        • Bit 1 – OCF0A: Timer/Counter 0 Output Compare A Match Flag
        The OCF0A bit is set when a compare match occurs between the Timer/Counter0 and the data in OCR0A – output compare
        register0. OCF0A is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF0A
        is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0A (Timer/Counter0 compare match interrupt
        enable), and OCF0A are set, the Timer/Counter0 compare match interrupt is executed.
        • Bit 0 – TOV0: Timer/Counter0 Overflow Flag
        The bit TOV0 is set when an overflow occurs in Timer/Counter0. TOV0 is cleared by hardware when executing the
        corresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When the SREG I-
        bit, TOIE0 (Timer/Counter0 overflow interrupt enable), and TOV0 are set, the Timer/Counter0 Overflow interrupt is executed.
        The setting of this flag is dependent of the WGM02:0 bit setting. Refer to Table 5-47 on page 109.
112     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.15   16-bit Timer/Counter1 with PWM
5.15.1 Features
         ●    True 16-bit design (i.e., allows 16-bit PWM)
         ●    Two independent output compare units
         ●    Double buffered output compare registers
         ●    One input capture unit
         ●    Input capture noise canceler
         ●    Clear timer on compare match (auto reload)
         ●    Glitch-free, phase correct pulse width modulator (PWM)
         ●    Variable PWM period
         ●    Frequency generator
         ●    External event counter
         ●    Four independent interrupt sources (TOV1, OCF1A, OCF1B, and ICF1)
5.15.2 Overview
       The 16-bit Timer/Counter unit allows accurate program execution timing (event management), wave generation, and signal
       timing measurement.
       Most register and bit references in this section are written in general form. A lower case “n” replaces the Timer/Counter
       number, and a lower case “x” replaces the output compare unit channel. However, when using the register or bit defines in a
       program, the precise form must be used, i.e., TCNT1 for accessing Timer/Counter1 counter value and so on.
       A simplified block diagram of the 16-bit Timer/Counter is shown in Figure 5-38. The device-specific I/O register and bit
       locations are listed in the Section 5.15.11 “Register Description” on page 131.
       The PRTIM1 bit in Section 5.9.11.3 “PRR – Power Reduction Register” on page 63 must be written to zero to enable
       Timer/Counter1 module.
                                                                                               ATA6614Q [DATASHEET]              113
                                                                                                             9240I–AUTO–03/16


       Figure 5-38. 16-bit Timer/Counter Block Diagram(1)
                                                                                                        TOVn (Int. Req.)
                                                       Count
                                                       Clear                                             Clock Select
                                                                  Control Logic
                                                      Direction                                           Edge
                                                                                      clkTn
                                                                                                                                      Tn
                                                                                                         Detector
                                                                                                       (From Prescaler)
                                                                    TOP      BOTTOM
                                      Timer/Counter
                                         TCNTn
                                                                      =               =   0
                                                                                                     OCnA (Int. Req.)
                                                                                                      Waveform
                                           =                                                          Generation
                                                                                                                                     OCnA
                                         OCRnA
                                                                            Fixed
                DATA BUS
                                                                            TOP                      OCnB (Int. Req.)
                                                                            Value
                                                                                                      Waveform
                                           =                                                          Generation
                                                                                                                                     OCnB
                                         OCRnB                                                                            (From Analog
                                                                                                                        Comparator Output)
                                                                                  ICFn (Int. Req.)
                                                                                     Edge               Noise
                                          ICRn
                                                                                    Detector           Canceler
                                                                                                                                     ICPn
                                        TCCRnA                        TCCRnB
       Note:    1.         Refer to Table 5-31 on page 89 and Table 5-37 on page 94 for Timer/Counter1 pin placement and description.
5.15.2.1 Registers
       The Timer/Counter (TCNT1), Output Compare Registers (OCR1A/B), and Input Capture Register (ICR1) are all 16-bit
       registers. Special procedures must be followed when accessing the 16-bit registers. These procedures are described in
       Section 5.15.3 “Accessing 16-bit Registers” on page 115. The Timer/Counter Control Registers (TCCR1A/B) are 8-bit
       registers and have no CPU access restrictions. Interrupt requests (abbreviated to Int.Req. in the figure) signals are all visible
       in the Timer Interrupt Flag Register (TIFR1). All interrupts are individually masked with the Timer Interrupt Mask Register
       (TIMSK1). TIFR1 and TIMSK1 are not shown in the figure.
       The Timer/Counter can be clocked internally, via the prescaler, or by an external clock source on the T1 pin. The clock select
       logic block controls which clock source and edge the Timer/Counter uses to increment (or decrement) its value. The
       Timer/Counter is inactive when no clock source is selected. The output from the clock select logic is referred to as the timer
       clock (clkT1).
       The double buffered output compare registers (OCR1A/B) are compared with the Timer/Counter value at all time. The result
       of the compare can be used by the waveform generator to generate a PWM or variable frequency output on the output
       compare pin (OC1A/B). See Section 5.15.7 “Output Compare Units” on page 120. The compare match event will also set the
       compare match flag (OCF1A/B) which can be used to generate an output compare interrupt request.
       The input capture register can capture the Timer/Counter value at a given external (edge triggered) event on either the input
       capture pin (ICP1) or on the analog comparator pins (see Section 5.22 “Analog Comparator” on page 223).
114    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


        The input capture unit includes a digital filtering unit (noise canceler) for reducing the chance of capturing noise spikes. The
        TOP value, or maximum Timer/Counter value, can in some modes of operation be defined by either the OCR1A register, the
        ICR1 register, or by a set of fixed values. When using OCR1A as TOP value in a PWM mode, the OCR1A register can not be
        used for generating a PWM output. However, the TOP value will in this case be double buffered allowing the TOP value to
        be changed in run time. If a fixed TOP value is required, the ICR1 register can be used as an alternative, freeing the OCR1A
        to be used as PWM output.
5.15.2.2 Definitions
        The definitions in Table 5-49 are also used extensively throughout the section.
        Table 5-49. Definitions
               Case          Definition
             BOTTOM          The counter reaches the BOTTOM when it becomes 0x0000.
               MAX           The counter reaches its MAXimum when it becomes 0xFFFF (decimal 65535).
                             The counter reaches the TOP when it becomes equal to the highest value in the count sequence. The
                TOP          TOP value can be assigned to be one of the fixed values: 0x00FF, 0x01FF, or 0x03FF, or to the value
                             stored in the OCR1A or ICR1 register. The assignment is dependent of the mode of operation.
5.15.3 Accessing 16-bit Registers
        The TCNT1, OCR1A/B, and ICR1 are 16-bit registers that can be accessed by the AVR® CPU via the 8-bit data bus. The 16-
        bit register must be byte accessed using two read or write operations. Each 16-bit timer has a single 8-bit register for
        temporary storing of the high byte of the 16-bit access. The same temporary register is shared between all 16-bit registers
        within each 16-bit timer. Accessing the low byte triggers the 16-bit read or write operation. When the low byte of a 16-bit
        register is written by the CPU, the high byte stored in the temporary register, and the low byte written are both copied into the
        16-bit register in the same clock cycle. When the low byte of a 16-bit register is read by the CPU, the high byte of the 16-bit
        register is copied into the temporary register in the same clock cycle as the low byte is read.
        Not all 16-bit accesses uses the temporary register for the high byte. Reading the OCR1A/B 16-bit registers does not involve
        using the temporary register. To do a 16-bit write, the high byte must be written before the low byte. For a 16-bit read, the low
        byte must be read before the high byte.
        The following code examples show how to access the 16-bit timer registers assuming that no interrupts updates the
        temporary register. The same principle can be used directly for accessing the OCR1A/B and ICR1 Registers. Note that when
        using “C”, the compiler handles the 16-bit access.
         Assembly Code Examples(1)
                             ...
                             ; Set TCNT1 to 0x01FF
                             ldi      r17,0x01
                             ldi      r16,0xFF
                             out      TCNT1H,r17
                             out      TCNT1L,r16
                             ; Read TCNT1 into r17:r16
                             in       r16,TCNT1L
                             in       r17,TCNT1H
                             ...
         C Code Examples(1)
                             unsigned int i;
                             ...
                             /* Set TCNT1 to 0x01FF */
                             TCNT1 = 0x1FF;
                             /* Read TCNT1 into i */
                             i = TCNT1;
                             ...
         Note:     1. See Section 5.5 “About Code Examples” on page 32. For I/O registers located in extended I/O map, “IN”,
                         “OUT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must be replaced with instructions that allow access to
                         extended I/O. Typically “LDS” and “STS” combined with “SBRS”, “SBRC”, “SBR”, and “CBR”.
                                                                                                  ATA6614Q [DATASHEET]               115
                                                                                                               9240I–AUTO–03/16


    The assembly code example returns the TCNT1 value in the r17:r16 register pair.
    It is important to notice that accessing 16-bit registers are atomic operations. If an interrupt occurs between the two
    instructions accessing the 16-bit register, and the interrupt code updates the temporary register by accessing the same or
    any other of the 16-bit timer registers, then the result of the access outside the interrupt will be corrupted. Therefore, when
    both the main code and the interrupt code update the temporary register, the main code must disable the interrupts during
    the 16-bit access.
    The following code examples show how to do an atomic read of the TCNT1 register contents. Reading any of the OCR1A/B
    or ICR1 registers can be done by using the same principle.
     Assembly Code Example(1)
               TIM16_ReadTCNT1:
                         ; Save global interrupt flag
                         in        r18,SREG
                         ; Disable interrupts
                         cli
                         ; Read TCNT1 into r17:r16
                         in        r16,TCNT1L
                         in        r17,TCNT1H
                         ; Restore global interrupt flag
                         out       SREG,r18
                         ret
     C Code Example(1)
               unsigned int TIM16_ReadTCNT1( void )
               {
                         unsigned char sreg;
                         unsigned int i;
                         /* Save global interrupt flag */
                         sreg = SREG;
                         /* Disable interrupts */
                         _CLI();
                         /* Read TCNT1 into i */
                         i = TCNT1;
                         /* Restore global interrupt flag */
                         SREG = sreg;
                         return i;
               }
     Note:     1.   See Section 5.5 “About Code Examples” on page 32.
                    For I/O registers located in extended I/O map, “IN”, “OUT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must
                    be replaced with instructions that allow access to extended I/O. Typically “LDS” and “STS” combined with
                    “SBRS”, “SBRC”, “SBR”, and “CBR”.
    The assembly code example returns the TCNT1 value in the r17:r16 register pair.
116 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


        The following code examples show how to do an atomic write of the TCNT1 register contents. Writing any of the OCR1A/B
        or ICR1 Registers can be done by using the same principle.
         Assembly Code Example(1)
                    TIM16_WriteTCNT1:
                             ; Save global interrupt flag
                             in       r18,SREG
                             ; Disable interrupts
                             cli
                             ; Set TCNT1 to r17:r16
                             out      TCNT1H,r17
                             out      TCNT1L,r16
                             ; Restore global interrupt flag
                             out      SREG,r18
                             ret
         C Code Example(1)
                    void TIM16_WriteTCNT1( unsigned int i )
                    {
                             unsigned char sreg;
                             unsigned int i;
                             /* Save global interrupt flag */
                             sreg = SREG;
                             /* Disable interrupts */
                             _CLI();
                             /* Set TCNT1 to i */
                             TCNT1 = i;
                             /* Restore global interrupt flag */
                             SREG = sreg;
                    }
         Note:      1.  See Section 5.5 “About Code Examples” on page 32.
                        For I/O registers located in extended I/O map, “IN”, “OUT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must
                        be replaced with instructions that allow access to extended I/O. Typically “LDS” and “STS” combined with
                        “SBRS”, “SBRC”, “SBR”, and “CBR”.
        The assembly code example requires that the r17:r16 register pair contains the value to be written to TCNT1.
5.15.3.1 Reusing the Temporary High Byte Register
        If writing to more than one 16-bit register where the high byte is the same for all registers written, then the high byte only
        needs to be written once. However, note that the same rule of atomic operation described previously also applies in this
        case.
5.15.4 Timer/Counter Clock Sources
        The Timer/Counter can be clocked by an internal or an external clock source. The clock source is selected by the clock
        select logic which is controlled by the Clock Select (CS12:0) bits located in the Timer/Counter control Register B (TCCR1B).
        For details on clock sources and prescaler, see Section 5.16 “Timer/Counter0 and Timer/Counter1 Prescalers” on page 137.
                                                                                                 ATA6614Q [DATASHEET]                 117
                                                                                                                9240I–AUTO–03/16


5.15.5 Counter Unit
       The main part of the 16-bit Timer/Counter is the programmable 16-bit bi-directional counter unit. Figure 5-39 shows a block
       diagram of the counter and its surroundings.
       Figure 5-39. Counter Unit Block Diagram
                             DATA BUS      (8-bit)
                                                                                       TOVn
                                                                                       (Int. Req.)
                      TEMP (8-bit)
                                                                                                        Clock Select
                                                               Count                                      Edge
                     TCNTnH (8-bit)       TCNTnL (8-bit)                                                                     Tn
                                                                Clear                      clkTn         Detector
                                                                         Control Logic
                                                              Direction
                           TCNTnH (16-bit Counter)                                                    (From Prescaler)
                                                                       TOP           BOTTOM
       Signal description (internal signals):
               Count                         Increment or decrement TCNT1 by 1.
               Direction                     Select between increment and decrement.
               Clear                         Clear TCNT1 (set all bits to zero).
               clkT1                         Timer/Counter clock.
               TOP                           Signalize that TCNT1 has reached maximum value.
               BOTTOM                        Signalize that TCNT1 has reached minimum value (zero).
       The 16-bit counter is mapped into two 8-bit I/O memory locations: Counter High (TCNT1H) containing the upper eight bits of
       the counter, and Counter Low (TCNT1L) containing the lower eight bits. The TCNT1H register can only be indirectly
       accessed by the CPU. When the CPU does an access to the TCNT1H I/O location, the CPU accesses the high byte
       temporary register (TEMP). The temporary register is updated with the TCNT1H value when the TCNT1L is read, and
       TCNT1H is updated with the temporary register value when TCNT1L is written. This allows the CPU to read or write the
       entire 16-bit counter value within one clock cycle via the 8-bit data bus. It is important to notice that there are special cases
       of writing to the TCNT1 register when the counter is counting that will give unpredictable results. The special cases are
       described in the sections where they are of importance.
       Depending on the mode of operation used, the counter is cleared, incremented, or decremented at each timer clock (clkT1).
       The clkT1 can be generated from an external or internal clock source, selected by the Clock Select bits (CS12:0). When no
       clock source is selected (CS12:0 = 0) the timer is stopped. However, the TCNT1 value can be accessed by the CPU,
       independent of whether clkT1 is present or not. A CPU write overrides (has priority over) all counter clear or count operations.
       The counting sequence is determined by the setting of the Waveform Generation mode bits (WGM13:0) located in the
       Timer/Counter Control Registers A and B (TCCR1A and TCCR1B). There are close connections between how the counter
       behaves (counts) and how waveforms are generated on the output compare outputs OC1x. For more details about
       advanced counting sequences and waveform generation, see Section 5.15.9 “Modes of Operation” on page 123.
       The Timer/Counter overflow flag (TOV1) is set according to the mode of operation selected by the WGM13:0 bits. TOV1 can
       be used for generating a CPU interrupt.
5.15.6 Input Capture Unit
       The Timer/Counter incorporates an input capture unit that can capture external events and give them a time-stamp
       indicating time of occurrence. The external signal indicating an event, or multiple events, can be applied via the ICP1 pin or
       alternatively, via the analog-comparator unit. The time-stamps can then be used to calculate frequency, duty-cycle, and
       other features of the signal applied. Alternatively the time-stamps can be used for creating a log of the events.
       The input capture unit is illustrated by the block diagram shown in Figure 5-40. The elements of the block diagram that are
       not directly a part of the input capture unit are gray shaded. The small “n” in register and bit names indicates the
       Timer/Counter number.
118    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


        Figure 5-40. Input Capture Unit Block Diagram
                                                                    DATA BUS (8-bit)
                                 TEMP (8-bit)
                                 ICRnH (8-bit)         ICRnL (8-bit)             TCNTnH (8-bit)        TCNTnL (8-bit)
                            WRITE      ICRn (16-bit Register)                         TCNTn (16-bit Counter)
                                    +      ACO*               ACIC*       ICNC                   ICES
                                    -    Analog
                                      Comparator
                                                                          Noise                  Edge
                                                                                                                    ICFn (Int. Req.)
                                                                        Canceler                Detector
                        ICPn
        When a change of the logic level (an event) occurs on the input capture pin (ICP1), alternatively on the analog comparator
        output (ACO), and this change confirms to the setting of the edge detector, a capture will be triggered. When a capture is
        triggered, the 16-bit value of the counter (TCNT1) is written to the input capture register (ICR1). The input capture flag (ICF1)
        is set at the same system clock as the TCNT1 value is copied into ICR1 register. If enabled (ICIE1 = 1), the input capture flag
        generates an input capture interrupt. The ICF1 flag is automatically cleared when the interrupt is executed. Alternatively the
        ICF1 flag can be cleared by software by writing a logical one to its I/O bit location.
        Reading the 16-bit value in the input capture register (ICR1) is done by first reading the low byte (ICR1L) and then the high
        byte (ICR1H). When the low byte is read the high byte is copied into the high byte temporary register (TEMP). When the
        CPU reads the ICR1H I/O location it will access the TEMP register.
        The ICR1 register can only be written when using a waveform generation mode that utilizes the ICR1 register for defining the
        counter’s TOP value. In these cases the waveform generation mode (WGM13:0) bits must be set before the TOP value can
        be written to the ICR1 register. When writing the ICR1 register the high byte must be written to the ICR1H I/O location before
        the low byte is written to ICR1L.
        For more information on how to access the 16-bit registers refer to Section 5.15.3 “Accessing 16-bit Registers” on page 115.
5.15.6.1 Input Capture Trigger Source
        The main trigger source for the input capture unit is the input capture pin (ICP1). Timer/Counter1 can alternatively use the
        analog comparator output as trigger source for the input capture unit. The analog comparator is selected as trigger source by
        setting the analog comparator input capture (ACIC) bit in the analog comparator control and status register (ACSR). Be
        aware that changing trigger source can trigger a capture. The input capture flag must therefore be cleared after the change.
        Both the input capture pin (ICP1) and the analog comparator output (ACO) inputs are sampled using the same technique as
        for the T1 pin (Figure 5-51 on page 137). The edge detector is also identical. However, when the noise canceler is enabled,
        additional logic is inserted before the edge detector, which increases the delay by four system clock cycles. Note that the
        input of the noise canceler and edge detector is always enabled unless the Timer/Counter is set in a waveform generation
        mode that uses ICR1 to define TOP.
        An input capture can be triggered by software by controlling the port of the ICP1 pin.
                                                                                                     ATA6614Q [DATASHEET]              119
                                                                                                                      9240I–AUTO–03/16


5.15.6.2 Noise Canceler
        The noise canceler improves noise immunity by using a simple digital filtering scheme. The noise canceler input is monitored
        over four samples, and all four must be equal for changing the output that in turn is used by the edge detector.
        The noise canceler is enabled by setting the input capture noise canceler (ICNC1) bit in Timer/Counter control register B
        (TCCR1B). When enabled the noise canceler introduces additional four system clock cycles of delay from a change applied
        to the input, to the update of the ICR1 register. The noise canceler uses the system clock and is therefore not affected by the
        prescaler.
5.15.6.3 Using the Input Capture Unit
        The main challenge when using the input capture unit is to assign enough processor capacity for handling the incoming
        events. The time between two events is critical. If the processor has not read the captured value in the ICR1 register before
        the next event occurs, the ICR1 will be overwritten with a new value. In this case the result of the capture will be incorrect.
        When using the input capture interrupt, the ICR1 register should be read as early in the interrupt handler routine as possible.
        Even though the input capture interrupt has relatively high priority, the maximum interrupt response time is dependent on the
        maximum number of clock cycles it takes to handle any of the other interrupt requests.
        Using the input capture unit in any mode of operation when the TOP value (resolution) is actively changed during operation,
        is not recommended.
        Measurement of an external signal’s duty cycle requires that the trigger edge is changed after each capture. Changing the
        edge sensing must be done as early as possible after the ICR1 register has been read. After a change of the edge, the input
        capture flag (ICF1) must be cleared by software (writing a logical one to the I/O bit location). For measuring frequency only,
        the clearing of the ICF1 flag is not required (if an interrupt handler is used).
5.15.7 Output Compare Units
        The 16-bit comparator continuously compares TCNT1 with the output compare register (OCR1x). If TCNT equals OCR1x
        the comparator signals a match. A match will set the output compare flag (OCF1x) at the next timer clock cycle. If enabled
        (OCIE1x = 1), the output compare flag generates an output compare interrupt. The OCF1x Flag is automatically cleared
        when the interrupt is executed. Alternatively the OCF1x flag can be cleared by software by writing a logical one to its I/O bit
        location. The waveform generator uses the match signal to generate an output according to operating mode set by the
        waveform generation mode (WGM13:0) bits and compare output mode (COM1x1:0) bits. The TOP and BOTTOM signals
        are used by the waveform generator for handling the special cases of the extreme values in some modes of operation (see
        Section 5.15.9 “Modes of Operation” on page 123).
        A special feature of output compare unit A allows it to define the Timer/Counter TOP value (i.e., counter resolution). In
        addition to the counter resolution, the TOP value defines the period time for waveforms generated by the waveform
        generator.
        Figure 5-41 shows a block diagram of the output compare unit. The small “n” in the register and bit names indicates the
        device number (n = 1 for Timer/Counter 1), and the “x” indicates output compare unit (A/B). The elements of the block
        diagram that are not directly a part of the output compare unit are gray shaded.
120     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        Figure 5-41. Output Compare Unit, Block Diagram
                                                                      DATA BUS (8-bit)
                                              TEMP (8-bit)
                                       OCRnxH Buf. (8-bit)   OCRnxL Buf. (8-bit)             TCNTnH (8-bit)       TCNTnL (8-bit)
                                             OCRnx Buffer (16-bit Register)                        TCNTn (16-bit Counter)
                                         OCRnxH (8-bit)        OCRnxL (8-bit)
                                                OCRnx (16-bit Register)
                                                                            = (16-bit Comparator)
                                                                                               OCFnx (Int. Req.)
                                                  TOP
                                                                            Waveform Generator                                 OCnx
                                               BOTTOM
                                                                          WGMn3:0       COMnx1:0
        The OCR1x register is double buffered when using any of the twelve pulse width modulation (PWM) modes. For the normal
        and clear timer on compare (CTC) modes of operation, the double buffering is disabled. The double buffering synchronizes
        the update of the OCR1x compare register to either TOP or BOTTOM of the counting sequence. The synchronization
        prevents the occurrence of odd-length, non-symmetrical PWM pulses, thereby making the output glitch-free.
        The OCR1x register access may seem complex, but this is not case. When the double buffering is enabled, the CPU has
        access to the OCR1x buffer register, and if double buffering is disabled the CPU will access the OCR1x directly. The content
        of the OCR1x (buffer or compare) register is only changed by a write operation (the Timer/Counter does not update this
        register automatically as the TCNT1 and ICR1 register). Therefore OCR1x is not read via the high byte temporary register
        (TEMP). However, it is a good practice to read the low byte first as when accessing other 16-bit registers. Writing the OCR1x
        registers must be done via the TEMP register since the compare of all 16 bits is done continuously. The high byte (OCR1xH)
        has to be written first. When the high byte I/O location is written by the CPU, the TEMP register will be updated by the value
        written. Then when the low byte (OCR1xL) is written to the lower eight bits, the high byte will be copied into the upper 8-bits
        of either the OCR1x buffer or OCR1x compare register in the same system clock cycle.
        For more information of how to access the 16-bit registers refer to Section 5.15.3 “Accessing 16-bit Registers” on page 115.
5.15.7.1 Force Output Compare
        In non-PWM waveform generation modes, the match output of the comparator can be forced by writing a one to the force
        output compare (FOC1x) bit. Forcing compare match will not set the OCF1x flag or reload/clear the timer, but the OC1x pin
        will be updated as if a real compare match had occurred (the COM11:0 bits settings define whether the OC1x pin is set,
        cleared or toggled).
5.15.7.2 Compare Match Blocking by TCNT1 Write
        All CPU writes to the TCNT1 register will block any compare match that occurs in the next timer clock cycle, even when the
        timer is stopped. This feature allows OCR1x to be initialized to the same value as TCNT1 without triggering an interrupt
        when the Timer/Counter clock is enabled.
                                                                                                      ATA6614Q [DATASHEET]           121
                                                                                                                    9240I–AUTO–03/16


5.15.7.3 Using the Output Compare Unit
       Since writing TCNT1 in any mode of operation will block all compare matches for one timer clock cycle, there are risks
       involved when changing TCNT1 when using any of the output compare channels, independent of whether the Timer/Counter
       is running or not. If the value written to TCNT1 equals the OCR1x value, the compare match will be missed, resulting in
       incorrect waveform generation. Do not write the TCNT1 equal to TOP in PWM modes with variable TOP values. The
       compare match for the TOP will be ignored and the counter will continue to 0xFFFF. Similarly, do not write the TCNT1 value
       equal to BOTTOM when the counter is downcounting.
       The setup of the OC1x should be performed before setting the data direction register for the port pin to output. The easiest
       way of setting the OC1x value is to use the force output compare (FOC1x) strobe bits in normal mode. The OC1x register
       keeps its value even when changing between waveform generation modes.
       Be aware that the COM1x1:0 bits are not double buffered together with the compare value. Changing the COM1x1:0 bits will
       take effect immediately.
5.15.8 Compare Match Output Unit
       The compare output mode (COM1x1:0) bits have two functions. The waveform generator uses the COM1x1:0 bits for
       defining the output compare (OC1x) state at the next compare match. Secondly the COM1x1:0 bits control the OC1x pin
       output source. Figure 5-42 shows a simplified schematic of the logic affected by the COM1x1:0 bit setting. The I/O registers,
       I/O bits, and I/O pins in the figure are shown in bold. Only the parts of the general I/O port control registers (DDR and PORT)
       that are affected by the COM1x1:0 bits are shown. When referring to the OC1x state, the reference is for the internal OC1x
       register, not the OC1x pin. If a system reset occur, the OC1x register is reset to “0”.
       Figure 5-42. Compare Match Output Unit, Schematic
                               COMnx1
                               COMnx0            Waveform
                                                 Generator           D          Q
                               FOCnx
                                                                                       1
                                                                                                          OCnx
                                                                         OCnx                              Pin
                                                                                       0
                                                                     D          Q
                                                        DATA BUS
                                                                      PORT
                                                                     D          Q
                                                                         DDR
                             clkI/O
       The general I/O port function is overridden by the output compare (OC1x) from the waveform generator if either of the
       COM1x1:0 bits are set. However, the OC1x pin direction (input or output) is still controlled by the data direction register
       (DDR) for the port pin. The data direction register bit for the OC1x pin (DDR_OC1x) must be set as output before the OC1x
       value is visible on the pin. The port override function is generally independent of the waveform generation mode, but there
       are some exceptions. Refer to Table 5-50, Table 5-51 and Table 5-52 for details.
       The design of the output compare pin logic allows initialization of the OC1x state before the output is enabled. Note that
       some COM1x1:0 bit settings are reserved for certain modes of operation. See Section 5.15.11 “Register Description” on
       page 131.
       The COM1x1:0 bits have no effect on the input capture unit.
122    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.15.8.1 Compare Output Mode and Waveform Generation
        The waveform generator uses the COM1x1:0 bits differently in normal, CTC, and PWM modes. For all modes, setting the
        COM1x1:0 = 0 tells the waveform generator that no action on the OC1x register is to be performed on the next compare
        match. For compare output actions in the non-PWM modes refer to Table 5-50 on page 131. For fast PWM mode refer to
        Table 5-51 on page 131, and for phase correct and phase and frequency correct PWM refer to Table 5-52 on page 132.
        A change of the COM1x1:0 bits state will have effect at the first compare match after the bits are written. For non-PWM
        modes, the action can be forced to have immediate effect by using the FOC1x strobe bits.
5.15.9 Modes of Operation
        The mode of operation, i.e., the behavior of the Timer/Counter and the output compare pins, is defined by the combination of
        the waveform generation mode (WGM13:0) and compare output mode (COM1x1:0) bits. The compare output mode bits do
        not affect the counting sequence, while the waveform generation mode bits do. The COM1x1:0 bits control whether the
        PWM output generated should be inverted or not (inverted or non-inverted PWM). For non-PWM modes the COM1x1:0 bits
        control whether the output should be set, cleared or toggle at a compare match (see Section 5.15.8 “Compare Match Output
        Unit” on page 122).
        For detailed timing information refer to Section 5.15.10 “Timer/Counter Timing Diagrams” on page 129.
5.15.9.1 Normal Mode
        The simplest mode of operation is the normal mode (WGM13:0 = 0). In this mode the counting direction is always up
        (incrementing), and no counter clear is performed. The counter simply OverRuns when it passes its maximum 16-bit value
        (MAX = 0xFFFF) and then restarts from the BOTTOM (0x0000). In normal operation the Timer/Counter overflow flag (TOV1)
        will be set in the same timer clock cycle as the TCNT1 becomes zero. The TOV1 flag in this case behaves like a 17th bit,
        except that it is only set, not cleared. However, combined with the timer overflow interrupt that automatically clears the TOV1
        flag, the timer resolution can be increased by software. There are no special cases to consider in the normal mode, a new
        counter value can be written anytime.
        The input capture unit is easy to use in normal mode. However, observe that the maximum interval between the external
        events must not exceed the resolution of the counter. If the interval between events are too long, the timer overflow interrupt
        or the prescaler must be used to extend the resolution for the capture unit.
        The output compare units can be used to generate interrupts at some given time. Using the output compare to generate
        waveforms in normal mode is not recommended, since this will occupy too much of the CPU time.
5.15.9.2 Clear Timer on Compare Match (CTC) Mode
        In clear timer on compare or CTC mode (WGM13:0 = 4 or 12), the OCR1A or ICR1 register are used to manipulate the
        counter resolution. In CTC mode the counter is cleared to zero when the counter value (TCNT1) matches either the OCR1A
        (WGM13:0 = 4) or the ICR1 (WGM13:0 = 12). The OCR1A or ICR1 define the top value for the counter, hence also its
        resolution. This mode allows greater control of the compare match output frequency. It also simplifies the operation of
        counting external events.
        The timing diagram for the CTC mode is shown in Figure 5-43. The counter value (TCNT1) increases until a compare match
        occurs with either OCR1A or ICR1, and then counter (TCNT1) is cleared.
        Figure 5-43. CTC Mode, Timing Diagram
                                                                                                           OCnA Interrupt Flag Set
                                                                                                          or ICFn Interrupt Flag Set
                                                                                                              (Interrupt on TOP)
                   TCNTn
                    OCnA                                                                                 (COMnA1:0 = 1)
                 (Toggle)
                                       1                2         3           4
                    Period
                                                                                                ATA6614Q [DATASHEET]                 123
                                                                                                                 9240I–AUTO–03/16


        An interrupt can be generated at each time the counter value reaches the TOP value by either using the OCF1A or ICF1 flag
        according to the register used to define the TOP value. If the interrupt is enabled, the interrupt handler routine can be used
        for updating the TOP value. However, changing the TOP to a value close to BOTTOM when the counter is running with none
        or a low prescaler value must be done with care since the CTC mode does not have the double buffering feature. If the new
        value written to OCR1A or ICR1 is lower than the current value of TCNT1, the counter will miss the compare match. The
        counter will then have to count to its maximum value (0xFFFF) and wrap around starting at 0x0000 before the compare
        match can occur. In many cases this feature is not desirable. An alternative will then be to use the fast PWM mode using
        OCR1A for defining TOP (WGM13:0 = 15) since the OCR1A then will be double buffered.
        For generating a waveform output in CTC mode, the OC1A output can be set to toggle its logical level on each compare
        match by setting the compare output mode bits to toggle mode (COM1A1:0 = 1). The OC1A value will not be visible on the
        port pin unless the data direction for the pin is set to output (DDR_OC1A = 1). The waveform generated will have a
        maximum frequency of fOC1A = fclk_I/O/2 when OCR1A is set to zero (0x0000). The waveform frequency is defined by the
        following equation:
                                  f clk_I/O
        f OCnA = --------------------------------------------------
                    2  N   1 + OCRnA 
        The N variable represents the prescaler factor (1, 8, 64, 256, or 1024).
        As for the normal mode of operation, the TOV1 flag is set in the same timer clock cycle that the counter counts from MAX to
        0x0000.
5.15.9.3 Fast PWM Mode
        The fast pulse width modulation or fast PWM mode (WGM13:0 = 5, 6, 7, 14, or 15) provides a high frequency PWM
        waveform generation option. The fast PWM differs from the other PWM options by its single-slope operation. The counter
        counts from BOTTOM to TOP then restarts from BOTTOM. In non-inverting compare output mode, the output compare
        (OC1x) is cleared on the compare match between TCNT1 and OCR1x, and set at BOTTOM. In inverting compare output
        mode output is set on compare match and cleared at BOTTOM. Due to the single-slope operation, the operating frequency
        of the fast PWM mode can be twice as high as the phase correct and phase and frequency correct PWM modes that use
        dual-slope operation. This high frequency makes the fast PWM mode well suited for power regulation, rectification, and DAC
        applications. High frequency allows physically small sized external components (coils, capacitors), hence reduces total
        system cost.
        The PWM resolution for fast PWM can be fixed to 8-, 9-, or 10-bit, or defined by either ICR1 or OCR1A. The minimum
        resolution allowed is 2-bit (ICR1 or OCR1A set to 0x0003), and the maximum resolution is 16-bit (ICR1 or OCR1A set to
        MAX). The PWM resolution in bits can be calculated by using the following equation:
                      log  TOP + 1 
        R FPWM = ----------------------------------
                              log  2 
        In fast PWM mode the counter is incremented until the counter value matches either one of the fixed values 0x00FF,
        0x01FF, or 0x03FF (WGM13:0 = 5, 6, or 7), the value in ICR1 (WGM13:0 = 14), or the value in OCR1A (WGM13:0 = 15).
        The counter is then cleared at the following timer clock cycle. The timing diagram for the fast PWM mode is shown in Figure
        5-44. The figure shows fast PWM mode when OCR1A or ICR1 is used to define TOP. The TCNT1 value is in the timing
        diagram shown as a histogram for illustrating the single-slope operation. The diagram includes non-inverted and inverted
        PWM outputs. The small horizontal line marks on the TCNT1 slopes represent compare matches between OCR1x and
        TCNT1. The OC1x interrupt flag will be set when a compare match occurs.
124     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


Figure 5-44. Fast PWM Mode, Timing Diagram
                                                                                                 OCRnx/TOP Update and
                                                                                                TOVn Interrupt Flag Set and
                                                                                                  OCnA Interrupt Flag Set
                                                                                                 or ICFn Interrupt Flag Set
                                                                                                     (Interrupt on TOP)
         TCNTn
           OCnx                                                                                (COMnx1:0 = 2)
           OCnx                                                                                (COMnx1:0 = 3)
                            1                   2 3   4    5   6       7            8
          Period
The Timer/Counter overflow flag (TOV1) is set each time the counter reaches TOP. In addition the OC1A or ICF1 Flag is set
at the same timer clock cycle as TOV1 is set when either OCR1A or ICR1 is used for defining the TOP value. If one of the
interrupts are enabled, the interrupt handler routine can be used for updating the TOP and compare values.
When changing the TOP value the program must ensure that the new TOP value is higher or equal to the value of all of the
compare registers. If the TOP value is lower than any of the compare registers, a compare match will never occur between
the TCNT1 and the OCR1x. Note that when using fixed TOP values the unused bits are masked to zero when any of the
OCR1x registers are written.
The procedure for updating ICR1 differs from updating OCR1A when used for defining the TOP value. The ICR1 register is
not double buffered. This means that if ICR1 is changed to a low value when the counter is running with none or a low
prescaler value, there is a risk that the new ICR1 value written is lower than the current value of TCNT1. The result will then
be that the counter will miss the compare match at the TOP value. The counter will then have to count to the MAX value
(0xFFFF) and wrap around starting at 0x0000 before the compare match can occur. The OCR1A register however, is double
buffered. This feature allows the OCR1A I/O location to be written anytime. When the OCR1A I/O location is written the
value written will be put into the OCR1A buffer register. The OCR1A compare register will then be updated with the value in
the buffer register at the next timer clock cycle the TCNT1 matches TOP. The update is done at the same timer clock cycle
as the TCNT1 is cleared and the TOV1 flag is set.
Using the ICR1 register for defining TOP works well when using fixed TOP values. By using ICR1, the OCR1A register is
free to be used for generating a PWM output on OC1A. However, if the base PWM frequency is actively changed (by
changing the TOP value), using the OCR1A as TOP is clearly a better choice due to its double buffer feature.
In fast PWM mode, the compare units allow generation of PWM waveforms on the OC1x pins. Setting the COM1x1:0 bits to
two will produce a inverted PWM and an non-inverted PWM output can be generated by setting the COM1x1:0 to three (see
Table on page 131). The actual OC1x value will only be visible on the port pin if the data direction for the port pin is set as
output (DDR_OC1x). The PWM waveform is generated by setting (or clearing) the OC1x register at the compare match
between OCR1x and TCNT1, and clearing (or setting) the OC1x register at the timer clock cycle the counter is cleared
(changes from TOP to BOTTOM).
The PWM frequency for the output can be calculated by the following equation:
                      f clk_I/O
 f OCnxPWM = ----------------------------------
                 N   1 + TOP 
The N variable represents the prescaler divider (1, 8, 64, 256, or 1024).
The extreme values for the OCR1x register represents special cases when generating a PWM waveform output in the fast
PWM mode. If the OCR1x is set equal to BOTTOM (0x0000) the output will be a narrow spike for each TOP+1 timer clock
cycle. Setting the OCR1x equal to TOP will result in a constant high or low output (depending on the polarity of the output set
by the COM1x1:0 bits.
                                                                                        ATA6614Q [DATASHEET]                 125
                                                                                                        9240I–AUTO–03/16


        A frequency (with 50% duty cycle) waveform output in fast PWM mode can be achieved by setting OC1A to toggle its logical
        level on each compare match (COM1A1:0 = 1). This applies only if OCR1A is used to define the TOP value (WGM13:0 =
        15). The waveform generated will have a maximum frequency of fOC1A = fclk_I/O/2 when OCR1A is set to zero (0x0000). This
        feature is similar to the OC1A toggle in CTC mode, except the double buffer feature of the output compare unit is enabled in
        the fast PWM mode.
5.15.9.4 Phase Correct PWM Mode
        The phase correct pulse width modulation or phase correct PWM mode (WGM13:0 = 1, 2, 3, 10, or 11) provides a high
        resolution phase correct PWM waveform generation option. The phase correct PWM mode is, like the phase and frequency
        correct PWM mode, based on a dual-slope operation. The counter counts repeatedly from BOTTOM (0x0000) to TOP and
        then from TOP to BOTTOM. In non-inverting compare output mode, the output compare (OC1x) is cleared on the compare
        match between TCNT1 and OCR1x while upcounting, and set on the compare match while downcounting. In inverting output
        compare mode, the operation is inverted. The dual-slope operation has lower maximum operation frequency than single
        slope operation. However, due to the symmetric feature of the dual-slope PWM modes, these modes are preferred for motor
        control applications.
        The PWM resolution for the phase correct PWM mode can be fixed to 8-, 9-, or 10-bit, or defined by either ICR1 or OCR1A.
        The minimum resolution allowed is 2-bit (ICR1 or OCR1A set to 0x0003), and the maximum resolution is 16-bit (ICR1 or
        OCR1A set to MAX). The PWM resolution in bits can be calculated by using the following equation:
                        log  TOP + 1 
         R PCPWM = ----------------------------------
                            log  2 
        In phase correct PWM mode the counter is incremented until the counter value matches either one of the fixed values
        0x00FF, 0x01FF, or 0x03FF (WGM13:0 = 1, 2, or 3), the value in ICR1 (WGM13:0 = 10), or the value in OCR1A (WGM13:0
        = 11). The counter has then reached the TOP and changes the count direction. The TCNT1 value will be equal to TOP for
        one timer clock cycle. The timing diagram for the phase correct PWM mode is shown on Figure 5-45. The figure shows
        phase correct PWM mode when OCR1A or ICR1 is used to define TOP. The TCNT1 value is in the timing diagram shown as
        a histogram for illustrating the dual-slope operation. The diagram includes non-inverted and inverted PWM outputs. The
        small horizontal line marks on the TCNT1 slopes represent compare matches between OCR1x and TCNT1. The OC1x
        interrupt flag will be set when a compare match occurs.
        Figure 5-45. Phase Correct PWM Mode, Timing Diagram
                                                                                                       OCRnx/TOP Update and
                                                                                                        OCnA Interrupt Flag Set
                                                                                                       or ICFn Interrupt Flag Set
                                                                                                            (Interrupt on TOP)
                                                                                                        TOVn Interrupt Flag Set
                                                                                                          (Interrupt on Bottom)
                 TCNTn
                   OCnx                                                                                             (COMnx1:0 = 2)
                   OCnx                                                                                             (COMnx1:0 = 3)
                                                      1        2             3                   4
                  Period
        The Timer/Counter overflow flag (TOV1) is set each time the counter reaches BOTTOM. When either OCR1A or ICR1 is
        used for defining the TOP value, the OC1A or ICF1 flag is set accordingly at the same timer clock cycle as the OCR1x
        registers are updated with the double buffer value (at TOP). The interrupt flags can be used to generate an interrupt each
        time the counter reaches the TOP or BOTTOM value.
126     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        When changing the TOP value the program must ensure that the new TOP value is higher or equal to the value of all of the
        compare registers. If the TOP value is lower than any of the compare registers, a compare match will never occur between
        the TCNT1 and the OCR1x. Note that when using fixed TOP values, the unused bits are masked to zero when any of the
        OCR1x registers are written. As the third period shown in Figure 5-45 illustrates, changing the TOP actively while the
        Timer/Counter is running in the phase correct mode can result in an unsymmetrical output. The reason for this can be found
        in the time of update of the OCR1x register. Since the OCR1x update occurs at TOP, the PWM period starts and ends at
        TOP. This implies that the length of the falling slope is determined by the previous TOP value, while the length of the rising
        slope is determined by the new TOP value. When these two values differ the two slopes of the period will differ in length. The
        difference in length gives the unsymmetrical result on the output.
        It is recommended to use the phase and frequency correct mode instead of the phase correct mode when changing the TOP
        value while the Timer/Counter is running. When using a static TOP value there are practically no differences between the
        two modes of operation.
        In phase correct PWM mode, the compare units allow generation of PWM waveforms on the OC1x pins. Setting the
        COM1x1:0 bits to two will produce a non-inverted PWM and an inverted PWM output can be generated by setting the
        COM1x1:0 to three (See Table on page 132). The actual OC1x value will only be visible on the port pin if the data direction
        for the port pin is set as output (DDR_OC1x). The PWM waveform is generated by setting (or clearing) the OC1x register at
        the compare match between OCR1x and TCNT1 when the counter increments, and clearing (or setting) the OC1x register at
        compare match between OCR1x and TCNT1 when the counter decrements. The PWM frequency for the output when using
        phase correct PWM can be calculated by the following equation:
                                 f clk_I/O
         f OCnxPCPWM = ----------------------------
                             2  N  TOP
        The N variable represents the prescaler divider (1, 8, 64, 256, or 1024).
        The extreme values for the OCR1x register represent special cases when generating a PWM waveform output in the phase
        correct PWM mode. If the OCR1x is set equal to BOTTOM the output will be continuously low and if set equal to TOP the
        output will be continuously high for non-inverted PWM mode. For inverted PWM the output will have the opposite logic
        values. If OCR1A is used to define the TOP value (WGM13:0 = 11) and COM1A1:0 = 1, the OC1A output will toggle with a
        50% duty cycle.
5.15.9.5 Phase and Frequency Correct PWM Mode
        The phase and frequency correct pulse width modulation, or phase and frequency correct PWM mode (WGM13:0 = 8 or 9)
        provides a high resolution phase and frequency correct PWM waveform generation option. The phase and frequency correct
        PWM mode is, like the phase correct PWM mode, based on a dual-slope operation. The counter counts repeatedly from
        BOTTOM (0x0000) to TOP and then from TOP to BOTTOM. In non-inverting compare output mode, the output compare
        (OC1x) is cleared on the compare match between TCNT1 and OCR1x while upcounting, and set on the compare match
        while downcounting. In inverting compare output mode, the operation is inverted. The dual-slope operation gives a lower
        maximum operation frequency compared to the single-slope operation. However, due to the symmetric feature of the dual-
        slope PWM modes, these modes are preferred for motor control applications.
        The main difference between the phase correct, and the phase and frequency correct PWM mode is the time the OCR1x
        register is updated by the OCR1x buffer register, (see Figure 5-45 and Figure 5-46).
        The PWM resolution for the phase and frequency correct PWM mode can be defined by either ICR1 or OCR1A. The
        minimum resolution allowed is 2-bit (ICR1 or OCR1A set to 0x0003), and the maximum resolution is 16-bit (ICR1 or OCR1A
        set to MAX). The PWM resolution in bits can be calculated using the following equation:
                         log  TOP + 1 
         R PFCPWM = ----------------------------------
                              log  2 
        In phase and frequency correct PWM mode the counter is incremented until the counter value matches either the value in
        ICR1 (WGM13:0 = 8), or the value in OCR1A (WGM13:0 = 9). The counter has then reached the TOP and changes the
        count direction. The TCNT1 value will be equal to TOP for one timer clock cycle. The timing diagram for the phase correct
        and frequency correct PWM mode is shown on Figure 5-46. The figure shows phase and frequency correct PWM mode
        when OCR1A or ICR1 is used to define TOP. The TCNT1 value is in the timing diagram shown as a histogram for illustrating
        the dual-slope operation. The diagram includes non-inverted and inverted PWM outputs. The small horizontal line marks on
        the TCNT1 slopes represent compare matches between OCR1x and TCNT1. The OC1x Interrupt Flag will be set when a
        compare match occurs.
                                                                                              ATA6614Q [DATASHEET]                 127
                                                                                                            9240I–AUTO–03/16


    Figure 5-46. Phase and Frequency Correct PWM Mode, Timing Diagram
                                                                                                   OCnA Interrupt Flag Set
                                                                                                  or ICFn Interrupt Flag Set
                                                                                                       (Interrupt on TOP)
                                                                                                  OCRnx/ TOP Update and
                                                                                                   TOVn Interrupt Flag Set
                                                                                                     (Interrupt on Bottom)
             TCNTn
               OCnx                                                                         (COMnx1:0 = 2)
               OCnx                                                                         (COMnx1:0 = 3)
                                    1               2           3              4
              Period
    The Timer/Counter overflow flag (TOV1) is set at the same timer clock cycle as the OCR1x registers are updated with the
    double buffer value (at BOTTOM). When either OCR1A or ICR1 is used for defining the TOP value, the OC1A or ICF1 flag
    set when TCNT1 has reached TOP. The interrupt flags can then be used to generate an interrupt each time the counter
    reaches the TOP or BOTTOM value.
    When changing the TOP value the program must ensure that the new TOP value is higher or equal to the value of all of the
    compare registers. If the TOP value is lower than any of the compare registers, a compare match will never occur between
    the TCNT1 and the OCR1x.
    As Figure 5-46 shows the output generated is, in contrast to the phase correct mode, symmetrical in all periods. Since the
    OCR1x registers are updated at BOTTOM, the length of the rising and the falling slopes will always be equal. This gives
    symmetrical output pulses and is therefore frequency correct.
    Using the ICR1 register for defining TOP works well when using fixed TOP values. By using ICR1, the OCR1A register is
    free to be used for generating a PWM output on OC1A. However, if the base PWM frequency is actively changed by
    changing the TOP value, using the OCR1A as TOP is clearly a better choice due to its double buffer feature.
    In phase and frequency correct PWM mode, the compare units allow generation of PWM waveforms on the OC1x pins.
    Setting the COM1x1:0 bits to two will produce a non-inverted PWM and an inverted PWM output can be generated by setting
    the COM1x1:0 to three (see Table on page 132). The actual OC1x value will only be visible on the port pin if the data
    direction for the port pin is set as output (DDR_OC1x). The PWM waveform is generated by setting (or clearing) the OC1x
    register at the compare match between OCR1x and TCNT1 when the counter increments, and clearing (or setting) the OC1x
    register at compare match between OCR1x and TCNT1 when the counter decrements. The PWM frequency for the output
    when using phase and frequency correct PWM can be calculated by the following equation:
                            f clk_I/O
    f OCnxPFCPWM = ----------------------------
                         2  N  TOP
    The N variable represents the prescaler divider (1, 8, 64, 256, or 1024).
    The extreme values for the OCR1x register represents special cases when generating a PWM waveform output in the phase
    correct PWM mode. If the OCR1x is set equal to BOTTOM the output will be continuously low and if set equal to TOP the
    output will be set to high for non-inverted PWM mode. For inverted PWM the output will have the opposite logic values. If
    OCR1A is used to define the TOP value (WGM13:0 = 9) and COM1A1:0 = 1, the OC1A output will toggle with a 50% duty
    cycle.
128 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.15.10    Timer/Counter Timing Diagrams
        The Timer/Counter is a synchronous design and the timer clock (clkT1) is therefore shown as a clock enable signal in the
        following figures. The figures include information on when Interrupt flags are set, and when the OCR1x register is updated
        with the OCR1x buffer value (only for modes utilizing double buffering). Figure 5-47 shows a timing diagram for the setting of
        OCF1x.
        Figure 5-47. Timer/Counter Timing Diagram, Setting of OCF1x, no Prescaling
                             clkI/O
                             clkTn
                         (clkI/O/1)
                          TCNTn             OCRnx - 1            OCRnx               OCRnx + 1          OCRnx + 2
                          OCRnx                                          OCRnx Value
                          OCFnx
        Figure 5-48 shows the same timing data, but with the prescaler enabled.
        Figure 5-48. Timer/Counter Timing Diagram, Setting of OCF1x, with Prescaler (fclk_I/O/8)
                             clkI/O
                             clkTn
                         (clkI/O/8)
                          TCNTn             OCRnx - 1            OCRnx               OCRnx + 1          OCRnx + 2
                          OCRnx                                          OCRnx Value
                          OCFnx
                                                                                               ATA6614Q [DATASHEET]               129
                                                                                                            9240I–AUTO–03/16


    Figure 5-49 shows the count sequence close to TOP in various modes. When using phase and frequency correct PWM
    mode the OCR1x register is updated at BOTTOM. The timing diagrams will be the same, but TOP should be replaced by
    BOTTOM, TOP-1 by BOTTOM+1 and so on. The same renaming applies for modes that set the TOV1 Flag at BOTTOM.
    Figure 5-49. Timer/Counter Timing Diagram, no Prescaling
                               clkI/O
                                clkTn
                          (clkI/O/1)
                        TCNTn
                 (CTC and FPWM)           TOP - 1                TOP           BOTTOM            BOTTOM + 1
                       TCNTn
               (PC and PFC PWM)           TOP - 1                TOP            TOP - 1             TOP - 2
                    TOVn (FPWM)
                        and ICFn
                   (if used as TOP)
                         OCRnx                  Old OCRnx Value                       New OCRnx Value
                   (Update at TOP)
    Figure 5-50 shows the same timing data, but with the prescaler enabled.
    Figure 5-50. Timer/Counter Timing Diagram, with Prescaler (fclk_I/O/8)
                               clkI/O
                                clkTn
                          (clkI/O/8)
                        TCNTn
                 (CTC and FPWM)           TOP - 1                TOP           BOTTOM            BOTTOM + 1
                       TCNTn
               (PC and PFC PWM)           TOP - 1                TOP            TOP - 1             TOP - 2
                    TOVn (FPWM)
                        and ICFn
                   (if used as TOP)
                         OCRnx                  Old OCRnx Value                       New OCRnx Value
                   (Update at TOP)
130 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.15.11 Register Description
5.15.11.1 TCCR1A – Timer/Counter1 Control Register A
                Bit          7          6          5          4           3         2         1         0
              (0x80)      COM1A1    COM1A0     COM1B1    COM1B0           –         –      WGM11     WGM10    TCCR1A
          Read/Write        R/W        R/W       R/W        R/W           R         R        R/W       R/W
          Initial Value      0          0          0          0           0         0         0         0
        • Bit 7:6 – COM1A1:0: Compare Output Mode for Channel A
        • Bit 5:4 – COM1B1:0: Compare Output Mode for Channel B
        The COM1A1:0 and COM1B1:0 control the output compare pins (OC1A and OC1B respectively) behavior. If one or both of
        the COM1A1:0 bits are written to one, the OC1A output overrides the normal port functionality of the I/O pin it is connected
        to. If one or both of the COM1B1:0 bit are written to one, the OC1B output overrides the normal port functionality of the I/O
        pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC1A or OC1B pin
        must be set in order to enable the output driver.
        When the OC1A or OC1B is connected to the pin, the function of the COM1x1:0 bits is dependent of the WGM13:0 bits
        setting. Table 5-50 shows the COM1x1:0 bit functionality when the WGM13:0 bits are set to a Normal or a CTC mode (non-
        PWM).
        Table 5-50. Compare Output Mode, non-PWM
              COM1A1/COM1B1                COM1A0/COM1B0             Description
                        0                            0               Normal port operation, OC1A/OC1B disconnected.
                        0                            1               Toggle OC1A/OC1B on compare match.
                        1                            0               Clear OC1A/OC1B on compare match (set output to low level).
                        1                            1               Set OC1A/OC1B on compare match (set output to high level).
        Table 5-51 shows the COM1x1:0 bit functionality when the WGM13:0 bits are set to the fast PWM mode.
        Table 5-51. Compare Output Mode, Fast PWM(1)
              COM1A1/COM1B1                COM1A0/COM1B0              Description
                        0                            0                Normal port operation, OC1A/OC1B disconnected.
                                                                      WGM13:0 = 14 or 15: Toggle OC1A on compare match, OC1B
                        0                            1                disconnected (normal port operation). For all other WGM1
                                                                      settings, normal port operation, OC1A/OC1B disconnected.
                                                                      Clear OC1A/OC1B on compare match, set OC1A/OC1B at
                        1                            0
                                                                      BOTTOM (non-inverting mode)
                                                                      Set OC1A/OC1B on compare match, clear OC1A/OC1B at
                        1                            1
                                                                      BOTTOM (inverting mode)
        Note:       1.  A special case occurs when OCR1A/OCR1B equals TOP and COM1A1/COM1B1 is set. In this case the com-
                        pare match is ignored, but the set or clear is done at BOTTOM. See Section 5.15.9.3 “Fast PWM Mode” on
                        page 124 for more details.
                                                                                                  ATA6614Q [DATASHEET]            131
                                                                                                               9240I–AUTO–03/16


        Table 5-52 shows the COM1x1:0 bit functionality when the WGM13:0 bits are set to the phase correct or the phase and
        frequency correct, PWM mode.
        Table 5-52. Compare Output Mode, Phase Correct and Phase and Frequency Correct PWM(1)
             COM1A1/COM1B1                COM1A0/COM1B0            Description
                      0                           0                Normal port operation, OC1A/OC1B disconnected.
                                                                   WGM13:0 = 9 or 11: Toggle OC1A on compare match, OC1B
                      0                           1                disconnected (normal port operation). For all other WGM1
                                                                   settings, normal port operation, OC1A/OC1B disconnected.
                                                                   Clear OC1A/OC1B on compare match when up-counting. Set
                      1                           0
                                                                   OC1A/OC1B on compare match when downcounting.
                                                                   Set OC1A/OC1B on compare match when up-counting. Clear
                      1                           1
                                                                   OC1A/OC1B on compare match when downcounting.
        Note:    1.   A special case occurs when OCR1A/OCR1B equals TOP and COM1A1/COM1B1 is set. See Section 5.15.9.4
                      “Phase Correct PWM Mode” on page 126 for more details.
        • Bit 1:0 – WGM11:0: Waveform Generation Mode
        Combined with the WGM13:2 bits found in the TCCR1B register, these bits control the counting sequence of the counter, the
        source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 5-53. Modes of
        operation supported by the Timer/Counter unit are: Normal mode (counter), clear timer on compare match (CTC) mode, and
        three types of pulse width modulation (PWM) modes (see Section 5.15.9 “Modes of Operation” on page 123).
Table 5-53. Waveform Generation Mode Bit Description(1)
                       WGM12        WGM11       WGM10        Timer/Counter Mode of                        Update of     TOV1 Flag
 Mode     WGM13         (CTC1)     (PWM11)     (PWM10)       Operation                       TOP          OCR1x at      Set on
    0         0            0            0           0        Normal                          0xFFFF       Immediate     MAX
    1         0            0            0           1        PWM, phase correct, 8-bit       0x00FF       TOP           BOTTOM
    2         0            0            1           0        PWM, phase correct, 9-bit       0x01FF       TOP           BOTTOM
    3         0            0            1           1        PWM, phase correct, 10-bit      0x03FF       TOP           BOTTOM
    4         0            1            0           0        CTC                             OCR1A        Immediate     MAX
    5         0            1            0           1        Fast PWM, 8-bit                 0x00FF       BOTTOM        TOP
    6         0            1            1           0        Fast PWM, 9-bit                 0x01FF       BOTTOM        TOP
    7         0            1            1           1        Fast PWM, 10-bit                0x03FF       BOTTOM        TOP
                                                             PWM, phase and frequency
    8         1            0            0           0                                        ICR1         BOTTOM        BOTTOM
                                                             correct
                                                             PWM, phase and frequency
    9         1            0            0           1                                        OCR1A        BOTTOM        BOTTOM
                                                             correct
   10         1            0            1           0        PWM, phase correct              ICR1         TOP           BOTTOM
   11         1            0            1           1        PWM, phase correct              OCR1A        TOP           BOTTOM
   12         1            1            0           0        CTC                             ICR1         Immediate     MAX
   13         1            1            0           1        (Reserved)                      –            –             –
   14         1            1            1           0        Fast PWM                        ICR1         BOTTOM        TOP
   15         1            1            1           1        Fast PWM                        OCR1A        BOTTOM        TOP
Note:   1. The CTC1 and PWM11:0 bit definition names are obsolete. Use the WGM12:0 definitions. However, the functionality
            and location of these bits are compatible with previous versions of the timer.
132     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.15.11.2 TCCR1B – Timer/Counter1 Control Register B
                 Bit          7         6          5           4         3         2        1          0
              (0x81)        ICNC1     ICES1        –        WGM13     WGM12       CS12     CS11       CS10    TCCR1B
           Read/Write        R/W       R/W         R          R/W       R/W       R/W      R/W        R/W
           Initial Value      0         0          0           0         0         0        0          0
        • Bit 7 – ICNC1: Input Capture Noise Canceler
        Setting this bit (to one) activates the input capture noise canceler. When the noise canceler is activated, the input from the
        input capture pin (ICP1) is filtered. The filter function requires four successive equal valued samples of the ICP1 pin for
        changing its output. The input capture is therefore delayed by four oscillator cycles when the noise canceler is enabled.
        • Bit 6 – ICES1: Input Capture Edge Select
        This bit selects which edge on the input capture pin (ICP1) that is used to trigger a capture event. When the ICES1 bit is
        written to zero, a falling (negative) edge is used as trigger, and when the ICES1 bit is written to one, a rising (positive) edge
        will trigger the capture.
        When a capture is triggered according to the ICES1 setting, the counter value is copied into the input capture register
        (ICR1). The event will also set the input capture flag (ICF1), and this can be used to cause an input capture interrupt, if this
        interrupt is enabled.
        When the ICR1 is used as TOP value (see description of the WGM13:0 bits located in the TCCR1A and the TCCR1B
        register), the ICP1 is disconnected and consequently the Input capture function is disabled.
        • Bit 5 – Reserved Bit
        This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero when
        TCCR1B is written.
        • Bit 4:3 – WGM13:2: Waveform Generation Mode
        See TCCR1A register description.
        • Bit 2:0 – CS12:0: Clock Select
        The three clock select bits select the clock source to be used by the Timer/Counter, see Figure 5-47 and Figure 5-48.
        Table 5-54. Clock Select Bit Description
             CS12            CS11         CS10        Description
                 0             0             0        No clock source (Timer/Counter stopped).
                 0             0             1        clkI/O/1 (no prescaling)
                 0             1             0        clkI/O/8 (from prescaler)
                 0             1             1        clkI/O/64 (from prescaler)
                 1             0             0        clkI/O/256 (from prescaler)
                 1             0             1        clkI/O/1024 (from prescaler)
                 1             1             0        External clock source on T1 pin. Clock on falling edge.
                 1             1             1        External clock source on T1 pin. Clock on rising edge.
        If external pin modes are used for the Timer/Counter1, transitions on the T1 pin will clock the counter even if the pin is
        configured as an output. This feature allows software control of the counting.
                                                                                                 ATA6614Q [DATASHEET]                 133
                                                                                                               9240I–AUTO–03/16


5.15.11.3 TCCR1C – Timer/Counter1 Control Register C
                 Bit        7         6          5         4           3        2         1         0
              (0x82)     FOC1A      FOC1B        –         –           –        –         –         –      TCCR1C
           Read/Write      R/W       R/W         R         R          R         R         R         R
           Initial Value    0         0          0         0           0        0         0         0
        • Bit 7 – FOC1A: Force Output Compare for Channel A
        • Bit 6 – FOC1B: Force Output Compare for Channel B
        The FOC1A/FOC1B bits are only active when the WGM13:0 bits specifies a non-PWM mode. When writing a logical one to
        the FOC1A/FOC1B bit, an immediate compare match is forced on the waveform generation unit. The OC1A/OC1B output is
        changed according to its COM1x1:0 bits setting. Note that the FOC1A/FOC1B bits are implemented as strobes. Therefore it
        is the value present in the COM1x1:0 bits that determine the effect of the forced compare.
        A FOC1A/FOC1B strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC)
        mode using OCR1A as TOP. The FOC1A/FOC1B bits are always read as zero.
5.15.11.4 TCNT1H and TCNT1L – Timer/Counter1
                 Bit         7        6          5         4          3         2         1         0
              (0x85)                                       TCNT1[15:8]                                     TCNT1H
              (0x84)                                       TCNT1[7:0]                                      TCNT1L
           Read/Write      R/W       R/W       R/W       R/W         R/W      R/W        R/W      R/W
           Initial Value     0        0          0         0          0         0         0         0
        The two Timer/Counter I/O locations (TCNT1H and TCNT1L, combined TCNT1) give direct access, both for read and for
        write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written
        simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary high byte register
        (TEMP). This temporary register is shared by all the other 16-bit registers (see Section 5.15.3 “Accessing 16-bit Registers”
        on page 115).
        Modifying the counter (TCNT1) while the counter is running introduces a risk of missing a compare match between TCNT1
        and one of the OCR1x registers.
        Writing to the TCNT1 register blocks (removes) the compare match on the following timer clock for all compare units.
5.15.11.5 OCR1AH and OCR1AL – Output Compare Register 1 A
                 Bit         7        6          5         4           3        2         1         0
              (0x89)                                       OCR1A[15:8]                                     OCR1AH
              (0x88)                                       OCR1A[7:0]                                      OCR1AL
           Read/Write      R/W       R/W       R/W       R/W         R/W      R/W        R/W      R/W
           Initial Value     0        0          0         0           0        0         0         0
5.15.11.6 OCR1BH and OCR1BL – Output Compare Register 1 B
                 Bit         7        6          5         4           3        2         1         0
              (0x8B)                                       OCR1B[15:8]                                     OCR1BH
              (0x8A)                                       OCR1B[7:0]                                      OCR1BL
           Read/Write      R/W       R/W       R/W       R/W         R/W      R/W        R/W      R/W
           Initial Value     0        0          0         0           0        0         0         0
        The Output compare registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match
        can be used to generate an output compare interrupt, or to generate a waveform output on the OC1x pin.
        The output compare registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when
        the CPU writes to these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This
        temporary register is shared by all the other 16-bit registers (see Section 5.15.3 “Accessing 16-bit Registers” on page 115).
134     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.15.11.7 ICR1H and ICR1L – Input Capture Register 1
                 Bit         7          6          5          4           3        2           1          0
              (0x87)                                           ICR1[15:8]                                         ICR1H
              (0x86)                                            ICR1[7:0]                                         ICR1L
           Read/Write       R/W       R/W        R/W        R/W        R/W        R/W         R/W      R/W
           Initial Value     0          0          0          0           0        0           0          0
        The input capture is updated with the counter (TCNT1) value each time an event occurs on the ICP1 pin (or optionally on the
        analog comparator output for Timer/Counter1). The input capture can be used for defining the counter TOP value.
        The input capture register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the
        CPU accesses these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary
        register is shared by all the other 16-bit registers (see Section 5.15.3 “Accessing 16-bit Registers” on page 115).
5.15.11.8 TIMSK1 – Timer/Counter1 Interrupt Mask Register
                 Bit         7          6         5          4           3         2           1          0
              (0x6F)         –          –       ICIE1        –           –      OCIE1B     OCIE1A     TOIE1      TIMSK1
           Read/Write        R         R         R/W         R          R         R/W         R/W      R/W
           Initial Value     0          0         0          0           0         0           0          0
        • Bit 7, 6 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 5 – ICIE1: Timer/Counter1, Input Capture Interrupt Enable
        When this bit is written to one, and the I-flag in the status register is set (interrupts globally enabled), the Timer/Counter1
        input capture interrupt is enabled. The corresponding interrupt vector (see Section 5.11 “Interrupts” on page 73) is executed
        when the ICF1 Flag, located in TIFR1, is set.
        • Bit 4, 3 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 2 – OCIE1B: Timer/Counter1, Output Compare B Match Interrupt Enable
        When this bit is written to one, and the I-flag in the status register is set (interrupts globally enabled), the Timer/Counter1
        output compare B match interrupt is enabled. The corresponding Interrupt vector (see Section 5.11 “Interrupts” on page 73)
        is executed when the OCF1B Flag, located in TIFR1, is set.
        • Bit 1 – OCIE1A: Timer/Counter1, Output Compare A Match Interrupt Enable
        When this bit is written to one, and the I-flag in the status register is set (interrupts globally enabled), the Timer/Counter1
        output compare A match interrupt is enabled. The corresponding interrupt vector (see Section 5.11 “Interrupts” on page 73)
        is executed when the OCF1A flag, located in TIFR1, is set.
        • Bit 0 – TOIE1: Timer/Counter1, Overflow Interrupt Enable
        When this bit is written to one, and the I-flag in the status register is set (interrupts globally enabled), the Timer/Counter1
        overflow interrupt is enabled. The corresponding interrupt vector (see Section 5.11 “Interrupts” on page 73) is executed when
        the TOV1 flag, located in TIFR1, is set.
                                                                                                    ATA6614Q [DATASHEET]              135
                                                                                                                   9240I–AUTO–03/16


5.15.11.9 TIFR1 – Timer/Counter1 Interrupt Flag Register
                 Bit          7           6         5         4        3        2        1         0
           0x16 (0x36)        –           –       ICF1        –        –     OCF1B     OCF1A     TOV1        TIFR1
           Read/Write         R          R        R/W         R        R       R/W      R/W       R/W
           Initial Value      0           0         0         0        0        0        0         0
        • Bit 7, 6 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 5 – ICF1: Timer/Counter1, Input Capture Flag
        This flag is set when a capture event occurs on the ICP1 pin. When the input capture register (ICR1) is set by the WGM13:0
        to be used as the TOP value, the ICF1 flag is set when the counter reaches the TOP value.
        ICF1 is automatically cleared when the input capture interrupt vector is executed. Alternatively, ICF1 can be cleared by
        writing a logic one to its bit location.
        • Bit 4, 3 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 2 – OCF1B: Timer/Counter1, Output Compare B Match Flag
        This flag is set in the timer clock cycle after the counter (TCNT1) value matches the output compare register B (OCR1B).
        Note that a forced output compare (FOC1B) strobe will not set the OCF1B flag.
        OCF1B is automatically cleared when the output compare match B Interrupt Vector is executed. Alternatively, OCF1B can
        be cleared by writing a logic one to its bit location.
        • Bit 1 – OCF1A: Timer/Counter1, Output Compare A Match Flag
        This flag is set in the timer clock cycle after the counter (TCNT1) value matches the output compare register A (OCR1A).
        Note that a forced output compare (FOC1A) strobe will not set the OCF1A flag.
        OCF1A is automatically cleared when the output compare match A interrupt vector is executed. Alternatively, OCF1A can be
        cleared by writing a logic one to its bit location.
        • Bit 0 – TOV1: Timer/Counter1, Overflow Flag
        The setting of this flag is dependent of the WGM13:0 bits setting. In normal and CTC modes, the TOV1 flag is set when the
        timer overflows. Refer to Table 5-53 on page 132 for the TOV1 flag behavior when using another WGM13:0 bit setting.
        TOV1 is automatically cleared when the Timer/Counter1 overflow interrupt vector is executed. Alternatively, TOV1 can be
        cleared by writing a logic one to its bit location.
136     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.16   Timer/Counter0 and Timer/Counter1 Prescalers
       Section 5.14 “8-bit Timer/Counter0 with PWM” on page 98 and Section 5.15 “16-bit Timer/Counter1 with PWM” on page 113
       share the same prescaler module, but the Timer/Counters can have different prescaler settings. The description below
       applies to both Timer/Counter1 and Timer/Counter0.
5.16.1 Internal Clock Source
       The Timer/Counter can be clocked directly by the system clock (by setting the CSn2:0 = 1). This provides the fastest
       operation, with a maximum Timer/Counter clock frequency equal to system clock frequency (fCLK_I/O). Alternatively, one of
       four taps from the prescaler can be used as a clock source. The prescaled clock has a frequency of either fCLK_I/O/8,
       fCLK_I/O/64, fCLK_I/O/256, or fCLK_I/O/1024.
5.16.2 Prescaler Reset
       The prescaler is free running, i.e., operates independently of the clock select logic of the Timer/Counter, and it is shared by
       Timer/Counter1 and Timer/Counter0. Since the prescaler is not affected by the Timer/Counter’s clock select, the state of the
       prescaler will have implications for situations where a prescaled clock is used. One example of prescaling artifacts occurs
       when the timer is enabled and clocked by the prescaler (6 > CSn2:0 > 1). The number of system clock cycles from when the
       timer is enabled to the first count occurs can be from 1 to N+1 system clock cycles, where N equals the prescaler divisor (8,
       64, 256, or 1024).
       It is possible to use the prescaler reset for synchronizing the Timer/Counter to program execution. However, care must be
       taken if the other Timer/Counter that shares the same prescaler also uses prescaling. A prescaler reset will affect the
       prescaler period for all Timer/Counters it is connected to.
5.16.3 External Clock Source
       An external clock source applied to the T1/T0 pin can be used as Timer/Counter clock (clkT1/clkT0). The T1/T0 pin is sampled
       once every system clock cycle by the pin synchronization logic. The synchronized (sampled) signal is then passed through
       the edge detector. Figure 5-51 shows a functional equivalent block diagram of the T1/T0 synchronization and edge detector
       logic. The registers are clocked at the positive edge of the internal system clock (clkI/O). The latch is transparent in the high
       period of the internal system clock.
       The edge detector generates one clkT1/clkT0 pulse for each positive (CSn2:0 = 7) or negative (CSn2:0 = 6) edge it detects.
       Figure 5-51. T1/T0 Pin Sampling
                       Tn            D    Q        D      Q                           D     Q                       Tn_sync
                                                                                                                   (To Clock
                                                                                                                 Select Logic)
                                     LE
                       clkI/O
                                             Synchronization                                   Edge Detector
       The synchronization and edge detector logic introduces a delay of 2.5 to 3.5 system clock cycles from an edge has been
       applied to the T1/T0 pin to the counter is updated.
       Enabling and disabling of the clock input must be done when T1/T0 has been stable for at least one system clock cycle,
       otherwise it is a risk that a false Timer/Counter clock pulse is generated.
       Each half period of the external clock applied must be longer than one system clock cycle to ensure correct sampling. The
       external clock must be guaranteed to have less than half the system clock frequency (fExtClk < fclk_I/O/2) given a 50/50% duty
       cycle. Since the edge detector uses sampling, the maximum frequency of an external clock it can detect is half the sampling
       frequency (Nyquist sampling theorem). However, due to variation of the system clock frequency and duty cycle caused by
       Oscillator source (crystal, resonator, and capacitors) tolerances, it is recommended that maximum frequency of an external
       clock source is less than fclk_I/O/2.5.
       An external clock source can not be prescaled.
                                                                                                ATA6614Q [DATASHEET]                 137
                                                                                                               9240I–AUTO–03/16


       Figure 5-52. Prescaler for Timer/Counter0 and Timer/Counter1(1)
               clkI/O                                                                          10-bit T/C Prescaler
                                                                       Clear
                                                                                    CK/8                  CK/64           CK/256              CK/1024
         PSRSYNC
                   T0     Synchronization
                   T1     Synchronization              0                                                              0
                                            CS10                                                         CS00
                                            CS11                                                         CS01
                                            CS12                                                         CS02
                                                               Timer/Counter1 Clock Source                                         Timer/Counter0 Clock Source
                                                                          clkT1                                                               clkT0
       Note:       1.   The synchronization logic on the input pins (T1/T0) is shown in Figure 5-51 on page 137.
5.16.4 Register Description
5.16.4.1 GTCCR – General Timer/Counter Control Register
             Bit           7           6       5           4             3                 2         1                0
        0x23 (0x43)       TSM          –       –           –             –                 –     PSRASY           PSRSYNC               GTCCR
        Read/Write        R/W          R       R           R             R                 R       R/W              R/W
        Initial Value      0           0       0           0             0                 0         0                0
       • Bit 7 – TSM: Timer/Counter Synchronization Mode
       Writing the TSM bit to one activates the Timer/Counter synchronization mode. In this mode, the value that is written to the
       PSRASY and PSRSYNC bits is kept, hence keeping the corresponding prescaler reset signals asserted. This ensures that
       the corresponding Timer/Counters are halted and can be configured to the same value without the risk of one of them
       advancing during configuration. When the TSM bit is written to zero, the PSRASY and PSRSYNC bits are cleared by
       hardware, and the Timer/Counters start counting simultaneously.
       • Bit 0 – PSRSYNC: Prescaler Reset
       When this bit is one, Timer/Counter1 and Timer/Counter0 prescaler will be reset. This bit is normally cleared immediately by
       hardware, except if the TSM bit is set. Note that Timer/Counter1 and Timer/Counter0 share the same prescaler and a reset
       of this prescaler will affect both timers.
138    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.17   8-bit Timer/Counter2 with PWM and Asynchronous Operation
5.17.1 Features
        ●    Single channel counter
        ●    Clear timer on compare match (auto reload)
        ●    Glitch-free, phase correct pulse width modulator (PWM)
        ●    Frequency generator
        ●    10-bit clock prescaler
        ●    Overflow and compare match interrupt sources (TOV2, OCF2A and OCF2B)
        ●    Allows clocking from external 32kHz watch crystal independent of the I/O clock
5.17.2 Overview
       Timer/Counter2 is a general purpose, single channel, 8-bit Timer/Counter module. A simplified block diagram of the 8-bit
       Timer/Counter is shown in Figure 5-53. The device-specific I/O register and bit locations are listed in Section 5.17.11
       “Register Description” on page 150.
       The PRTIM2 bit in Section 5.9.10 “Minimizing Power Consumption” on page 60 must be written to zero to enable
       Timer/Counter2 module.
       Figure 5-53. 8-bit Timer/Counter Block Diagram
                                                  Count
                                                                                                  TOVn (Int. Req.)
                                                  Clear
                                                             Control Logic     clkTn
                                                 Direction                                     Clock Select
                                                                                                 Edge
                                                                                                                         Tn
                                                                                                Detector
                                                               TOP      BOTTOM
                                                                                              (from Prescaler)
                                 Timer/Counter
                                      TCNTn
                                                                 =              =      0
                                                                                              OCnA (Int. Req.)
                                                                                               Waveform
                                        =                                                      Generation
                                                                                                                        OCnA
                                      OCRnA
                                                                       Fixed
                                                                       TOP
                DATA BUS
                                                                       Value                  OCnB (Int. Req.)
                                                                                               Waveform
                                        =                                                      Generation
                                                                                                                        OCnB
                                      OCRnB
                                      TCCRnA                     TCCRnB
                                                                                           ATA6614Q [DATASHEET]                  139
                                                                                                              9240I–AUTO–03/16


5.17.2.1 Registers
        The Timer/Counter (TCNT2) and output compare register (OCR2A and OCR2B) are 8-bit registers. interrupt request
        (shorten as Int.Req.) signals are all visible in the timer interrupt flag register (TIFR2). All interrupts are individually masked
        with the timer interrupt mask register (TIMSK2). TIFR2 and TIMSK2 are not shown in the figure.
        The Timer/Counter can be clocked internally, via the prescaler, or asynchronously clocked from the TOSC1/2 pins, as
        detailed later in this section. The asynchronous operation is controlled by the asynchronous status register (ASSR). The
        clock select logic block controls which clock source he Timer/Counter uses to increment (or decrement) its value. The
        Timer/Counter is inactive when no clock source is selected. The output from the clock select logic is referred to as the timer
        clock (clkT2).
        The double buffered output compare register (OCR2A and OCR2B) are compared with the Timer/Counter value at all times.
        The result of the compare can be used by the waveform generator to generate a PWM or variable frequency output on the
        output compare pins (OC2A and OC2B). See Section 5.17.5 “Output Compare Unit” on page 141 for details. The compare
        match event will also set the compare flag (OCF2A or OCF2B) which can be used to generate an output compare interrupt
        request.
5.17.2.2 Definitions
        Many register and bit references in this document are written in general form. A lower case “n” replaces the Timer/Counter
        number, in this case 2. However, when using the register or bit defines in a program, the precise form must be used, i.e.,
        TCNT2 for accessing Timer/Counter2 counter value and so on.
        The definitions in Table 5-55 are also used extensively throughout the section.
        Table 5-55. Definitions
               Case           Definition
             BOTTOM           The counter reaches the BOTTOM when it becomes zero (0x00).
                MAX           The counter reaches its MAXimum when it becomes 0xFF (decimal 255).
                              The counter reaches the TOP when it becomes equal to the highest value in the count sequence. The
                TOP           TOP value can be assigned to be the fixed value 0xFF (MAX) or the value stored in the OCR2A register.
                              The assignment is dependent on the mode of operation.
5.17.3 Timer/Counter Clock Sources
        The Timer/Counter can be clocked by an internal synchronous or an external asynchronous clock source. The clock source
        clkT2 is by default equal to the MCU clock, clkI/O. When the AS2 bit in the ASSR register is written to logic one, the clock
        source is taken from the Timer/Counter oscillator connected to TOSC1 and TOSC2. For details on asynchronous operation,
        see Section 5.17.11.8 “ASSR – Asynchronous Status Register” on page 155. For details on clock sources and prescaler, see
        Section 5.17.10 “Timer/Counter Prescaler” on page 150.
5.17.4 Counter Unit
        The main part of the 8-bit Timer/Counter is the programmable bi-directional counter unit. Figure 5-54 on page 140 shows a
        block diagram of the counter and its surrounding environment.
        Figure 5-54. Counter Unit Block Diagram
                                                                              TOVn
                            DATA BUS                                          (Int. Req.)
                                                                                                                               TOSC1
                                                      count
                                                                                 clkTn
                                                                                                                   T/C
                                                      clear
                              TCNTn                            Control Logic              Prescaler             Oscillator
                                                    direction                                                                  TOSC2
                                                          bottom           top                                               clkI/O
140     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


       Signal description (internal signals):
              count                        Increment or decrement TCNT2 by 1.
              direction                    Selects between increment and decrement.
              clear                        Clear TCNT2 (set all bits to zero).
              clkTn                        Timer/Counter clock, referred to as clkT2 in the following.
              top                          Signalizes that TCNT2 has reached maximum value.
              bottom                       Signalizes that TCNT2 has reached minimum value (zero).
       Depending on the mode of operation used, the counter is cleared, incremented, or decremented at each timer clock (clkT2).
       clkT2 can be generated from an external or internal clock source, selected by the clock select bits (CS22:0). When no clock
       source is selected (CS22:0 = 0) the timer is stopped. However, the TCNT2 value can be accessed by the CPU, regardless of
       whether clkT2 is present or not. A CPU write overrides (has priority over) all counter clear or count operations.
       The counting sequence is determined by the setting of the WGM21 and WGM20 bits located in the Timer/Counter control
       register (TCCR2A) and the WGM22 located in the Timer/Counter control register B (TCCR2B). There are close connections
       between how the counter behaves (counts) and how waveforms are generated on the output compare outputs OC2A and
       OC2B. For more details about advanced counting sequences and waveform generation, see Section 5.17.7 “Modes of
       Operation” on page 143.
       The Timer/Counter overflow flag (TOV2) is set according to the mode of operation selected by the WGM22:0 bits. TOV2 can
       be used for generating a CPU interrupt.
5.17.5 Output Compare Unit
       The 8-bit comparator continuously compares TCNT2 with the output compare register (OCR2A and OCR2B). Whenever
       TCNT2 equals OCR2A or OCR2B, the comparator signals a match. A match will set the output compare flag (OCF2A or
       OCF2B) at the next timer clock cycle. If the corresponding interrupt is enabled, the output compare flag generates an output
       compare interrupt. The output compare flag is automatically cleared when the interrupt is executed. Alternatively, the output
       compare flag can be cleared by software by writing a logical one to its I/O bit location. The waveform generator uses the
       match signal to generate an output according to operating mode set by the WGM22:0 bits and compare output mode
       (COM2x1:0) bits. The max and bottom signals are used by the waveform generator for handling the special cases of the
       extreme values in some modes of operation (see Section 5.17.7 “Modes of Operation” on page 143).
       Figure 5-55 shows a block diagram of the output compare unit.
       Figure 5-55. Output Compare Unit, Block Diagram
                                                                 DATA BUS
                                                 OCRnx                                   TCNTn
                                                             =  (8-bit Comparator)
                                                                                          OCFnx (Int. Req.)
                                             top
                                         bottom              Waveform Generator                   OCnx
                                          FOCn
                                                           WGMn[1:0]      COMnX[1:0]
                                                                                                 ATA6614Q [DATASHEET]           141
                                                                                                             9240I–AUTO–03/16


        The OCR2x register is double buffered when using any of the pulse width modulation (PWM) modes. For the normal and
        clear timer on compare (CTC) modes of operation, the double buffering is disabled. The double buffering synchronizes the
        update of the OCR2x compare register to either top or bottom of the counting sequence. The synchronization prevents the
        occurrence of odd-length, non-symmetrical PWM pulses, thereby making the output glitch-free.
        The OCR2x register access may seem complex, but this is not case. When the double buffering is enabled, the CPU has
        access to the OCR2x buffer register, and if double buffering is disabled the CPU will access the OCR2x directly.
5.17.5.1 Force Output Compare
        In non-PWM waveform generation modes, the match output of the comparator can be forced by writing a one to the force
        output compare (FOC2x) bit. Forcing compare match will not set the OCF2x flag or reload/clear the timer, but the OC2x pin
        will be updated as if a real compare match had occurred (the COM2x1:0 bits settings define whether the OC2x pin is set,
        cleared or toggled).
5.17.5.2 Compare Match Blocking by TCNT2 Write
        All CPU write operations to the TCNT2 Register will block any compare match that occurs in the next timer clock cycle, even
        when the timer is stopped. This feature allows OCR2x to be initialized to the same value as TCNT2 without triggering an
        interrupt when the Timer/Counter clock is enabled.
5.17.5.3 Using the Output Compare Unit
        Since writing TCNT2 in any mode of operation will block all compare matches for one timer clock cycle, there are risks
        involved when changing TCNT2 when using the output compare channel, independently of whether the Timer/Counter is
        running or not. If the value written to TCNT2 equals the OCR2x value, the compare match will be missed, resulting in
        incorrect waveform generation. Similarly, do not write the TCNT2 value equal to BOTTOM when the counter is
        downcounting. The setup of the OC2x should be performed before setting the data direction register for the port pin to
        output. The easiest way of setting the OC2x value is to use the force output compare (FOC2x) strobe bit in normal mode.
        The OC2x register keeps its value even when changing between waveform generation modes.
        Be aware that the COM2x1:0 bits are not double buffered together with the compare value. Changing the COM2x1:0 bits will
        take effect immediately.
5.17.6 Compare Match Output Unit
        The compare output mode (COM2x1:0) bits have two functions. The waveform generator uses the COM2x1:0 bits for
        defining the output compare (OC2x) state at the next compare match. Also, the COM2x1:0 bits control the OC2x pin output
        source. Figure 5-56 shows a simplified schematic of the logic affected by the COM2x1:0 bit setting. The I/O registers, I/O
        bits, and I/O pins in the figure are shown in bold. Only the parts of the general I/O port control registers (DDR and PORT)
        that are affected by the COM2x1:0 bits are shown. When referring to the OC2x state, the reference is for the internal OC2x
        Register, not the OC2x pin.
142     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


      Figure 5-56. Compare Match Output Unit, Schematic
                             COMnx1
                             COMnx0            Waveform
                                               Generator           D          Q
                             FOCnx
                                                                                     1
                                                                                                        OCnx
                                                                       OCnx                              Pin
                                                                                     0
                                                                   D          Q
                                                       DATA BUS
                                                                    PORT
                                                                   D          Q
                                                                       DDR
                            clkI/O
      The general I/O port function is overridden by the output compare (OC2x) from the waveform generator if either of the
      COM2x1:0 bits are set. However, the OC2x pin direction (input or output) is still controlled by the data direction register
      (DDR) for the port pin. The data direction register bit for the OC2x pin (DDR_OC2x) must be set as output before the OC2x
      value is visible on the pin. The port override function is independent of the waveform generation mode.
      The design of the output compare pin logic allows initialization of the OC2x state before the output is enabled. Note that
      some COM2x1:0 bit settings are reserved for certain modes of operation (see Section 5.17.11 “Register Description” on
      page 150).
5.17.6.1 Compare Output Mode and Waveform Generation
      The waveform generator uses the COM2x1:0 bits differently in normal, CTC, and PWM modes. For all modes, setting the
      COM2x1:0 = 0 tells the waveform generator that no action on the OC2x register is to be performed on the next compare
      match. For compare output actions in the non-PWM modes refer to Table 5-59 on page 151. For fast PWM mode, refer to
      Table 5-60 on page 152, and for phase correct PWM refer to Table 5-61 on page 152.
      A change of the COM2x1:0 bits state will have effect at the first compare match after the bits are written. For non-PWM
      modes, the action can be forced to have immediate effect by using the FOC2x strobe bits.
5.17.7 Modes of Operation
      The mode of operation, i.e., the behavior of the Timer/Counter and the output compare pins, is defined by the combination of
      the waveform generation mode (WGM22:0) and compare output mode (COM2x1:0) bits. The compare output mode bits do
      not affect the counting sequence, while the waveform generation mode bits do. The COM2x1:0 bits control whether the
      PWM output generated should be inverted or not (inverted or non-inverted PWM). For non-PWM modes the COM2x1:0 bits
      control whether the output should be set, cleared, or toggled at a compare match (see Section 5.17.6 “Compare Match
      Output Unit” on page 142).
      For detailed timing information refer to Section 5.17.8 “Timer/Counter Timing Diagrams” on page 147.
                                                                                            ATA6614Q [DATASHEET]                   143
                                                                                                          9240I–AUTO–03/16


5.17.7.1 Normal Mode
        The simplest mode of operation is the normal mode (WGM22:0 = 0). In this mode the counting direction is always up
        (incrementing), and no counter clear is performed. The counter simply OverRuns when it passes its maximum 8-bit value
        (TOP = 0xFF) and then restarts from the bottom (0x00). In normal operation the Timer/Counter overflow flag (TOV2) will be
        set in the same timer clock cycle as the TCNT2 becomes zero. The TOV2 flag in this case behaves like a ninth bit, except
        that it is only set, not cleared. However, combined with the timer overflow interrupt that automatically clears the TOV2 flag,
        the timer resolution can be increased by software. There are no special cases to consider in the normal mode, a new counter
        value can be written anytime.
        The output compare unit can be used to generate interrupts at some given time. Using the output compare to generate
        waveforms in normal mode is not recommended, since this will occupy too much of the CPU time.
5.17.7.2 Clear Timer on Compare Match (CTC) Mode
        In clear timer on compare or CTC mode (WGM22:0 = 2), the OCR2A register is used to manipulate the counter resolution. In
        CTC mode the counter is cleared to zero when the counter value (TCNT2) matches the OCR2A. The OCR2A defines the top
        value for the counter, hence also its resolution. This mode allows greater control of the compare match output frequency. It
        also simplifies the operation of counting external events.
        The timing diagram for the CTC mode is shown in Figure 5-57. The counter value (TCNT2) increases until a compare match
        occurs between TCNT2 and OCR2A, and then counter (TCNT2) is cleared.
        Figure 5-57. CTC Mode, Timing Diagram
                                                                                                             OCnx Interrupt
                                                                                                                Flag Set
                     TCNTn
                       OCnx                                                                              (COMnx[1:0] = 1)
                    (Toggle)
                                                                1   2 3          4
                      Period
        An interrupt can be generated each time the counter value reaches the TOP value by using the OCF2A flag. If the interrupt
        is enabled, the interrupt handler routine can be used for updating the TOP value. However, changing TOP to a value close to
        BOTTOM when the counter is running with none or a low prescaler value must be done with care since the CTC mode does
        not have the double buffering feature. If the new value written to OCR2A is lower than the current value of TCNT2, the
        counter will miss the compare match. The counter will then have to count to its maximum value (0xFF) and wrap around
        starting at 0x00 before the compare match can occur.
        For generating a waveform output in CTC mode, the OC2A output can be set to toggle its logical level on each compare
        match by setting the compare output mode bits to toggle mode (COM2A1:0 = 1). The OC2A value will not be visible on the
        port pin unless the data direction for the pin is set to output. The waveform generated will have a maximum frequency of
        fOC2A = fclk_I/O/2 when OCR2A is set to zero (0x00). The waveform frequency is defined by the following equation:
                                  f clk_I/O
         f OCnx = -------------------------------------------------
                    2  N   1 + OCRnx 
        The N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).
        As for the normal mode of operation, the TOV2 Flag is set in the same timer clock cycle that the counter counts from MAX to
        0x00.
144     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.17.7.3 Fast PWM Mode
        The fast pulse width modulation or fast PWM mode (WGM22:0 = 3 or 7) provides a high frequency PWM waveform
        generation option. The fast PWM differs from the other PWM option by its single-slope operation. The counter counts from
        BOTTOM to TOP then restarts from BOTTOM. TOP is defined as 0xFF when WGM2:0 = 3, and OCR2A when MGM2:0 = 7.
        In non-inverting compare output mode, the output compare (OC2x) is cleared on the compare match between TCNT2 and
        OCR2x, and set at BOTTOM. In inverting compare output mode, the output is set on compare match and cleared at
        BOTTOM. Due to the single-slope operation, the operating frequency of the fast PWM mode can be twice as high as the
        phase correct PWM mode that uses dual-slope operation. This high frequency makes the fast PWM mode well suited for
        power regulation, rectification, and DAC applications. High frequency allows physically small sized external components
        (coils, capacitors), and therefore reduces total system cost.
        In fast PWM mode, the counter is incremented until the counter value matches the TOP value. The counter is then cleared at
        the following timer clock cycle. The timing diagram for the fast PWM mode is shown in Figure 5-58. The TCNT2 value is in
        the timing diagram shown as a histogram for illustrating the single-slope operation. The diagram includes non-inverted and
        inverted PWM outputs. The small horizontal line marks on the TCNT2 slopes represent compare matches between OCR2x
        and TCNT2.
        Figure 5-58. Fast PWM Mode, Timing Diagram
                                                                                                                  OCRnx Interrupt
                                                                                                                      Flag Set
                                                                                                                 OCRnx Update and
                                                                                                               TOVn Interrupt Flag Set
                  TCNTn
                    OCnx                                                                                      (COMnx1:0 = 2)
                    OCnx                                                                                      (COMnx1:0 = 3)
                                       1   2            3         4         5          6          7
                   Period
        The Timer/Counter overflow flag (TOV2) is set each time the counter reaches TOP. If the interrupt is enabled, the interrupt
        handler routine can be used for updating the compare value.
        In fast PWM mode, the compare unit allows generation of PWM waveforms on the OC2x pin. Setting the COM2x1:0 bits to
        two will produce a non-inverted PWM and an inverted PWM output can be generated by setting the COM2x1:0 to three. TOP
        is defined as 0xFF when WGM2:0 = 3, and OCR2A when MGM2:0 = 7. (See Table 5-57 on page 151). The actual OC2x
        value will only be visible on the port pin if the data direction for the port pin is set as output. The PWM waveform is generated
        by setting (or clearing) the OC2x Register at the compare match between OCR2x and TCNT2, and clearing (or setting) the
        OC2x register at the timer clock cycle the counter is cleared (changes from TOP to BOTTOM).
        The PWM frequency for the output can be calculated by the following equation:
                         f clk_I/O
         f OCnxPWM = -----------------
                         N  256
        The N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).
        The extreme values for the OCR2A Register represent special cases when generating a PWM waveform output in the fast
        PWM mode. If the OCR2A is set equal to BOTTOM, the output will be a narrow spike for each MAX+1 timer clock cycle.
        Setting the OCR2A equal to MAX will result in a constantly high or low output (depending on the polarity of the output set by
        the COM2A1:0 bits).
                                                                                                      ATA6614Q [DATASHEET]             145
                                                                                                                   9240I–AUTO–03/16


        A frequency (with 50% duty cycle) waveform output in fast PWM mode can be achieved by setting OC2x to toggle its logical
        level on each compare match (COM2x1:0 = 1). The waveform generated will have a maximum frequency of foc2 = fclk_I/O/2
        when OCR2A is set to zero. This feature is similar to the OC2A toggle in CTC mode, except the double buffer feature of the
        output compare unit is enabled in the fast PWM mode.
5.17.7.4 Phase Correct PWM Mode
        The phase correct PWM mode (WGM22:0 = 1 or 5) provides a high resolution phase correct PWM waveform generation
        option. The phase correct PWM mode is based on a dual-slope operation. The counter counts repeatedly from BOTTOM to
        TOP and then from TOP to BOTTOM. TOP is defined as 0xFF when WGM2:0 = 3, and OCR2A when MGM2:0 = 7. In non-
        inverting compare output mode, the output compare (OC2x) is cleared on the compare match between TCNT2 and OCR2x
        while upcounting, and set on the compare match while downcounting. In inverting output compare mode, the operation is
        inverted. The dual-slope operation has lower maximum operation frequency than single slope operation. However, due to
        the symmetric feature of the dual-slope PWM modes, these modes are preferred for motor control applications.
        In phase correct PWM mode the counter is incremented until the counter value matches TOP. When the counter reaches
        TOP, it changes the count direction. The TCNT2 value will be equal to TOP for one timer clock cycle. The timing diagram for
        the phase correct PWM mode is shown on Figure 5-59. The TCNT2 value is in the timing diagram shown as a histogram for
        illustrating the dual-slope operation. The diagram includes non-inverted and inverted PWM outputs. The small horizontal line
        marks on the TCNT2 slopes represent compare matches between OCR2x and TCNT2.
        Figure 5-59. Phase Correct PWM Mode, Timing Diagram
                                                                                                                 OCnx Interrupt
                                                                                                                    Flag Set
                                                                                                                OCRnx Update
                                                                                                                 TOVn Interrupt
                                                                                                                    Flag Set
                   TCNTn
                     OCnx                                                                                  (COMnx1:0 = 2)
                     OCnx                                                                                  (COMnx1:0 = 3)
                                                1                 2                      3
                    Period
        The Timer/Counter Overflow flag (TOV2) is set each time the counter reaches BOTTOM. The Interrupt Flag can be used to
        generate an interrupt each time the counter reaches the BOTTOM value.
        In phase correct PWM mode, the compare unit allows generation of PWM waveforms on the OC2x pin. Setting the
        COM2x1:0 bits to two will produce a non-inverted PWM. An inverted PWM output can be generated by setting the
        COM2x1:0 to three. TOP is defined as 0xFF when WGM2:0 = 3, and OCR2A when MGM2:0 = 7 (See Table 5-58 on page
        151). The actual OC2x value will only be visible on the port pin if the data direction for the port pin is set as output. The PWM
        waveform is generated by clearing (or setting) the OC2x register at the compare match between OCR2x and TCNT2 when
        the counter increments, and setting (or clearing) the OC2x register at compare match between OCR2x and TCNT2 when the
        counter decrements. The PWM frequency for the output when using phase correct PWM can be calculated by the following
        equation:
                            f clk_I/O
         f OCnxPCPWM = -----------------
                            N  510
        The N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).
146     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


       The extreme values for the OCR2A register represent special cases when generating a PWM waveform output in the phase
       correct PWM mode. If the OCR2A is set equal to BOTTOM, the output will be continuously low and if set equal to MAX the
       output will be continuously high for non-inverted PWM mode. For inverted PWM the output will have the opposite logic
       values.
       At the very start of period 2 in Figure 5-59 OCnx has a transition from high to low even though there is no compare match.
       The point of this transition is to guarantee symmetry around BOTTOM. There are two cases that give a transition without
       compare match.
         ● OCR2A changes its value from MAX, like in Figure 5-59. When the OCR2A value is MAX the OCn pin value is the
              same as the result of a down-counting compare match. To ensure symmetry around BOTTOM the OCn value at MAX
              must correspond to the result of an up-counting compare match.
         ●    The timer starts counting from a value higher than the one in OCR2A, and for that reason misses the compare match
              and hence the OCn change that would have happened on the way up.
5.17.8 Timer/Counter Timing Diagrams
       The following figures show the Timer/Counter in synchronous mode, and the timer clock (clkT2) is therefore shown as a clock
       enable signal. In asynchronous mode, clkI/O should be replaced by the Timer/Counter oscillator clock. The figures include
       information on when interrupt flags are set. Figure 5-60 contains timing data for basic Timer/Counter operation. The figure
       shows the count sequence close to the MAX value in all modes other than phase correct PWM mode.
       Figure 5-60. Timer/Counter Timing Diagram, no Prescaling
                            clkI/O
                            clkTn
                        (clkI/O/1)
                         TCNTn                MAX - 1             MAX                BOTTOM           BOTTOM + 1
                           TOVn
       Figure 5-61 shows the same timing data, but with the prescaler enabled.
       Figure 5-61. Timer/Counter Timing Diagram, with Prescaler (fclk_I/O/8)
                            clkI/O
                            clkTn
                        (clkI/O/8)
                         TCNTn                MAX - 1             MAX                BOTTOM           BOTTOM + 1
                           TOVn
                                                                                             ATA6614Q [DATASHEET]               147
                                                                                                           9240I–AUTO–03/16


       Figure 5-62 shows the setting of OCF2A in all modes except CTC mode.
       Figure 5-62. Timer/Counter Timing Diagram, Setting of OCF2A, with Prescaler (fclk_I/O/8)
                            clkI/O
                            clkTn
                        (clkI/O/8)
                         TCNTn               OCRnx - 1            OCRnx              OCRnx + 1          OCRnx + 2
                         OCRnx                                           OCRnx Value
                          OCFnx
       Figure 5-63 shows the setting of OCF2A and the clearing of TCNT2 in CTC mode.
       Figure 5-63. Timer/Counter Timing Diagram, Clear Timer on Compare Match mode, with Prescaler (fclk_I/O/8)
                            clkI/O
                            clkTn
                        (clkI/O/8)
                         TCNTn
                           (CTC)              TOP - 1               TOP              BOTTOM            BOTTOM + 1
                         OCRnx                                                TOP
                         OCFnx
5.17.9 Asynchronous Operation of Timer/Counter2
       When Timer/Counter2 operates asynchronously, some considerations must be taken.
         ● Warning: When switching between asynchronous and synchronous clocking of Timer/Counter2, the timer registers
              TCNT2, OCR2x, and TCCR2x might be corrupted. A safe procedure for switching clock source is:
                 a.   Disable the Timer/Counter2 interrupts by clearing OCIE2x and TOIE2.
                 b.   Select clock source by setting AS2 as appropriate.
                 c.   Write new values to TCNT2, OCR2x, and TCCR2x.
                 d.   To switch to asynchronous operation: Wait for TCN2xUB, OCR2xUB, and TCR2xUB.
                 e.   Clear the Timer/Counter2 interrupt flags.
                 f.   Enable interrupts, if needed.
         ●    The CPU main clock frequency must be more than four times the oscillator frequency.
         ●    When writing to one of the registers TCNT2, OCR2x, or TCCR2x, the value is transferred to a temporary register, and
              latched after two positive edges on TOSC1. The user should not write a new value before the contents of the
              temporary register have been transferred to its destination. Each of the five mentioned registers have their individual
              temporary register, which means that e.g. writing to TCNT2 does not disturb an OCR2x write in progress. To detect
              that a transfer to the destination register has taken place, the asynchronous status register – ASSR has been
              implemented.
148    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


  ●    When entering power-save or ADC noise reduction mode after having written to TCNT2, OCR2x, or TCCR2x, the
       user must wait until the written register has been updated if Timer/Counter2 is used to wake up the device. Otherwise,
       the MCU will enter sleep mode before the changes are effective. This is particularly important if any of the output
       compare2 interrupt is used to wake up the device, since the output compare function is disabled during writing to
       OCR2x or TCNT2. If the write cycle is not finished, and the MCU enters sleep mode before the corresponding
       OCR2xUB bit returns to zero, the device will never receive a compare match interrupt, and the MCU will not wake up.
  ●    If Timer/Counter2 is used to wake the device up from power-save or ADC noise reduction mode, precautions must be
       taken if the user wants to re-enter one of these modes: If re-entering sleep mode within the TOSC1 cycle, the interrupt
       will immediately occur and the device wake up again. The result is multiple interrupts and wake-ups within one
       TOSC1 cycle from the first interrupt. If the user is in doubt whether the time before re-entering power-save or ADC
       noise reduction mode is sufficient, the following algorithm can be used to ensure that one TOSC1 cycle has elapsed:
          a.  Write a value to TCCR2x, TCNT2, or OCR2x.
          b.  Wait until the corresponding update busy flag in ASSR returns to zero.
          c.  Enter power-save or ADC noise reduction mode.
  ●    When the asynchronous operation is selected, the 32.768kHz oscillator for Timer/Counter2 is always running, except
       in power-down and standby modes. After a power-up reset or wake-up from power-down or standby mode, the user
       should be aware of the fact that this oscillator might take as long as one second to stabilize. The user is advised to
       wait for at least one second before using Timer/Counter2 after power-up or wake-up from power-down or standby
       mode. The contents of all Timer/Counter2 registers must be considered lost after a wake-up from power-down or
       standby mode due to unstable clock signal upon start-up, no matter whether the oscillator is in use or a clock signal is
       applied to the TOSC1 pin.
  ●    Description of wake up from power-save or ADC noise reduction mode when the timer is clocked asynchronously:
       When the interrupt condition is met, the wake up process is started on the following cycle of the timer clock, that is,
       the timer is always advanced by at least one before the processor can read the counter value. After wake-up, the
       MCU is halted for four cycles, it executes the interrupt routine, and resumes execution from the instruction following
       SLEEP.
  ●    Reading of the TCNT2 register shortly after wake-up from power-save may give an incorrect result. Since TCNT2 is
       clocked on the asynchronous TOSC clock, reading TCNT2 must be done through a register synchronized to the
       internal I/O clock domain. Synchronization takes place for every rising TOSC1 edge. When waking up from power-
       save mode, and the I/O clock (clkI/O) again becomes active, TCNT2 will read as the previous value (before entering
       sleep) until the next rising TOSC1 edge. The phase of the TOSC clock after waking up from power-save mode is
       essentially unpredictable, as it depends on the wake-up time. The recommended procedure for reading TCNT2 is
       thus as follows:
          a.  Write any value to either of the registers OCR2x or TCCR2x.
          b.  Wait for the corresponding update busy flag to be cleared.
          c.  Read TCNT2.
During asynchronous operation, the synchronization of the interrupt flags for the asynchronous timer takes 3 processor
cycles plus one timer cycle. The timer is therefore advanced by at least one before the processor can read the timer value
causing the setting of the interrupt flag. The output compare pin is changed on the timer clock and is not synchronized to the
processor clock.
                                                                                        ATA6614Q [DATASHEET]                149
                                                                                                      9240I–AUTO–03/16


5.17.10     Timer/Counter Prescaler
          Figure 5-64. Prescaler for Timer/Counter2
                                    clkI/O
                                                            clkT2S
                                                                                                 10-bit T/C Prescaler
                                                                      Clear
                                   TOSC1
                                                                                  clkT2S/8             clkT2S/32   clkT2S/64   clkT2S/128    clkT2S/256   clkT2S/1024
                                     AS2
                               PSRASY
                                                                                             0
                                    CS20
                                    CS21
                                    CS22
                                                                                  Timer/Counter2 Clock Source
                                                                                             clkT2
          The clock source for Timer/Counter2 is named clkT2S. clkT2S is by default connected to the main system I/O clock clkIO. By
          setting the AS2 bit in ASSR, Timer/Counter2 is asynchronously clocked from the TOSC1 pin. This enables use of
          Timer/Counter2 as a real time counter (RTC). When AS2 is set, pins TOSC1 and TOSC2 are disconnected from Port C. A
          crystal can then be connected between the TOSC1 and TOSC2 pins to serve as an independent clock source for
          Timer/Counter2. The pscillator is optimized for use with a 32.768 kHz crystal.
          For Timer/Counter2, the possible prescaled selections are: clkT2S/8, clkT2S/32, clkT2S/64, clkT2S/128, clkT2S/256, and
          clkT2S/1024. Additionally, clkT2S as well as 0 (stop) may be selected. Setting the PSRASY bit in GTCCR resets the prescaler.
          This allows the user to operate with a predictable prescaler.
5.17.11 Register Description
5.17.11.1 TCCR2A – Timer/Counter Control Register A
                 Bit           7                 6     5              4       3                    2                       1                      0
              (0xB0)         COM2A1     COM2A0       COM2B1 COM2B0            –                    –               WGM21                    WGM20         TCCR2A
            Read/Write        R/W            R/W      R/W            R/W      R                    R                R/W                      R/W
            Initial Value      0                 0     0              0       0                    0                       0                      0
          • Bits 7:6 – COM2A1:0: Compare Match Output A Mode
          These bits control the output compare pin (OC2A) behavior. If one or both of the COM2A1:0 bits are set, the OC2A output
          overrides the normal port functionality of the I/O pin it is connected to. However, note that the data direction register (DDR)
          bit corresponding to the OC2A pin must be set in order to enable the output driver.
          When OC2A is connected to the pin, the function of the COM2A1:0 bits depends on the WGM22:0 bit setting. Table 5-56
          shows the COM2A1:0 bit functionality when the WGM22:0 bits are set to a normal or CTC mode (non-PWM).
          Table 5-56. Compare Output Mode, non-PWM Mode
               COM2A1               COM2A0            Description
                       0                     0        Normal port operation, OC0A disconnected.
                       0                     1        Toggle OC2A on compare match
                       1                     0        Clear OC2A on compare match
                       1                     1        Set OC2A on compare match
150       ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


Table 5-57 shows the COM2A1:0 bit functionality when the WGM21:0 bits are set to fast PWM mode.
Table 5-57. Compare Output Mode, Fast PWM Mode(1)
     COM2A1            COM2A0           Description
         0                  0           Normal port operation, OC2A disconnected.
                                        WGM22 = 0: Normal port operation, OC0A disconnected.
         0                  1
                                        WGM22 = 1: Toggle OC2A on compare match.
         1                  0           Clear OC2A on compare match, set OC2A at BOTTOM, (non-inverting mode).
         1                  1           Set OC2A on compare match, clear OC2A at BOTTOM, (inverting mode).
Note:     1.  A special case occurs when OCR2A equals TOP and COM2A1 is set. In this case, the compare match is
              ignored, but the set or clear is done at BOTTOM. See Section 5.17.7.3 “Fast PWM Mode” on page 145 for
              more details.
Table 5-58 shows the COM2A1:0 bit functionality when the WGM22:0 bits are set to phase correct PWM mode.
Table 5-58. Compare Output Mode, Phase Correct PWM Mode(1)
     COM2A1            COM2A0           Description
         0                  0           Normal port operation, OC2A disconnected.
                                        WGM22 = 0: Normal port operation, OC2A disconnected.
         0                  1
                                        WGM22 = 1: Toggle OC2A on compare match.
                                        Clear OC2A on compare match when up-counting. Set OC2A on compare match
         1                  0
                                        when down-counting.
                                        Set OC2A on compare match when up-counting. Clear OC2A on compare match
         1                  1
                                        when down-counting.
Note:     1.  A special case occurs when OCR2A equals TOP and COM2A1 is set. In this case, the compare match is
              ignored, but the set or clear is done at TOP. See Section 5.17.7.4 “Phase Correct PWM Mode” on page 146 for
              more details.
• Bits 5:4 – COM2B1:0: Compare Match Output B Mode
These bits control the output compare pin (OC2B) behavior. If one or both of the COM2B1:0 bits are set, the OC2B output
overrides the normal port functionality of the I/O pin it is connected to. However, note that the data direction register (DDR)
bit corresponding to the OC2B pin must be set in order to enable the output driver.
When OC2B is connected to the pin, the function of the COM2B1:0 bits depends on the WGM22:0 bit setting. Table 5-59
shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to a normal or CTC mode (non-PWM).
Table 5-59. Compare Output Mode, non-PWM Mode
     COM2B1             COM2B0           Description
          0                  0           Normal port operation, OC2B disconnected.
          0                  1           Toggle OC2B on compare match
          1                  0           Clear OC2B on compare match
          1                  1           Set OC2B on compare match
                                                                                        ATA6614Q [DATASHEET]                 151
                                                                                                       9240I–AUTO–03/16


    Table 5-60 shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to fast PWM mode.
    Table 5-60. Compare Output Mode, Fast PWM Mode(1)
         COM2B1             COM2B0           Description
             0                   0           Normal port operation, OC2B disconnected.
             0                   1           Reserved
             1                   0           Clear OC2B on compare match, set OC2B at BOTTOM, (non-inverting mode).
             1                   1           Set OC2B on compare match, clear OC2B at BOTTOM, (inverting mode).
    Note:    1.   A special case occurs when OCR2B equals TOP and COM2B1 is set. In this case, the compare match is
                  ignored, but the set or clear is done at BOTTOM. See Section 5.17.7.4 “Phase Correct PWM Mode” on page
                  146 for more details.
    Table 5-61 shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to phase correct PWM mode.
    Table 5-61. Compare Output Mode, Phase Correct PWM Mode(1)
         COM2B1             COM2B0           Description
             0                   0           Normal port operation, OC2B disconnected.
             0                   1           Reserved
                                             Clear OC2B on compare match when up-counting. Set OC2B on compare match
             1                   0
                                             when down-counting.
                                             Set OC2B on compare match when up-counting. Clear OC2B on compare match
             1                   1
                                             when down-counting.
    Note:    1.   A special case occurs when OCR2B equals TOP and COM2B1 is set. In this case, the compare match is
                  ignored, but the set or clear is done at TOP. See Section 5.17.7.4 “Phase Correct PWM Mode” on page 146 for
                  more details.
    • Bits 3, 2 – Res: Reserved Bits
    These bits are reserved bits in the ATmega328P and will always read as zero.
    • Bits 1:0 – WGM21:0: Waveform Generation Mode
    Combined with the WGM22 bit found in the TCCR2B register, these bits control the counting sequence of the counter, the
    source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 5-62 on page 152.
    Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), clear timer on compare match (CTC)
    mode, and two types of pulse width modulation (PWM) modes (see Section 5.17.7 “Modes of Operation” on page 143).
    Table 5-62. Waveform Generation Mode Bit Description
                                                          Timer/Counter Mode                    Update of       TOV Flag
       Mode        WGM2         WGM1          WGM0        of Operation                TOP        OCRx at       Set on(1)(2)
          0           0            0              0       Normal                     0xFF       Immediate         MAX
          1           0            0              1       PWM, phase correct         0xFF          TOP          BOTTOM
          2           0            1              0       CTC                       OCRA        Immediate         MAX
          3           0            1              1       Fast PWM                   0xFF        BOTTOM           MAX
          4           1            0              0       Reserved                     –             –              –
          5           1            0              1       PWM, phase correct        OCRA           TOP          BOTTOM
          6           1            1              0       Reserved                     –             –              –
          7           1            1              1       Fast PWM                  OCRA         BOTTOM           TOP
    Notes:   1.   MAX = 0xFF
             2.   BOTTOM = 0x00
152 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.17.11.2 TCCR2B – Timer/Counter Control Register B
                 Bit        7          6          5          4         3          2         1        0
              (0xB1)     FOC2A      FOC2B         –          –      WGM22       CS22      CS21    CS20     TCCR2B
           Read/Write      W           W          R         R          R          R       R/W      R/W
           Initial Value    0          0          0          0         0          0         0        0
        • Bit 7 – FOC2A: Force Output Compare A
        The FOC2A bit is only active when the WGM bits specify a non-PWM mode.
        However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR2B is written when operating
        in PWM mode. When writing a logical one to the FOC2A bit, an immediate compare match is forced on the waveform
        generation unit. The OC2A output is changed according to its COM2A1:0 bits setting. Note that the FOC2A bit is
        implemented as a strobe. Therefore it is the value present in the COM2A1:0 bits that determines the effect of the forced
        compare.
        A FOC2A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR2A as TOP.
        The FOC2A bit is always read as zero.
        • Bit 6 – FOC2B: Force Output Compare B
        The FOC2B bit is only active when the WGM bits specify a non-PWM mode.
        However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR2B is written when operating
        in PWM mode. When writing a logical one to the FOC2B bit, an immediate compare match is forced on the waveform
        generation unit. The OC2B output is changed according to its COM2B1:0 bits setting. Note that the FOC2B bit is
        implemented as a strobe. Therefore it is the value present in the COM2B1:0 bits that determines the effect of the forced
        compare.
        A FOC2B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR2B as TOP.
        The FOC2B bit is always read as zero.
        • Bits 5:4 – Res: Reserved Bits
        These bits are reserved bits in the ATmega328P and will always read as zero.
        • Bit 3 – WGM22: Waveform Generation Mode
        See the description in Section 5.17.11.1 “TCCR2A – Timer/Counter Control Register A” on page 150.
        • Bit 2:0 – CS22:0: Clock Select
        The three clock select bits select the clock source to be used by the Timer/Counter, see Table 5-63 on page 153.
        Table 5-63. Clock Select Bit Description
                 CS22             CS21                CS20         Description
                     0               0                  0          No clock source (Timer/Counter stopped).
                     0               0                  1          clkT2S/(no prescaling)
                     0               1                  0          clkT2S/8 (from prescaler)
                     0               1                  1          clkT2S/32 (from prescaler)
                     1               0                  0          clkT2S/64 (from prescaler)
                     1               0                  1          clkT2S/128 (from prescaler)
                     1               1                  0          clkT2S/256 (from prescaler)
                     1               1                  1          clkT2S/1024 (from prescaler)
        If external pin modes are used for the Timer/Counter0, transitions on the T0 pin will clock the counter even if the pin is
        configured as an output. This feature allows software control of the counting.
                                                                                               ATA6614Q [DATASHEET]                153
                                                                                                            9240I–AUTO–03/16


5.17.11.3 TCNT2 – Timer/Counter Register
                 Bit        7          6         5         4          3          2          1         0
              (0xB2)                                       TCNT2[7:0]                                        TCNT2
           Read/Write      R/W       R/W       R/W       R/W         R/W       R/W         R/W       R/W
           Initial Value    0          0         0         0          0          0          0         0
        The Timer/Counter register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter.
        Writing to the TCNT2 register blocks (removes) the compare match on the following timer clock. Modifying the counter
        (TCNT2) while the counter is running, introduces a risk of missing a compare match between TCNT2 and the OCR2x
        registers.
5.17.11.4 OCR2A – Output Compare Register A
                 Bit        7          6         5         4          3          2          1          0
              (0xB3)                                       OCR2A[7:0]                                        OCR2A
           Read/Write      R/W       R/W       R/W       R/W         R/W       R/W         R/W       R/W
           Initial Value    0          0         0         0          0          0          0          0
        The output compare register A contains an 8-bit value that is continuously compared with the counter value (TCNT2). A
        match can be used to generate an output compare interrupt, or to generate a waveform output on the OC2A pin.
5.17.11.5 OCR2B – Output Compare Register B
                 Bit        7          6         5         4          3          2          1         0
              (0xB4)                                       OCR2B[7:0]                                        OCR2B
           Read/Write      R/W       R/W       R/W       R/W         R/W       R/W         R/W       R/W
           Initial Value    0          0         0         0          0          0          0         0
        The output compare register B contains an 8-bit value that is continuously compared with the counter value (TCNT2). A
        match can be used to generate an output compare interrupt, or to generate a waveform output on the OC2B pin.
5.17.11.6 TIMSK2 – Timer/Counter2 Interrupt Mask Register
                 Bit        7         6        5         4         3           2            1          0
              (0x70)        –         –        –         –          –      OCIE2B        OCIE2A     TOIE2    TIMSK2
           Read/Write       R         R        R        R          R          R/W          R/W       R/W
           Initial Value    0         0        0         0         0           0            0          0
        • Bit 2 – OCIE2B: Timer/Counter2 Output Compare Match B Interrupt Enable
        When the OCIE2B bit is written to one and the I-bit in the status register is set (one), the Timer/Counter2 compare match B
        interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter2 occurs, i.e., when the
        OCF2B bit is set in the Timer/Counter 2 interrupt flag register – TIFR2.
        • Bit 1 – OCIE2A: Timer/Counter2 Output Compare Match A Interrupt Enable
        When the OCIE2A bit is written to one and the I-bit in the status register is set (one), the Timer/Counter2 compare match A
        interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter2 occurs, i.e., when the
        OCF2A bit is set in the Timer/Counter 2 interrupt flag register – TIFR2.
        • Bit 0 – TOIE2: Timer/Counter2 Overflow Interrupt Enable
        When the TOIE2 bit is written to one and the I-bit in the status register is set (one), the Timer/Counter2 overflow interrupt is
        enabled. The corresponding interrupt is executed if an overflow in Timer/Counter2 occurs, i.e., when the TOV2 bit is set in
        the Timer/Counter2 interrupt flag register – TIFR2.
154     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.17.11.7 TIFR2 – Timer/Counter2 Interrupt Flag Register
                 Bit         7          6        5          4         3         2           1        0
           0x17 (0x37)       –          –        –          –         –      OCF2B      OCF2A      TOV2        TIFR2
           Read/Write        R          R        R          R         R        R/W        R/W       R/W
           Initial Value     0          0        0          0         0         0           0        0
        • Bit 2 – OCF2B: Output Compare Flag 2 B
        The OCF2B bit is set (one) when a compare match occurs between the Timer/Counter2 and the data in OCR2B – output
        compare register2. OCF2B is cleared by hardware when executing the corresponding interrupt handling vector.
        Alternatively, OCF2B is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE2B (Timer/Counter2 compare
        match interrupt enable), and OCF2B are set (one), the Timer/Counter2 compare match interrupt is executed.
        • Bit 1 – OCF2A: Output Compare Flag 2 A
        The OCF2A bit is set (one) when a compare match occurs between the Timer/Counter2 and the data in OCR2A – output
        compare register2. OCF2A is cleared by hardware when executing the corresponding interrupt handling vector.
        Alternatively, OCF2A is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE2A (Timer/Counter2 compare
        match Interrupt Enable), and OCF2A are set (one), the Timer/Counter2 compare match Interrupt is executed.
        • Bit 0 – TOV2: Timer/Counter2 Overflow Flag
        The TOV2 bit is set (one) when an overflow occurs in Timer/Counter2. TOV2 is cleared by hardware when executing the
        corresponding interrupt handling vector. Alternatively, TOV2 is cleared by writing a logic one to the flag. When the SREG I-
        bit, TOIE2A (Timer/Counter2 Overflow Interrupt Enable), and TOV2 are set (one), the Timer/Counter2 overflow interrupt is
        executed. In PWM mode, this bit is set when Timer/Counter2 changes counting direction at 0x00.
5.17.11.8 ASSR – Asynchronous Status Register
                Bit      7       6         5        4           3            2              1          0
             (0xB6)      –     EXCLK      AS2   TCN2UB      OCR2AUB      OCR2BUB      TCR2AUB      TCR2BUB        ASSR
          Read/Write     R      R/W       R/W       R           R            R              R          R
         Initial Value   0       0         0        0           0            0              0          0
        • Bit 7 – RES: Reserved bit
        This bit is reserved and will always read as zero.
        • Bit 6 – EXCLK: Enable External Clock Input
        When EXCLK is written to one, and asynchronous clock is selected, the external clock input buffer is enabled and an
        external clock can be input on timer oscillator 1 (TOSC1) pin instead of a 32kHz crystal. Writing to EXCLK should be done
        before asynchronous operation is selected. Note that the crystal Oscillator will only run when this bit is zero.
        • Bit 5 – AS2: Asynchronous Timer/Counter2
        When AS2 is written to zero, Timer/Counter2 is clocked from the I/O clock, clkI/O. When AS2 is written to one,
        Timer/Counter2 is clocked from a crystal oscillator connected to the timer oscillator 1 (TOSC1) pin. When the value of AS2 is
        changed, the contents of TCNT2, OCR2A, OCR2B, TCCR2A and TCCR2B might be corrupted.
        • Bit 4 – TCN2UB: Timer/Counter2 Update Busy
        When Timer/Counter2 operates asynchronously and TCNT2 is written, this bit becomes set. When TCNT2 has been
        updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCNT2 is
        ready to be updated with a new value.
        • Bit 3 – OCR2AUB: Output Compare Register2 Update Busy
        When Timer/Counter2 operates asynchronously and OCR2A is written, this bit becomes set. When OCR2A has been
        updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that OCR2A is
        ready to be updated with a new value.
                                                                                                ATA6614Q [DATASHEET]                155
                                                                                                               9240I–AUTO–03/16


        • Bit 2 – OCR2BUB: Output Compare Register2 Update Busy
        When Timer/Counter2 operates asynchronously and OCR2B is written, this bit becomes set. When OCR2B has been
        updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that OCR2B is
        ready to be updated with a new value.
        • Bit 1 – TCR2AUB: Timer/Counter Control Register2 Update Busy
        When Timer/Counter2 operates asynchronously and TCCR2A is written, this bit becomes set. When TCCR2A has been
        updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCCR2A
        is ready to be updated with a new value.
        • Bit 0 – TCR2BUB: Timer/Counter Control Register2 Update Busy
        When Timer/Counter2 operates asynchronously and TCCR2B is written, this bit becomes set. When TCCR2B has been
        updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCCR2B
        is ready to be updated with a new value.
        If a write is performed to any of the five Timer/Counter2 registers while its update busy flag is set, the updated value might
        get corrupted and cause an unintentional interrupt to occur.
        The mechanisms for reading TCNT2, OCR2A, OCR2B, TCCR2A and TCCR2B are different. When reading TCNT2, the
        actual timer value is read. When reading OCR2A, OCR2B, TCCR2A and TCCR2B the value in the temporary storage
        register is read.
5.17.11.9 GTCCR – General Timer/Counter Control Register
                Bit         7          6           5         4          3          2         1          0
                                                                                                    PSRSYN
          0x23 (0x43)      TSM         –           –         –          –          –      PSRASY                GTCCR
                                                                                                        C
          Read/Write       R/W         R           R         R          R         R         R/W       R/W
          Initial Value     0          0           0         0          0          0         0          0
        • Bit 1 – PSRASY: Prescaler Reset Timer/Counter2
        When this bit is one, the Timer/Counter2 prescaler will be reset. This bit is normally cleared immediately by hardware. If the
        bit is written when Timer/Counter2 is operating in asynchronous mode, the bit will remain one until the prescaler has been
        reset. The bit will not be cleared by hardware if the TSM bit is set. Refer to the description of the Section • “Bit 7 – TSM:
        Timer/Counter Synchronization Mode” on page 138 for a description of the Timer/Counter synchronization mode.
156     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.18   SPI – Serial Peripheral Interface
5.18.1 Features
        ●      Full-duplex, three-wire synchronous data transfer
        ●      Master or slave operation
        ●      LSB first or MSB first data transfer
        ●      Seven programmable bit rates
        ●      End of transmission interrupt flag
        ●      Write collision flag protection
        ●      Wake-up from idle mode
        ●      Double speed (CK/2) master SPI mode
5.18.2 Overview
       The serial peripheral interface (SPI) allows high-speed synchronous data transfer between the ATmega328P and peripheral
       devices or between several AVR® devices.
       The USART can also be used in master SPI mode, see Section 5.20 “USART in SPI Mode” on page 187. The PRSPI bit in
       Section 5.9.10 “Minimizing Power Consumption” on page 60 must be written to zero to enable SPI module.
       Figure 5-65. SPI Block Diagram(1)
                                                                                                                                                             S                   MISO
                                                                                                                                                             M
                                                      XTAL                                     MSB                                LSB                        M
                                                                                                                                                                                 MOSI
                                                                                                8-bit Shift Register                                         S
                                                                                                 Read Data Buffer                                                    Pin
                                               Divider                                                                                                             Control
                                        /2/4/8/16/32/64/128                                                                                                         Logic
                                                                                                                                       Clock
                                                                      SPI Clock (Master)
                                                      Select                                                                    Clock                        S                   SCK
                                                                                                                                Logic                        M
                                              SPI2X    SPR1   SPR0
                                                                                                                                                                                  SS
                                                                                                                                                            MSTR    SPE   DORD
                                                                                 MSTR
                                                                                 SPE
                                                      SPI Control
                                       WCOL                           SPI2X                                       DORD
                                                                                           8
                                SPIF                                                                 SPIE   SPE          MSTR   CPOL   CPHA   SPR1   SPR0
                                              SPI Status Register                                             SPI Control Register
                                                                                     8           8
                                                                     SPI Interrupt        Internal
                                                                      Request            Data Bus
       Note:     1.   Refer to Table 5-31 on page 89 for SPI pin placement.
                                                                                                                                                            ATA6614Q [DATASHEET]                    157
                                                                                                                                                                                 9240I–AUTO–03/16


    The interconnection between master and slave CPUs with SPI is shown in Figure 5-66 on page 158. The system consists of
    two shift registers, and a master clock generator. The SPI master initiates the communication cycle when pulling low the
    slave select SS pin of the desired slave. master and slave prepare the data to be sent in their respective shift registers, and
    the master generates the required clock pulses on the SCK line to interchange data. Data is always shifted from master to
    slave on the master out – slave in, MOSI, line, and from slave to master on the master in – slave out, MISO, line. After each
    data packet, the master will synchronize the slave by pulling high the slave select, SS, line.
    When configured as a master, the SPI interface has no automatic control of the SS line. This must be handled by user
    software before communication can start. When this is done, writing a byte to the SPI data register starts the SPI clock
    generator, and the hardware shifts the eight bits into the slave. After shifting one byte, the SPI clock generator stops, setting
    the end of transmission flag (SPIF). If the SPI interrupt enable bit (SPIE) in the SPCR register is set, an interrupt is
    requested. The master may continue to shift the next byte by writing it into SPDR, or signal the end of packet by pulling high
    the slave select, SS line. The last incoming byte will be kept in the buffer register for later use.
    When configured as a slave, the SPI interface will remain sleeping with MISO tri-stated as long as the SS pin is driven high.
    In this state, software may update the contents of the SPI data register, SPDR, but the data will not be shifted out by
    incoming clock pulses on the SCK pin until the SS pin is driven low. As one byte has been completely shifted, the end of
    transmission flag, SPIF is set. If the SPI interrupt enable bit, SPIE, in the SPCR register is set, an interrupt is requested. The
    slave may continue to place new data to be sent into SPDR before reading the incoming data. The last incoming byte will be
    kept in the buffer register for later use.
    Figure 5-66. SPI Master-slave Interconnection
                                          MSB     MASTER        LSB MISO   MISO       MSB      SLAVE        LSB
                                             8 Bit Shift Register                        8 Bit Shift Register
                                                                    MOSI   MOSI
                                                                                                              Shift
                                         SPI                        SCK     SCK                               Enable
                                   Clock Generator
                                                                    SS       SS
    The system is single buffered in the transmit direction and double buffered in the receive direction. This means that bytes to
    be transmitted cannot be written to the SPI data register before the entire shift cycle is completed. When receiving data,
    however, a received character must be read from the SPI data register before the next character has been completely
    shifted in. Otherwise, the first byte is lost.
    In SPI slave mode, the control logic will sample the incoming signal of the SCK pin. To ensure correct sampling of the clock
    signal, the minimum low and high periods should be:
    Low periods: Longer than 2 CPU clock cycles.
    High periods: Longer than 2 CPU clock cycles.
    When the SPI is enabled, the data direction of the MOSI, MISO, SCK, and SS pins is overridden according to Table 5-64 on
    page 158. For more details on automatic port overrides, refer to Section 5.13.3 “Alternate Port Functions” on page 87.
    Table 5-64. SPI Pin Overrides(1)
             Pin           Direction, Master SPI                                   Direction, Slave SPI
            MOSI           User Defined                                            Input
            MISO           Input                                                   User Defined
            SCK            User Defined                                            Input
             SS            User Defined                                            Input
    Note:      1.   See Section 5.13.3.1 “Alternate Functions of Port B” on page 89 for a detailed description of how to define the
                    direction of the user defined SPI pins.
158 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


The following code examples show how to initialize the SPI as a master and how to perform a simple transmission.
DDR_SPI in the examples must be replaced by the actual data direction register controlling the SPI pins. DD_MOSI,
DD_MISO and DD_SCK must be replaced by the actual data direction bits for these pins. E.g. if MOSI is placed on pin PB5,
replace DD_MOSI with DDB5 and DDR_SPI with DDRB.
 Assembly Code Example(1)
          SPI_MasterInit:
                  ; Set MOSI and SCK output, all others input
                  ldi     r17,(1<<DD_MOSI)|(1<<DD_SCK)
                  out     DDR_SPI,r17
                  ; Enable SPI, Master, set clock rate fck/16
                  ldi     r17,(1<<SPE)|(1<<MSTR)|(1<<SPR0)
                  out     SPCR,r17
                  ret
          SPI_MasterTransmit:
                  ; Start transmission of data (r16)
                  out     SPDR,r16
          Wait_Transmit:
                  ; Wait for transmission complete
                  in      r16, SPSR
                  sbrs    r16, SPIF
                  rjmp    Wait_Transmit
                  ret
 C Code Example(1)
          void SPI_MasterInit(void)
          {
                  /* Set MOSI and SCK output, all others input */
                  DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
                  /* Enable SPI, Master, set clock rate fck/16 */
                  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
          }
          void SPI_MasterTransmit(char cData)
          {
                  /* Start transmission */
                  SPDR = cData;
                  /* Wait for transmission complete */
                  while(!(SPSR & (1<<SPIF)))
                          ;
          }
Note:    1.  See Section 5.5 “About Code Examples” on page 32.
                                                                                  ATA6614Q [DATASHEET]               159
                                                                                                 9240I–AUTO–03/16


    The following code examples show how to initialize the SPI as a Slave and how to perform a simple reception.
     Assembly Code Example(1)
              SPI_SlaveInit:
                      ; Set MISO output, all others input
                      ldi      r17,(1<<DD_MISO)
                      out      DDR_SPI,r17
                      ; Enable SPI
                      ldi      r17,(1<<SPE)
                      out      SPCR,r17
                      ret
              SPI_SlaveReceive:
                      ; Wait for reception complete
                      sbis     SPSR,SPIF
                      rjmp     SPI_SlaveReceive
                      ; Read received data and return
                      in       r16,SPDR
                      ret
     C Code Example(1)
              void SPI_SlaveInit(void)
              {
                      /* Set MISO output, all others input */
                      DDR_SPI = (1<<DD_MISO);
                      /* Enable SPI */
                      SPCR = (1<<SPE);
              }
              char SPI_SlaveReceive(void)
              {
                      /* Wait for reception complete */
                      while(!(SPSR & (1<<SPIF)))
                               ;
                      /* Return Data Register */
                      return SPDR;
              }
    Note:    1.   See Section 5.5 “About Code Examples” on page 32.
160 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.18.3 SS Pin Functionality
5.18.3.1 Slave Mode
        When the SPI is configured as a slave, the slave select (SS) pin is always input. When SS is held low, the SPI is activated,
        and MISO becomes an output if configured so by the user. All other pins are inputs. When SS is driven high, all pins are
        inputs, and the SPI is passive, which means that it will not receive incoming data. Note that the SPI logic will be reset once
        the SS pin is driven high.
        The SS pin is useful for packet/byte synchronization to keep the slave bit counter synchronous with the master clock
        generator. When the SS pin is driven high, the SPI slave will immediately reset the send and receive logic, and drop any
        partially received data in the shift register.
5.18.3.2Master Mode
        When the SPI is configured as a master (MSTR in SPCR is set), the user can determine the direction of the SS pin.
        If SS is configured as an output, the pin is a general output pin which does not affect the SPI system. Typically, the pin will be
        driving the SS pin of the SPI slave.
        If SS is configured as an input, it must be held high to ensure master SPI operation. If the SS pin is driven low by peripheral
        circuitry when the SPI is configured as a master with the SS pin defined as an input, the SPI system interprets this as
        another master selecting the SPI as a slave and starting to send data to it. To avoid bus contention, the SPI system takes the
        following actions:
           1. The MSTR bit in SPCR is cleared and the SPI system becomes a slave. As a result of the SPI becoming a slave,
                the MOSI and SCK pins become inputs.
           2.   The SPIF flag in SPSR is set, and if the SPI interrupt is enabled, and the I-bit in SREG is set, the interrupt routine
                will be executed.
        Thus, when interrupt-driven SPI transmission is used in master mode, and there exists a possibility that SS is driven low, the
        interrupt should always check that the MSTR bit is still set. If the MSTR bit has been cleared by a slave select, it must be set
        by the user to re-enable SPI master mode.
5.18.4 Data Modes
        There are four combinations of SCK phase and polarity with respect to serial data, which are determined by control bits
        CPHA and CPOL. The SPI data transfer formats are shown in Figure 5-67 and Figure 5-68 on page 162. Data bits are
        shifted out and latched in on opposite edges of the SCK signal, ensuring sufficient time for data signals to stabilize. This is
        clearly seen by summarizing Table 5-66 on page 163 and Table 5-67 on page 163, as done in Table 5-65.
        Table 5-65. SPI Modes
               SPI Mode                       Conditions                       Leading Edge                       Trailing eDge
                     0                   CPOL=0, CPHA=0                        Sample (rising)                    Setup (falling)
                     1                   CPOL=0, CPHA=1                         Setup (rising)                   Sample (falling)
                     2                   CPOL=1, CPHA=0                        Sample (falling)                   Setup (rising)
                     3                   CPOL=1, CPHA=1                         Setup (falling)                  Sample (rising)
                                                                                                  ATA6614Q [DATASHEET]                161
                                                                                                               9240I–AUTO–03/16


    Figure 5-67. SPI Transfer Format with CPHA = 0
                     SCK (CPOL = 0)
                     mode 0
                     SCK (CPOL = 1)
                     mode 2
                     SAMPLE I
                     MOSI/MISO
                     CHANGE 0
                     MOSI PIN
                     CHANGE 0
                     MISO PIN
                     SS
                     MSB first (DORD = 0) MSB     Bit 6       Bit 5       Bit 4       Bit 3       Bit 2       Bit 1       LSB
                     LSB first (DORD =1) LSB      Bit 1       Bit 2       Bit 3       Bit 4       Bit 5       Bit 6       MSB
    Figure 5-68. SPI Transfer Format with CPHA = 1
                     SCK (CPOL = 0)
                     mode 1
                     SCK (CPOL = 1)
                     mode 3
                     SAMPLE I
                     MOSI/MISO
                     CHANGE 0
                     MOSI PIN
                     CHANGE 0
                     MISO PIN
                     SS
                       MSB first (DORD = 0)   MSB       Bit 6       Bit 5       Bit 4       Bit 3       Bit 2       Bit 1     LSB
                       LSB first (DORD =1)    LSB       Bit 1       Bit 2       Bit 3       Bit 4       Bit 5       Bit 6     MSB
162 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.18.5 Register Description
5.18.5.1 SPCR – SPI Control Register
                 Bit         7         6         5          4          3        2          1          0
          0x2C (0x4C)      SPIE       SPE      DORD     MSTR        CPOL      CPHA      SPR1       SPR0         SPCR
           Read/Write      R/W        R/W       R/W       R/W         R/W      R/W       R/W        R/W
           Initial Value     0         0         0          0          0        0          0          0
        • Bit 7 – SPIE: SPI Interrupt Enable
        This bit causes the SPI interrupt to be executed if SPIF bit in the SPSR register is set and the if the global interrupt enable bit
        in SREG is set.
        • Bit 6 – SPE: SPI Enable
        When the SPE bit is written to one, the SPI is enabled. This bit must be set to enable any SPI operations.
        • Bit 5 – DORD: Data Order
        When the DORD bit is written to one, the LSB of the data word is transmitted first.
        When the DORD bit is written to zero, the MSB of the data word is transmitted first.
        • Bit 4 – MSTR: Master/Slave Select
        This bit selects master SPI mode when written to one, and Slave SPI mode when written logic zero. If SS is configured as an
        input and is driven low while MSTR is set, MSTR will be cleared, and SPIF in SPSR will become set. The user will then have
        to set MSTR to re-enable SPI Master mode.
        • Bit 3 – CPOL: Clock Polarity
        When this bit is written to one, SCK is high when idle. When CPOL is written to zero, SCK is low when idle. Refer to Figure
        5-67 and Figure 5-68 for an example. The CPOL functionality is summarized below:
        Table 5-66. CPOL Functionality
                          CPOL                                Leading Edge                                  Trailing Edge
                             0                                    Rising                                        Falling
                             1                                    Falling                                       Rising
        • Bit 2 – CPHA: Clock Phase
        The settings of the clock phase bit (CPHA) determine if data is sampled on the leading (first) or trailing (last) edge of SCK.
        Refer to Figure 5-67 and Figure 5-68 for an example. The CPOL functionality is summarized below:
        Table 5-67. CPHA Functionality
                          CPHA                                Leading Edge                                  Trailing Edge
                             0                                    Sample                                        Setup
                             1                                     Setup                                       Sample
        • Bits 1, 0 – SPR1, SPR0: SPI Clock Rate Select 1 and 0
        These two bits control the SCK rate of the device configured as a master. SPR1 and SPR0 have no effect on the slave.
                                                                                                 ATA6614Q [DATASHEET]                 163
                                                                                                                9240I–AUTO–03/16


        The relationship between SCK and the Oscillator Clock frequency fosc is shown in the following table:
        Table 5-68. Relationship Between SCK and the Oscillator Frequency
                      SPI2X                  SPR1                     SPR0            SCK Frequency
                         0                      0                        0            fosc/4
                         0                      0                        1            fosc/16
                         0                      1                        0            fosc/64
                         0                      1                        1            fosc/128
                         1                      0                        0            fosc/2
                         1                      0                        1            fosc/8
                         1                      1                        0            fosc/32
                         1                      1                        1            fosc/64
5.18.5.2 SPSR – SPI Status Register
                  Bit          7         6        5         4          3          2         1          0
           0x2D (0x4D)       SPIF     WCOL        –         –          –          –         –       SPI2X      SPSR
            Read/Write        R          R        R         R          R          R        R         R/W
            Initial Value      0         0        0         0          0          0         0          0
        • Bit 7 – SPIF: SPI Interrupt Flag
        When a serial transfer is complete, the SPIF flag is set. An interrupt is generated if SPIE in SPCR is set and global interrupts
        are enabled. If SS is an input and is driven low when the SPI is in master mode, this will also set the SPIF flag. SPIF is
        cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by
        first reading the SPI status register with SPIF set, then accessing the SPI data register (SPDR).
        • Bit 6 – WCOL: Write COLlision Flag
        The WCOL bit is set if the SPI data register (SPDR) is written during a data transfer. The WCOL bit (and the SPIF bit) are
        cleared by first reading the SPI status register with WCOL set, and then accessing the SPI data register.
        • Bit 5..1 – Res: Reserved Bits
        These bits are reserved bits in the ATmega328P and will always read as zero.
        • Bit 0 – SPI2X: Double SPI Speed Bit
        When this bit is written logic one the SPI speed (SCK frequency) will be doubled when the SPI is in master mode (see
        Table 5-68). This means that the minimum SCK period will be two CPU clock periods. When the SPI is configured as slave,
        the SPI is only guaranteed to work at fosc/4 or lower.
        The SPI interface on the ATmega328P is also used for program memory and EEPROM downloading or uploading. See
        Section 5.27.8 “Serial Downloading” on page 274 for serial programming and verification.
5.18.5.3 SPDR – SPI Data Register
                  Bit         7          6        5         4          3         2         1          0
           0x2E (0x4E)       MSB                                                                    LSB        SPDR
            Read/Write       R/W       R/W       R/W      R/W        R/W        R/W      R/W        R/W
            Initial Value     X          X        X         X          X         X         X          X      Undefined
        The SPI data register is a read/write register used for data transfer between the register file and the SPI shift register. Writing
        to the register initiates data transmission. Reading the register causes the shift register receive buffer to be read.
164     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19   USART0
5.19.1 Features
         ●     Full duplex operation (independent serial receive and transmit registers)
         ●     Asynchronous or synchronous operation
         ●     Master or slave clocked synchronous operation
         ●     High resolution baud rate generator
         ●     Supports serial frames with 5, 6, 7, 8, or 9 data bits and 1 or 2 stop bits
         ●     Odd or even parity generation and parity check supported by hardware
         ●     Data OverRun detection
         ●     Framing error detection
         ●     Noise filtering includes false start bit detection and digital low pass filter
         ●     Three separate interrupts on TX complete, TX data register empty and RX complete
         ●     Multi-processor communication mode
         ●     Double speed asynchronous communication mode
5.19.2 Overview
       The universal synchronous and asynchronous serial receiver and transmitter (USART) is a highly flexible serial
       communication device.
       The USART0 can also be used in master SPI mode, see Section 5.20 “USART in SPI Mode” on page 187. The power
       reduction USART bit, PRUSART0, in Section 5.9.10 “Minimizing Power Consumption” on page 60 must be disabled by
       writing a logical zero to it.
       A simplified block diagram of the USART transmitter is shown in Figure 5-69 on page 166. CPU accessible I/O registers and
       I/O pins are shown in bold.
       The dashed boxes in the block diagram separate the three main parts of the USART (listed from the top): Clock generator,
       transmitter and receiver. Control registers are shared by all units. The clock generation logic consists of synchronization
       logic for external clock input used by synchronous slave operation, and the baud rate generator. The XCKn (transfer clock)
       pin is only used by synchronous transfer mode. The transmitter consists of a single write buffer, a serial shift register, parity
       generator and control logic for handling different serial frame formats. The write buffer allows a continuous transfer of data
       without any delay between frames. The receiver is the most complex part of the USART module due to its clock and data
       recovery units. The recovery units are used for asynchronous data reception. In addition to the recovery units, the receiver
       includes a parity checker, control logic, a shift register and a two level receive buffer (UDRn). The receiver supports the
       same frame formats as the transmitter, and can detect frame error, data OverRun and parity errors.
                                                                                                 ATA6614Q [DATASHEET]               165
                                                                                                              9240I–AUTO–03/16


      Figure 5-69. USART Block Diagram(1)
                                                                                     Clock Generator
                                                   UBRRn[H:L]
                                                                          OSC
                                             Baud Rate Generator
                                                                        Sync Logic       Pin
                                                                                                           XCKn
                                                                                        Control
                                                                                         Transmitter
                                                                                         TX
                                                 UDRn (Transmit)
                                                                                        Control
                                                                         Parity
                                                                        Generator
                         DATA BUS
                                                                                         Pin
                                             Transmit Shift Register                                       TxDn
                                                                                        Control
                                                                                            Receiver
                                                                         Clock           RX
                                                                        Recovery        Control
                                                                          Data           Pin
                                             Receive Shift Register                                        RxDn
                                                                        Recovery        Control
                                                                          Parity
                                                 UDRn (Receive)
                                                                         Checker
                                        UCSRnA                         UCSRnB                     UCSRnC
      Note:    1.   Refer to Table 5-37 on page 94 for USART0 pin placement.
166   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.19.3 Clock Generation
        The clock generation logic generates the base clock for the transmitter and receiver. The USART supports four modes of
        clock operation: normal asynchronous, double speed asynchronous, master synchronous and slave synchronous mode.
        The UMSELn bit in USART control and status register C (UCSRnC) selects between asynchronous and synchronous
        operation. Double speed (asynchronous mode only) is controlled by the U2Xn found in the UCSRnA register. When using
        synchronous mode (UMSELn = 1), the data direction register for the XCKn pin (DDR_XCKn) controls whether the clock
        source is internal (master mode) or external (slave mode). The XCKn pin is only active when using synchronous mode.
        Figure 5-70 shows a block diagram of the clock generation logic.
        Figure 5-70. Clock Generation Logic, Block Diagram
                                            UBRRn
                                                          foscn                                   U2Xn
                                           Prescaling   UBRRn+1
                                         Down-counter                /2        /4        /2
                                                                                                   0
                                                                                                   1
                                       OSC                                                                  0
                                                                                                                   txclk
                                                                                              DDR_XCKn      1
                                             Sync             Edge
                                  xcki      Register        Detector                               0
                         XCKn                                                                                    UMSELn
                                 xcko                                                              1
                          Pin
                                                                                                            1
                       DDR_XCKn                             UCPOLn                                                 rxclk
                                                                                                            0
        Signal description:
               txclk     Transmitter clock (internal signal).
               rxclk     Receiver base clock (internal signal).
               xcki      Input from XCK pin (internal signal). Used for synchronous slave operation.
               xcko      Clock output to XCK pin (internal signal). Used for synchronous master operation.
               fosc      XTAL pin frequency (system clock).
5.19.3.1 Internal Clock Generation – The Baud Rate Generator
        Internal clock generation is used for the asynchronous and the synchronous master modes of operation. The description in
        this section refers to Figure 5-70.
        The USART baud rate register (UBRRn) and the down-counter connected to it function as a programmable prescaler or
        baud rate generator. The down-counter, running at system clock (fosc), is loaded with the UBRRn value each time the
        counter has counted down to zero or when the UBRRnL register is written. A clock is generated each time the counter
        reaches zero. This clock is the baud rate generator clock output (= fosc/(UBRRn+1)). The transmitter divides the baud rate
        generator clock output by 2, 8 or 16 depending on mode. The baud rate generator output is used directly by the receiver’s
        clock and data recovery units. However, the recovery units use a state machine that uses 2, 8 or 16 states depending on
        mode set by the state of the UMSELn, U2Xn and DDR_XCKn bits.
                                                                                             ATA6614Q [DATASHEET]               167
                                                                                                           9240I–AUTO–03/16


        Table 5-69 contains equations for calculating the baud rate (in bits per second) and for calculating the UBRRn value for each
        mode of operation using an internally generated clock source.
        Table 5-69. Equations for Calculating Baud Rate Register Setting
                                                           Equation for Calculating Baud                  Equation for Calculating UBRRn
          Operating Mode                                                  Rate(1)                                         Value
          Asynchronous Normal mode (U2Xn =                                    f OSC                                    f OSC
          0)                                            BAUD = ----------------------------------------- UBRRn = ----------------------- – 1
                                                                    16  UBRRn + 1                                 16BAUD
          Asynchronous Double Speed mode                                    f OSC                                    f OSC
          (U2Xn = 1)                                    BAUD = --------------------------------------    UBRRn = -------------------- – 1
                                                                    8  UBRRn + 1                                  8BAUD
          Synchronous Master mode
                                                                            f OSC                                    f OSC
                                                        BAUD = --------------------------------------    UBRRn = -------------------- – 1
                                                                    2  UBRRn + 1                                  2BAUD
          Note:      1.     The baud rate is defined to be the transfer rate in bit per second (bps)
                BAUD         Baud rate (in bits per second, bps)
                fOSC         System oscillator clock frequency
                UBRRn Contents of the UBRRnH and UBRRnL registers, (0-4095)
        Some examples of UBRRn values for some system clock frequencies are found in Table 5-77 (see 185).
5.19.3.2 Double Speed Operation (U2Xn)
        The transfer rate can be doubled by setting the U2Xn bit in UCSRnA. Setting this bit only has effect for the asynchronous
        operation. Set this bit to zero when using synchronous operation.
        Setting this bit will reduce the divisor of the baud rate divider from 16 to 8, effectively doubling the transfer rate for
        asynchronous communication. Note however that the receiver will in this case only use half the number of samples (reduced
        from 16 to 8) for data sampling and clock recovery, and therefore a more accurate baud rate setting and system clock are
        required when this mode is used. For the transmitter, there are no downsides.
5.19.3.3 External Clock
        External clocking is used by the synchronous slave modes of operation. The description in this section refers to Figure 5-70
        for details.
        External clock input from the XCKn pin is sampled by a synchronization register to minimize the chance of meta-stability.
        The output from the synchronization register must then pass through an edge detector before it can be used by the
        transmitter and receiver. This process introduces a two CPU clock period delay and therefore the maximum external XCKn
        clock frequency is limited by the following equation:
                 f OSC
        f XCK  -----------
                    4
        Note that fosc depends on the stability of the system clock source. It is therefore recommended to add some margin to avoid
        possible loss of data due to frequency variations.
168     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19.3.4 Synchronous Clock Operation
        When synchronous mode is used (UMSELn = 1), the XCKn pin will be used as either clock input (slave) or clock output
        (master). The dependency between the clock edges and data sampling or data change is the same. The basic principle is
        that data input (on RxDn) is sampled at the opposite XCKn clock edge of the edge the data output (TxDn) is changed.
        Figure 5-71. Synchronous Mode XCKn Timing
                                UCPOL = 1      XCK
                                           RxD/TxD
                                                                                             Sample
                                UCPOL = 0      XCK
                                           RxD/TxD
                                                                                             Sample
        The UCPOLn bit UCRSC selects which XCKn clock edge is used for data sampling and which is used for data change. As
        Figure 5-71 shows, when UCPOLn is zero the data will be changed at rising XCKn edge and sampled at falling XCKn edge.
        If UCPOLn is set, the data will be changed at falling XCKn edge and sampled at rising XCKn edge.
5.19.4 Frame Formats
        A serial frame is defined to be one character of data bits with synchronization bits (start and stop bits), and optionally a parity
        bit for error checking. The USART accepts all 30 combinations of the following as valid frame formats:
           ● 1 start bit
           ●    5, 6, 7, 8, or 9 data bits
           ●    no, even or odd parity bit
           ●    1 or 2 stop bits
        A frame starts with the start bit followed by the least significant data bit. Then the next data bits, up to a total of nine, are
        succeeding, ending with the most significant bit. If enabled, the parity bit is inserted after the data bits, before the stop bits.
        When a complete frame is transmitted, it can be directly followed by a new frame, or the communication line can be set to an
        idle (high) state. Figure 5-72 illustrates the possible combinations of the frame formats. Bits inside brackets are optional.
        Figure 5-72. Frame Formats
                                                                     FRAME
                                  (IDLE)    ST    0    1   2    3   4   [5]  [6] [7]   [8] [P] Sp1 [Sp2]   (St/IDLE)
                St        Start bit, always low.
                (n)       Data bits (0 to 8).
                P         Parity bit. Can be odd or even.
                Sp        Stop bit, always high.
                IDLE      No transfers on the communication line (RxDn or TxDn). An IDLE line must be high.
                                                                                                  ATA6614Q [DATASHEET]                   169
                                                                                                                  9240I–AUTO–03/16


        The frame format used by the USART is set by the UCSZn2:0, UPMn1:0 and USBSn bits in UCSRnB and UCSRnC. The
        receiver and transmitter use the same setting. Note that changing the setting of any of these bits will corrupt all ongoing
        communication for both the receiver and transmitter.
        The USART character SiZe (UCSZn2:0) bits select the number of data bits in the frame. The USART parity mode (UPMn1:0)
        bits enable and set the type of parity bit. The selection between one or two stop bits is done by the USART stop bit select
        (USBSn) bit. The receiver ignores the second stop bit. An FE (frame error) will therefore only be detected in the cases where
        the first stop bit is zero.
5.19.4.1 Parity Bit Calculation
        The parity bit is calculated by doing an exclusive-or of all the data bits. If odd parity is used, the result of the exclusive or is
        inverted. The relation between the parity bit and data bits is as follows:
         P even = d n – 1    d 3  d 2  d 1  d 0  0
          P odd = d n – 1    d 3  d 2  d 1  d 0  1
                Peven      Parity bit using even parity
                P odd
                           Parity bit using odd parity
                dn         Data bit n of the character
        If used, the parity bit is located between the last data bit and first stop bit of a serial frame.
170     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19.5 USART Initialization
       The USART has to be initialized before any communication can take place. The initialization process normally consists of
       setting the baud rate, setting frame format and enabling the transmitter or the receiver depending on the usage. For interrupt
       driven USART operation, the global interrupt flag should be cleared (and interrupts globally disabled) when doing the
       initialization.
       Before doing a re-initialization with changed baud rate or frame format, be sure that there are no ongoing transmissions
       during the period the registers are changed. The TXCn flag can be used to check that the transmitter has completed all
       transfers, and the RXC flag can be used to check that there are no unread data in the receive buffer. Note that the TXCn flag
       must be cleared before each transmission (before UDRn is written) if it is used for this purpose.
       The following simple USART initialization code examples show one assembly and one C function that are equal in
       functionality. The examples assume asynchronous operation using polling (no interrupts enabled) and a fixed frame format.
       The baud rate is given as a function parameter. For the assembly code, the baud rate parameter is assumed to be stored in
       the r17:r16 registers.
        Assembly Code Example(1)
                    USART_Init:
                            ; Set baud rate
                            out       UBRRnH, r17
                            out       UBRRnL, r16
                            ; Enable receiver and transmitter
                            ldi       r16, (1<<RXENn)|(1<<TXENn)
                            out       UCSRnB,r16
                            ; Set frame format: 8data, 2stop bit
                            ldi       r16, (1<<USBSn)|(3<<UCSZn0)
                            out       UCSRnC,r16
                            ret
        C Code Example(1)
                    #define FOSC 1843200 // Clock Speed
                    #define BAUD 9600
                    #define MYUBRR FOSC/16/BAUD-1
                    void main( void )
                    {
                    ...
                            USART_Init(MYUBRR)
                    ...
                    }
                    void USART_Init( unsigned int ubrr)
                    {
                            /*Set baud rate */
                            UBRR0H = (unsigned char)(ubrr>>8);
                            UBRR0L = (unsigned char)ubrr;
                            Enable receiver and transmitter */
                            UCSR0B = (1<<RXEN0)|(1<<TXEN0);
                            /* Set frame format: 8data, 2stop bit */
                            UCSR0C = (1<<USBS0)|(3<<UCSZ00);
                    }
       Note:       1.  See Section 5.5 “About Code Examples” on page 32.
       More advanced initialization routines can be made that include frame format as parameters, disable interrupts and so on.
       However, many applications use a fixed setting of the baud and control registers, and for these types of applications the
       initialization code can be placed directly in the main routine, or be combined with initialization code for other I/O modules.
                                                                                                ATA6614Q [DATASHEET]               171
                                                                                                              9240I–AUTO–03/16


5.19.6 Data Transmission – The USART Transmitter
        The USART transmitter is enabled by setting the Transmit Enable (TXEN) bit in the UCSRnB register. When the transmitter
        is enabled, the normal port operation of the TxDn pin is overridden by the USART and given the function as the transmitter’s
        serial output. The baud rate, mode of operation and frame format must be set up once before doing any transmissions. If
        synchronous operation is used, the clock on the XCKn pin will be overridden and used as transmission clock.
5.19.6.1 Sending Frames with 5 to 8 Data Bit
        A data transmission is initiated by loading the transmit buffer with the data to be transmitted. The CPU can load the transmit
        buffer by writing to the UDRn I/O location. The buffered data in the transmit buffer will be moved to the shift register when the
        Shift register is ready to send a new frame. The shift register is loaded with new data if it is in idle state (no ongoing
        transmission) or immediately after the last stop bit of the previous frame is transmitted. When the shift register is loaded with
        new data, it will transfer one complete frame at the rate given by the baud register, U2Xn bit or by XCKn depending on mode
        of operation.
        The following code examples show a simple USART transmit function based on polling of the Data Register Empty (UDREn)
        flag. When using frames with less than eight bits, the most significant bits written to the UDRn are ignored. The USART has
        to be initialized before the function can be used. For the assembly code, the data to be sent is assumed to be stored in
        register R16.
         Assembly Code Example(1)
                    USART_Transmit:
                             ; Wait for empty transmit buffer
                             sbis      UCSRnA,UDREn
                             rjmp      USART_Transmit
                             ; Put data (r16) into buffer, sends the data
                             out       UDRn,r16
                             ret
         C Code Example(1)
                    void USART_Transmit( unsigned char data )
                    {
                             /* Wait for empty transmit buffer */
                             while ( !( UCSRnA & (1<<UDREn)) )
                                                         ;
                             /* Put data into buffer, sends the data */
                             UDRn = data;
                    }
        Note:      1.   See Section 5.5 “About Code Examples” on page 32.
        The function simply waits for the transmit buffer to be empty by checking the UDREn Flag, before loading it with new data to
        be transmitted. If the data register empty interrupt is utilized, the interrupt routine writes the data into the buffer.
172     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19.6.2 Sending Frames with 9 Data Bit
        If 9-bit characters are used (UCSZn = 7), the ninth bit must be written to the TXB8 bit in UCSRnB before the low byte of the
        character is written to UDRn. The following code examples show a transmit function that handles 9-bit characters. For the
        assembly code, the data to be sent is assumed to be stored in registers R17:R16.
         Assembly Code Example(1)(2)
                    USART_Transmit:
                             ; Wait for empty transmit buffer
                             sbis      UCSRnA,UDREn
                             rjmp      USART_Transmit
                             ; Copy 9th bit from r17 to TXB8
                             cbi       UCSRnB,TXB8
                             sbrc      r17,0
                             sbi       UCSRnB,TXB8
                             ; Put LSB data (r16) into buffer, sends the data
                             out       UDRn,r16
                             ret
         C Code Example(1)(2)
                    void USART_Transmit( unsigned int data )
                    {
                             /* Wait for empty transmit buffer */
                             while ( !( UCSRnA & (1<<UDREn))) )
                             ;
                             /* Copy 9th bit to TXB8 */
                             UCSRnB &= ~(1<<TXB8);
                             if ( data & 0x0100 )
                                       UCSRnB |= (1<<TXB8);
                             /* Put data into buffer, sends the data */
                             UDRn = data;
                    }
        Notes:     1.   These transmit functions are written to be general functions. They can be optimized if the contents of the UCS-
                        RnB is static. For example, only the TXB8 bit of the UCSRnB register is used after initialization.
                   2.   See Section 5.5 “About Code Examples” on page 32.
        The ninth bit can be used for indicating an address frame when using multi processor communication mode or for other
        protocol handling as for example synchronization.
5.19.6.3 Transmitter Flags and Interrupts
        The USART transmitter has two flags that indicate its state: USART data register empty (UDREn) and transmit complete
        (TXCn). Both flags can be used for generating interrupts.
        The data register empty (UDREn) flag indicates whether the transmit buffer is ready to receive new data. This bit is set when
        the transmit buffer is empty, and cleared when the transmit buffer contains data to be transmitted that has not yet been
        moved into the shift register. For compatibility with future devices, always write this bit to zero when writing the UCSRnA
        register.
        When the data register empty interrupt enable (UDRIEn) bit in UCSRnB is written to one, the USART data register empty
        Interrupt will be executed as long as UDREn is set (provided that global interrupts are enabled). UDREn is cleared by writing
        UDRn. When interrupt-driven data transmission is used, the data register empty interrupt routine must either write new data
        to UDRn in order to clear UDREn or disable the data register empty interrupt, otherwise a new interrupt will occur once the
        interrupt routine terminates.
        The transmit complete (TXCn) flag bit is set one when the entire frame in the transmit shift register has been shifted out and
        there are no new data currently present in the transmit buffer. The TXCn flag bit is automatically cleared when a transmit
        complete interrupt is executed, or it can be cleared by writing a one to its bit location. The TXCn flag is useful in half-duplex
        communication interfaces (like the RS-485 standard), where a transmitting application must enter receive mode and free the
        communication bus immediately after completing the transmission.
                                                                                                  ATA6614Q [DATASHEET]                173
                                                                                                               9240I–AUTO–03/16


        When the transmit compete interrupt enable (TXCIEn) bit in UCSRnB is set, the USART transmit complete interrupt will be
        executed when the TXCn flag becomes set (provided that global interrupts are enabled). When the transmit complete
        interrupt is used, the interrupt handling routine does not have to clear the TXCn flag, this is done automatically when the
        interrupt is executed.
5.19.6.4 Parity Generator
        The parity generator calculates the parity bit for the serial frame data. When parity bit is enabled (UPMn1 = 1), the
        transmitter control logic inserts the parity bit between the last data bit and the first stop bit of the frame that is sent.
5.19.6.5 Disabling the Transmitter
        The disabling of the transmitter (setting the TXEN to zero) will not become effective until ongoing and pending transmissions
        are completed, i.e., when the transmit shift register and transmit buffer register do not contain data to be transmitted. When
        disabled, the transmitter will no longer override the TxDn pin.
5.19.7 Data Reception – The USART Receiver
        The USART receiver is enabled by writing the receive enable (RXENn) bit in the UCSRnB register to one. When the receiver
        is enabled, the normal pin operation of the RxDn pin is overridden by the USART and given the function as the receiver’s
        serial input. The baud rate, mode of operation and frame format must be set up once before any serial reception can be
        done. If synchronous operation is used, the clock on the XCKn pin will be used as transfer clock.
5.19.7.1 Receiving Frames with 5 to 8 Data Bits
        The receiver starts data reception when it detects a valid start bit. Each bit that follows the start bit will be sampled at the
        baud rate or XCKn clock, and shifted into the receive shift register until the first stop bit of a frame is received. A second stop
        bit will be ignored by the receiver. When the first stop bit is received, i.e., a complete serial frame is present in the receive
        shift register, the contents of the shift register will be moved into the receive buffer. The receive buffer can then be read by
        reading the UDRn I/O location.
        The following code example shows a simple USART receive function based on polling of the Receive Complete (RXCn)
        Flag. When using frames with less than eight bits the most significant bits of the data read from the UDRn will be masked to
        zero. The USART has to be initialized before the function can be used.
         Assembly Code Example(1)
                    USART_Receive:
                              ; Wait for data to be received
                              sbis     UCSRnA, RXCn
                              rjmp     USART_Receive
                              ; Get and return received data from buffer
                              in       r16, UDRn
                              ret
         C Code Example(1)
                    unsigned char USART_Receive( void )
                    {
                              /* Wait for data to be received */
                              while ( !(UCSRnA & (1<<RXCn)) )
                              ;
                              /* Get and return received data from buffer */
                              return UDRn;
                    }
        Note:      1.   See Section 5.5 “About Code Examples” on page 32.
                        For I/O registers located in extended I/O map, “IN”, “OUT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must
                        be replaced with instructions that allow access to extended I/O. Typically “LDS” and “STS” combined with
                        “SBRS”, “SBRC”, “SBR”, and “CBR”.
        The function simply waits for data to be present in the receive buffer by checking the RXCn flag, before reading the buffer
        and returning the value.
174     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19.7.2 Receiving Frames with 9 Data Bits
        If 9-bit characters are used (UCSZn=7) the ninth bit must be read from the RXB8n bit in UCSRnB before reading the low bits
        from the UDRn. This rule applies to the FEn, DORn and UPEn status flags as well. Read status from UCSRnA, then data
        from UDRn. Reading the UDRn I/O location will change the state of the receive buffer FIFO and consequently the TXB8n,
        FEn, DORn and UPEn bits, which all are stored in the FIFO, will change.
        The following code example shows a simple USART receive function that handles both nine bit characters and the status
        bits.
         Assembly Code Example(1)
                    USART_Receive:
                             ; Wait for data to be received
                             sbis     UCSRnA, RXCn
                             rjmp     USART_Receive
                             ; Get status and 9th bit, then data from buffer
                             in       r18, UCSRnA
                             in       r17, UCSRnB
                             in       r16, UDRn
                             ; If error, return -1
                             andi     r18,(1<<FEn)|(1<<DORn)|(1<<UPEn)
                             breq     USART_ReceiveNoError
                             ldi      r17, HIGH(-1)
                             ldi      r16, LOW(-1)
                    USART_ReceiveNoError:
                             ; Filter the 9th bit, then return
                             lsr      r17
                             andi     r17, 0x01
                             ret
         C Code Example(1)
                    unsigned int USART_Receive( void )
                    {
                             unsigned char status, resh, resl;
                             /* Wait for data to be received */
                             while ( !(UCSRnA & (1<<RXCn)) )
                             ;
                             /* Get status and 9th bit, then data */
                             /* from buffer */
                             status = UCSRnA;
                             resh = UCSRnB;
                             resl = UDRn;
                             /* If error, return -1 */
                             if ( status & (1<<FEn)|(1<<DORn)|(1<<UPEn) )
                             return -1;
                             /* Filter the 9th bit, then return */
                             resh = (resh >> 1) & 0x01;
                             return ((resh << 8) | resl);
                    }
        Note:      1.  See Section 5.5 “About Code Examples” on page 32.
                       For I/O Registers located in extended I/O map, “IN”, “OUT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must
                       be replaced with instructions that allow access to extended I/O. Typically “LDS” and “STS” combined with
                       “SBRS”, “SBRC”, “SBR”, and “CBR”.
        The receive function example reads all the I/O registers into the register file before any computation is done. This gives an
        optimal receive buffer utilization since the buffer location read will be free to accept new data as early as possible.
                                                                                                  ATA6614Q [DATASHEET]             175
                                                                                                               9240I–AUTO–03/16


5.19.7.3 Receive Compete Flag and Interrupt
        The USART receiver has one flag that indicates the Receiver state.
        The receive complete (RXCn) flag indicates if there are unread data present in the receive buffer. This flag is one when
        unread data exist in the receive buffer, and zero when the receive buffer is empty (i.e., does not contain any unread data). If
        the receiver is disabled (RXENn = 0), the receive buffer will be flushed and consequently the RXCn bit will become zero.
        When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be
        executed as long as the RXCn flag is set (provided that global interrupts are enabled). When interrupt-driven data reception
        is used, the receive complete routine must read the received data from UDRn in order to clear the RXCn Flag, otherwise a
        new interrupt will occur once the interrupt routine terminates.
5.19.7.4 Receiver Error Flags
        The USART receiver has three error flags: frame error (FEn), data OverRun (DORn) and parity error (UPEn). All can be
        accessed by reading UCSRnA. Common for the error flags is that they are located in the receive buffer together with the
        frame for which they indicate the error status. Due to the buffering of the error flags, the UCSRnA must be read before the
        receive buffer (UDRn), since reading the UDRn I/O location changes the buffer read location. Another equality for the error
        flags is that they can not be altered by software doing a write to the flag location. However, all flags must be set to zero when
        the UCSRnA is written for upward compatibility of future USART implementations. None of the error flags can generate
        interrupts.
        The frame error (FEn) flag indicates the state of the first stop bit of the next readable frame stored in the receive buffer. The
        FEn flag is zero when the stop bit was correctly read (as one), and the FEn flag will be one when the stop bit was incorrect
        (zero). This flag can be used for detecting out-of-sync conditions, detecting break conditions and protocol handling. The FEn
        flag is not affected by the setting of the USBSn bit in UCSRnC since the receiver ignores all, except for the first, stop bits. For
        compatibility with future devices, always set this bit to zero when writing to UCSRnA.
        The data OverRun (DORn) flag indicates data loss due to a receiver buffer full condition. A data OverRun occurs when the
        receive buffer is full (two characters), it is a new character waiting in the receive shift register, and a new start bit is detected.
        If the DORn flag is set there was one or more serial frame lost between the frame last read from UDRn, and the next frame
        read from UDRn. For compatibility with future devices, always write this bit to zero when writing to UCSRnA. The DORn flag
        is cleared when the frame received was successfully moved from the shift register to the receive buffer.
        The parity error (UPEn) flag indicates that the next frame in the receive buffer had a parity error when received. If parity
        check is not enabled the UPEn bit will always be read zero. For compatibility with future devices, always set this bit to zero
        when writing to UCSRnA. For more details see Section 5.19.4.1 “Parity Bit Calculation” on page 170 and Section 5.19.7.5
        “Parity Checker” on page 176.
5.19.7.5 Parity Checker
        The parity checker is active when the high USART parity mode (UPMn1) bit is set. Type of parity check to be performed (odd
        or even) is selected by the UPMn0 bit. When enabled, the parity checker calculates the parity of the data bits in incoming
        frames and compares the result with the parity bit from the serial frame. The result of the check is stored in the receive buffer
        together with the received data and stop bits. The parity error (UPEn) flag can then be read by software to check if the frame
        had a parity error.
        The UPEn bit is set if the next character that can be read from the receive buffer had a parity error when received and the
        parity checking was enabled at that point (UPMn1 = 1). This bit is valid until the receive buffer (UDRn) is read.
5.19.7.6 Disabling the Receiver
        In contrast to the transmitter, disabling of the receiver will be immediate. Data from ongoing receptions will therefore be lost.
        When disabled (i.e., the RXENn is set to zero) the receiver will no longer override the normal function of the RxDn port pin.
        The receiver buffer FIFO will be flushed when the receiver is disabled. Remaining data in the buffer will be lost.
176     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19.7.7 Flushing the Receive Buffer
        The receiver buffer FIFO will be flushed when the receiver is disabled, i.e., the buffer will be emptied of its contents. Unread
        data will be lost. If the buffer has to be flushed during normal operation, due to for instance an error condition, read the UDRn
        I/O location until the RXCn Flag is cleared. The following code example shows how to flush the receive buffer.
         Assembly Code Example(1)
                    USART_Flush:
                               sbis     UCSRnA, RXCn
                               ret
                               in       r16, UDRn
                               rjmp     USART_Flush
         C Code Example(1)
                    void USART_Flush( void )
                    {
                               unsigned char dummy;
                               while ( UCSRnA & (1<<RXCn) ) dummy = UDRn;
                    }
        Note:      1.    See Section 5.5 “About Code Examples” on page 32.
                         For I/O registers located in extended I/O map, “IN”, “OUT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must
                         be replaced with instructions that allow access to extended I/O. Typically “LDS” and “STS” combined with
                         “SBRS”, “SBRC”, “SBR”, and “CBR”.
5.19.8 Asynchronous Data Reception
        The USART includes a clock recovery and a data recovery unit for handling asynchronous data reception. The clock
        recovery logic is used for synchronizing the internally generated baud rate clock to the incoming asynchronous serial frames
        at the RxDn pin. The data recovery logic samples and low pass filters each incoming bit, thereby improving the noise
        immunity of the receiver. The asynchronous reception operational range depends on the accuracy of the internal baud rate
        clock, the rate of the incoming frames, and the frame size in number of bits.
5.19.8.1 Asynchronous Clock Recovery
        The clock recovery logic synchronizes internal clock to the incoming serial frames. Figure 5-73 illustrates the sampling
        process of the start bit of an incoming frame. The sample rate is 16 times the baud rate for normal mode, and eight times the
        baud rate for double speed mode. The horizontal arrows illustrate the synchronization variation due to the sampling process.
        Note the larger time variation when using the double speed mode (U2Xn = 1) of operation. Samples denoted zero are
        samples done when the RxDn line is idle (i.e., no communication activity).
        Figure 5-73. Start Bit Sampling
                       RxD         IDLE                                         START                                       BIT 0
                    Sample
                    (U2X = 0)    0    0    1    2     3    4   5      6   7   8    9   10   11  12  13  14   15  16    1    2    3
                    Sample
                    (U2X = 1)    0         1          2        3          4        5         6       7       8         1         2
        When the clock recovery logic detects a high (idle) to low (start) transition on the RxDn line, the start bit detection sequence
        is initiated. Let sample 1 denote the first zero-sample as shown in the figure. The clock recovery logic then uses samples 8,
        9, and 10 for normal mode, and samples 4, 5, and 6 for double speed mode (indicated with sample numbers inside boxes on
        the figure), to decide if a valid start bit is received. If two or more of these three samples have logical high levels (the majority
        wins), the start bit is rejected as a noise spike and the receiver starts looking for the next high to low-transition. If however, a
        valid start bit is detected, the clock recovery logic is synchronized and the data recovery can begin. The synchronization
        process is repeated for each start bit.
                                                                                                    ATA6614Q [DATASHEET]                177
                                                                                                                  9240I–AUTO–03/16


5.19.8.2 Asynchronous Data Recovery
        When the receiver clock is synchronized to the start bit, the data recovery can begin. The data recovery unit uses a state
        machine that has 16 states for each bit in normal mode and eight states for each bit in double speed mode. Figure 5-74
        shows the sampling of the data bits and the parity bit. Each of the samples is given a number that is equal to the state of the
        recovery unit.
        Figure 5-74. Sampling of Data and Parity Bit
                        RxD                                                                 Bit n
                    Sample
                    (U2X = 0)                                 1  2  3  4  5  6     7   8       9        10          11       12  13   14 15 16 1
                    Sample
                    (U2X = 1)                                 1     2     3        4            5                    6            7      8     1
        The decision of the logic level of the received bit is taken by doing a majority voting of the logic value to the three samples in
        the center of the received bit. The center samples are emphasized on the figure by having the sample number inside boxes.
        The majority voting process is done as follows: If two or all three samples have high levels, the received bit is registered to
        be a logic 1. If two or all three samples have low levels, the received bit is registered to be a logic 0. This majority voting
        process acts as a low pass filter for the incoming signal on the RxDn pin. The recovery process is then repeated until a
        complete frame is received. Including the first stop bit. Note that the receiver only uses the first stop bit of a frame.
        Figure 5-75 shows the sampling of the stop bit and the earliest possible beginning of the start bit of the next frame.
        Figure 5-75. Stop Bit Sampling and Next Start Bit Sampling
                        RxD                                                                STOP 1                     (A)         (B)          (C)
                     Sample
                     (U2X = 0)                                 1  2  3  4  5  6     7   8       9         10         0/1     0/1 0/1
                     Sample
                     (U2X = 1)                                 1     2     3        4            5                     6         0/1
        The same majority voting is done to the stop bit as done for the other bits in the frame. If the stop bit is registered to have a
        logic 0 value, the frame error (FEn) flag will be set.
        A new high to low transition indicating the start bit of a new frame can come right after the last of the bits used for majority
        voting. For normal speed mode, the first low level sample can be at point marked (A) in Figure 5-75. For double speed mode
        the first low level must be delayed to (B). (C) marks a stop bit of full length. The early start bit detection influences the
        operational range of the receiver.
5.19.8.3 Asynchronous Operational Range
        The operational range of the receiver is dependent on the mismatch between the received bit rate and the internally
        generated baud rate. If the transmitter is sending frames at too fast or too slow bit rates, or the internally generated baud rate
        of the receiver does not have a similar (see Table 5-70 on page 179) base frequency, the receiver will not be able to
        synchronize the frames to the start bit.
        The following equations can be used to calculate the ratio of the incoming data rate and internal receiver baud rate.
                              D + 1 S                                                          D + 2 S
          R slow = ------------------------------------------                   R fast = -----------------------------------
                      S – 1 + D  S + SF                                                   D + 1 S + S M
178     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


       D                 Sum of character size and parity size (D = 5 to 10 bit)
       S                 Samples per bit. S = 16 for normal speed mode and S = 8 for double speed mode.
       SF                First sample number used for majority voting. SF = 8 for normal speed and SF = 4 for double speed mode.
       SM                Middle sample number used for majority voting. SM = 9 for normal speed and SM = 5 for double speed mode.
       Rslow             is the ratio of the slowest incoming data rate that can be accepted in relation to the receiver baud rate. Rfast is
                         the ratio of the fastest incoming data rate that can be accepted in relation to the receiver baud rate.
       Table 5-70 and Table 5-71 list the maximum receiver baud rate error that can be tolerated. Note that normal speed mode has
       higher toleration of baud rate variations.
       Table 5-70. Recommended Maximum Receiver Baud Rate Error for Normal Speed Mode (U2Xn = 0)
                       D                                                                                   Recommended Max Receiver
             # (Data+Parity Bit)            Rslow (%)       Rfast (%)         Max Total Error (%)                       Error (%)
                       5                      93.20          106.67                +6.67/-6.8                              ±3.0
                       6                      94.12          105.79               +5.79/-5.88                              ±2.5
                       7                      94.81           105.11              +5.11/-5.19                              ±2.0
                       8                      95.36          104.58               +4.58/-4.54                              ±2.0
                       9                      95.81          104.14               +4.14/-4.19                              ±1.5
                      10                      96.17          103.78               +3.78/-3.83                              ±1.5
       Table 5-71. Recommended Maximum Receiver Baud Rate Error for Double Speed Mode (U2Xn = 1)
                       D                                                                                  Recommended Max Receiver
             # (Data+Parity Bit)            Rslow (%)       Rfast (%)        Max Total Error (%)                       Error (%)
                       5                      94.12          105.66              +5.66/-5.88                              ±2.5
                       6                      94.92          104.92              +4.92/-5.08                              ±2.0
                       7                      95.52          104,35              +4.35/-4.48                              ±1.5
                       8                      96.00          103.90              +3.90/-4.00                              ±1.5
                       9                      96.39          103.53              +3.53/-3.61                              ±1.5
                      10                      96.70          103.23              +3.23/-3.30                              ±1.0
       The recommendations of the maximum receiver baud rate error was made under the assumption that the receiver and
       transmitter equally divides the maximum total error.
       There are two possible sources for the receivers baud rate error. The receiver’s system clock (XTAL) will always have some
       minor instability over the supply voltage range and the temperature range. When using a crystal to generate the system
       clock, this is rarely a problem, but for a resonator the system clock may differ more than 2% depending of the resonators
       tolerance. The second source for the error is more controllable. The baud rate generator can not always do an exact division
       of the system frequency to get the baud rate wanted. In this case an UBRRn value that gives an acceptable low error can be
       used if possible.
5.19.9 Multi-processor Communication Mode
       Setting the multi-processor communication mode (MPCMn) bit in UCSRnA enables a filtering function of incoming frames
       received by the USART receiver. Frames that do not contain address information will be ignored and not put into the receive
       buffer. This effectively reduces the number of incoming frames that has to be handled by the CPU, in a system with multiple
       MCUs that communicate via the same serial bus. The transmitter is unaffected by the MPCMn setting, but has to be used
       differently when it is a part of a system utilizing the multi-processor communication mode.
       If the receiver is set up to receive frames that contain 5 to 8 data bits, then the first stop bit indicates if the frame contains
       data or address information. If the receiver is set up for frames with nine data bits, then the ninth bit (RXB8n) is used for
       identifying address and data frames. When the frame type bit (the first stop or the ninth bit) is one, the frame contains an
       address. When the frame type bit is zero the frame is a data frame.
                                                                                                   ATA6614Q [DATASHEET]                 179
                                                                                                                  9240I–AUTO–03/16


        The multi-processor communication mode enables several slave MCUs to receive data from a master MCU. This is done by
        first decoding an address frame to find out which MCU has been addressed. If a particular slave MCU has been addressed,
        it will receive the following data frames as normal, while the other slave MCUs will ignore the received frames until another
        address frame is received.
5.19.9.1 Using MPCMn
        For an MCU to act as a master MCU, it can use a 9-bit character frame format (UCSZn = 7). The ninth bit (TXB8n) must be
        set when an address frame (TXB8n = 1) or cleared when a data frame (TXB = 0) is being transmitted. The slave MCUs must
        in this case be set to use a 9-bit character frame format.
        The following procedure should be used to exchange data in multi-processor communication mode:
           1. All slave MCUs are in multi-processor communication mode (MPCMn in
                  UCSRnA is set).
           2.     The master MCU sends an address frame, and all slaves receive and read this frame. In the Slave MCUs, the
                  RXCn flag in UCSRnA will be set as normal.
           3.     Each slave MCU reads the UDRn register and determines if it has been selected. If so, it clears the MPCMn bit in
                  UCSRnA, otherwise it waits for the next address byte and keeps the MPCMn setting.
           4.     The addressed MCU will receive all data frames until a new address frame is received. The other slave MCUs,
                  which still have the MPCMn bit set, will ignore the data frames.
           5.     When the last data frame is received by the addressed MCU, the addressed MCU sets the MPCMn bit and waits
                  for a new address frame from master. The process then repeats from 2.
        Using any of the 5- to 8-bit character frame formats is possible, but impractical since the receiver must change between
        using n and n+1 character frame formats. This makes full-duplex operation difficult since the transmitter and receiver uses
        the same character size setting. If 5- to 8-bit character frames are used, the transmitter must be set to use two stop bit
        (USBSn = 1) since the first stop bit is used for indicating the frame type.
        Do not use read-modify-write instructions (SBI and CBI) to set or clear the MPCMn bit. The MPCMn bit shares the same I/O
        location as the TXCn flag and this might accidentally be cleared when using SBI or CBI instructions.
5.19.10 Register Description
5.19.10.1 UDRn – USART I/O Data Register n
                 Bit            7       6        5           4          3       2          1         0
                                                               RXB[7:0]                                    UDRn (Read)
                                                               TXB[7:0]                                    UDRn (Write)
           Read/Write         R/W      R/W      R/W        R/W       R/W       R/W      R/W         R/W
           Initial Value        0       0        0           0          0       0          0         0
        The USART transmit data buffer register and USART receive data buffer registers share the same I/O address referred to as
        USART data register or UDRn. The transmit data buffer register (TXB) will be the destination for data written to the UDRn
        register location. Reading the UDRn register location will return the contents of the receive data buffer register (RXB).
        For 5-, 6-, or 7-bit characters the upper unused bits will be ignored by the transmitter and set to zero by the receiver.
        The transmit buffer can only be written when the UDREn flag in the UCSRnA register is set. Data written to UDRn when the
        UDREn flag is not set, will be ignored by the USART transmitter. When data is written to the transmit buffer, and the
        transmitter is enabled, the transmitter will load the data into the transmit shift register when the shift register is empty. Then
        the data will be serially transmitted on the TxDn pin.
        The receive buffer consists of a two level FIFO. The FIFO will change its state whenever the receive buffer is accessed. Due
        to this behavior of the receive buffer, do not use read-modify-write instructions (SBI and CBI) on this location. Be careful
        when using bit test instructions (SBIC and SBIS), since these also will change the state of the FIFO.
180     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19.10.2 UCSRnA – USART Control and Status Register n A
                  Bit          7         6           5         4          3          2         1          0
                             RXCn      TXCn       UDREn      FEn       DORn       UPEn       U2Xn      MPCMn       UCSRnA
            Read/Write         R        R/W         R         R           R         R         R/W       R/W
            Initial Value      0         0           1         0          0          0         0          0
        • Bit 7 – RXCn: USART Receive Complete
        This flag bit is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does
        not contain any unread data). If the receiver is disabled, the receive buffer will be flushed and consequently the RXCn bit will
        become zero. The RXCn flag can be used to generate a receive complete interrupt (see description of the RXCIEn bit).
        • Bit 6 – TXCn: USART Transmit Complete
        This flag bit is set when the entire frame in the transmit shift register has been shifted out and there are no new data currently
        present in the transmit buffer (UDRn). The TXCn flag bit is automatically cleared when a transmit complete interrupt is
        executed, or it can be cleared by writing a one to its bit location. The TXCn flag can generate a transmit complete interrupt
        (see description of the TXCIEn bit).
        • Bit 5 – UDREn: USART Data Register Empty
        The UDREn flag indicates if the transmit buffer (UDRn) is ready to receive new data. If UDREn is one, the buffer is empty,
        and therefore ready to be written. The UDREn flag can generate a data register empty interrupt (see description of the
        UDRIEn bit). UDREn is set after a reset to indicate that the transmitter is ready.
        • Bit 4 – FEn: Frame Error
        This bit is set if the next character in the receive buffer had a frame error when received. I.e., when the first stop bit of the
        next character in the receive buffer is zero. This bit is valid until the receive buffer (UDRn) is read. The FEn bit is zero when
        the stop bit of received data is one. Always set this bit to zero when writing to UCSRnA.
        • Bit 3 – DORn: Data OverRun
        This bit is set if a data OverRun condition is detected. A data OverRun occurs when the receive buffer is full (two characters),
        it is a new character waiting in the receive shift register, and a new start bit is detected. This bit is valid until the receive buffer
        (UDRn) is read. Always set this bit to zero when writing to UCSRnA.
        • Bit 2 – UPEn: USART Parity Error
        This bit is set if the next character in the receive buffer had a parity error when received and the parity checking was enabled
        at that point (UPMn1 = 1). This bit is valid until the receive buffer (UDRn) is read. Always set this bit to zero when writing to
        UCSRnA.
        • Bit 1 – U2Xn: Double the USART Transmission Speed
        This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation.
        Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for
        asynchronous communication.
        • Bit 0 – MPCMn: Multi-processor Communication Mode
        This bit enables the multi-processor communication mode. When the MPCMn bit is written to one, all the incoming frames
        received by the USART receiver that do not contain address information will be ignored. The transmitter is unaffected by the
        MPCMn setting. For more detailed information see Section 5.19.9 “Multi-processor Communication Mode” on page 179.
                                                                                                    ATA6614Q [DATASHEET]                    181
                                                                                                                    9240I–AUTO–03/16


5.19.10.3 UCSRnB – USART Control and Status Register n B
                Bit          7        6           5          4         3          2         1        0
                          RXCIEn    TXCIEn     UDRIEn    RXENn      TXENn     UCSZn2     RXB8n     TXB8n    UCSRnB
          Read/Write       R/W       R/W        R/W        R/W       R/W         R/W        R       R/W
          Initial Value      0        0           0          0         0          0         0        0
        • Bit 7 – RXCIEn: RX Complete Interrupt Enable n
        Writing this bit to one enables interrupt on the RXCn flag. A USART receive complete interrupt will be generated only if the
        RXCIEn bit is written to one, the global interrupt flag in SREG is written to one and the RXCn bit in UCSRnA is set.
        • Bit 6 – TXCIEn: TX Complete Interrupt Enable n
        Writing this bit to one enables interrupt on the TXCn flag. A USART transmit complete interrupt will be generated only if the
        TXCIEn bit is written to one, the global interrupt flag in SREG is written to one and the TXCn bit in UCSRnA is set.
        • Bit 5 – UDRIEn: USART Data Register Empty Interrupt Enable n
        Writing this bit to one enables interrupt on the UDREn flag. A data register empty interrupt will be generated only if the
        UDRIEn bit is written to one, the global interrupt flag in SREG is written to one and the UDREn bit in UCSRnA is set.
        • Bit 4 – RXENn: Receiver Enable n
        Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxDn pin when
        enabled. Disabling the receiver will flush the receive buffer invalidating the FEn, DORn, and UPEn flags.
        • Bit 3 – TXENn: Transmitter Enable n
        Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxDn pin
        when enabled. The disabling of the transmitter (writing TXENn to zero) will not become effective until ongoing and pending
        transmissions are completed, i.e., when the transmit shift register and transmit buffer register do not contain data to be
        transmitted. When disabled, the transmitter will no longer override the TxDn port.
        • Bit 2 – UCSZn2: Character Size n
        The UCSZn2 bits combined with the UCSZn1:0 bit in UCSRnC sets the number of data bits (Character SiZe) in a frame the
        receiver and transmitter use.
        • Bit 1 – RXB8n: Receive Data Bit 8 n
        RXB8n is the ninth data bit of the received character when operating with serial frames with nine data bits. Must be read
        before reading the low bits from UDRn.
        • Bit 0 – TXB8n: Transmit Data Bit 8 n
        TXB8n is the ninth data bit in the character to be transmitted when operating with serial frames with nine data bits. Must be
        written before writing the low bits to UDRn.
182     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.19.10.4 UCSRnC – USART Control and Status Register n C
               Bit          7          6           5         4         3        2          1         0
                        UMSELn1    UMSELn0     UPMn1      UPMn0     USBSn   UCSZn1     UCSZn0     UCPOLn     UCSRnC
         Read/Write       R/W         R/W        R/W       R/W       R/W      R/W        R/W        R/W
         Initial Value      0          0           0         0         0        1          1         0
        • Bits 7:6 – UMSELn1:0 USART Mode Select
        These bits select the mode of operation of the USARTn as shown in Table 5-72.
        Table 5-72. UMSELn Bits Settings
                   UMSELn1                   UMSELn0               Mode
                       0                          0                Asynchronous USART
                       0                          1                Synchronous USART
                       1                          0                (Reserved)
                       1                          1                Master SPI (MSPIM)(1)
        Note:       1.  See Section 5.20 “USART in SPI Mode” on page 187 for full description of the master SPI mode (MSPIM)
                        operation.
        • Bits 5:4 – UPMn1:0: Parity Mode
        These bits enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and
        send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data
        and compare it to the UPMn setting. If a mismatch is detected, the UPEn Flag in UCSRnA will be set.
        Table 5-73. UPMn Bits Settings
                    UPMn1                     UPMn0               Parity Mode
                       0                          0               Disabled
                       0                          1               Reserved
                       1                          0               Enabled, even parity
                       1                          1               Enabled, odd parity
        • Bit 3 – USBSn: Stop Bit Select
        This bit selects the number of stop bits to be inserted by the transmitter. The receiver ignores this setting.
        Table 5-74. USBS Bit Settings
                                 USBSn                           Stop Bit(s)
                                    0                            1-bit
                                    1                            2-bit
        • Bit 2:1 – UCSZn1:0: Character Size
        The UCSZn1:0 bits combined with the UCSZn2 bit in UCSRnB sets the number of data bits (character SiZe) in a frame the
        receiver and transmitter use.
                                                                                               ATA6614Q [DATASHEET]                 183
                                                                                                               9240I–AUTO–03/16


        Table 5-75. UCSZn Bits Settings
                     UCSZn2                                                  UCSZn1              UCSZn0            Character Size
                         0                                                       0                 0               5-bit
                         0                                                       0                 1               6-bit
                         0                                                       1                 0               7-bit
                         0                                                       1                 1               8-bit
                         1                                                       0                 0               Reserved
                         1                                                       0                 1               Reserved
                         1                                                       1                 0               Reserved
                         1                                                       1                 1               9-bit
        • Bit 0 – UCPOLn: Clock Polarity
        This bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is used. The UCPOLn bit sets
        the relationship between data output change and data input sample, and the synchronous clock (XCKn).
        Table 5-76. UCPOLn Bit Settings
             UCPOLn                 Transmitted Data Changed (Output of TxDn Pin) Received Data Sampled (Input on RxDn Pin)
                   0                Rising XCKn edge                                                     Falling XCKn edge
                   1                Falling XCKn edge                                                    Rising XCKn edge
5.19.10.5 UBRRnL and UBRRnH – USART Baud Rate Registers
                 Bit                  15                        14              13    12      11      10         9        8
                                       –                          –              –     –              UBRRn[11:8]               UBRRnH
                                                                                      UBRRn[7:0]                                 UBRRnL
                                       7                          6              5     4       3       2         1        0
                                       R                         R              R     R      R/W     R/W        R/W      R/W
           Read/Write
                                   R/W                        R/W              R/W   R/W     R/W     R/W        R/W      R/W
                                       0                          0              0     0       0       0         0        0
           Initial Value
                                       0                          0              0     0       0       0         0        0
        • Bit 15:12 – Reserved Bits
        These bits are reserved for future use. For compatibility with future devices, these bit must be written to zero when UBRRnH
        is written.
        • Bit 11:0 – UBRR11:0: USART Baud Rate Register
        This is a 12-bit register which contains the USART baud rate. The UBRRnH contains the four most significant bits, and the
        UBRRnL contains the eight least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and
        receiver will be corrupted if the baud rate is changed. Writing UBRRnL will trigger an immediate update of the baud rate
        prescaler.
5.19.10.6 Examples of Baud Rate Setting
        For standard crystal and resonator frequencies, the most commonly used baud rates for asynchronous operation can be
        generated by using the UBRRn settings in Table 5-77. UBRRn values which yield an actual baud rate differing less than
        0.5% from the target baud rate, are bold in the table. Higher error ratings are acceptable, but the receiver will have less noise
        resistance when the error ratings are high, especially for large serial frames (see Section 5.19.8.3 “Asynchronous
        Operational Range” on page 178). The error values are calculated using the following equation:
                         BaudRateClosest Match
         Error[%] =  -------------------------------------------------- – 1  100%
                                   BaudRate                                
184     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


Table 5-77. Examples of UBRRn Settings for Commonly Used Oscillator Frequencies
                      fosc = 1.0000MHz                       fosc = 1.8432MHz                      fosc = 2.0000MHz
  Baud
   Rate         U2Xn = 0              U2Xn = 1          U2Xn = 0            U2Xn = 1          U2Xn = 0              U2Xn = 1
  (bps)     UBRRn       Error    UBRRn       Error UBRRn       Error     UBRRn     Error UBRRn        Error     UBRRn     Error
   2400       25         0.2%       51        0.2%   47        0.0%        95      0.0%    51         0.2%       103       0.2%
   4800       12         0.2%       25        0.2%   23        0.0%        47      0.0%    25         0.2%        51       0.2%
   9600        6        -7.0%       12        0.2%    11       0.0%        23      0.0%    12         0.2%        25       0.2%
  14.4k        3         8.5%        8       -3.5%    7        0.0%        15      0.0%     8        -3.5%        16       2.1%
  19.2k        2         8.5%        6       -7.0%    5        0.0%        11      0.0%     6        -7.0%        12       0.2%
  28.8k        1         8.5%        3        8.5%    3        0.0%         7      0.0%     3         8.5%         8      -3.5%
  38.4k        1       -18.6%        2        8.5%    2        0.0%         5      0.0%     2         8.5%         6      -7.0%
  57.6k        0         8.5%        1        8.5%    1        0.0%         3      0.0%     1         8.5%         3       8.5%
  76.8k        –           –         1      -18.6%    1       -25.0%        2      0.0%     1       -18.6%         2       8.5%
 115.2k        –           –         0        8.5%    0        0.0%         1      0.0%     0         8.5%         1       8.5%
 230.4k        –           –         –          –     –           –         0      0.0%     –           –          –         –
   250k        –           –         –          –     –           –         –        –      –           –          0       0.0%
 Max.(1)        62.5kbps               125kbps         115.2kbps            230.4kbps         125kbps               250kbps
 Notes: 1.    UBRRn = 0, Error = 0.0%.
Table 5-78. Examples of UBRRn Settings for Commonly Used Oscillator Frequencies (Continued)
                      fosc = 3.6864MHz                      fosc = 4.0000MHz                       fosc = 7.3728MHz
  Baud
   Rate         U2Xn = 0             U2Xn = 1         U2Xn = 0             U2Xn = 1          U2Xn = 0              U2Xn = 1
   (bps)     UBRRn       Error   UBRRn       Error UBRRn      Error     UBRRn     Error  UBRRn       Error     UBRRn      Error
   2400        95        0.0%      191       0.0%   103       0.2%        207      0.2%    191        0.0%       383       0.0%
   4800        47        0.0%      95        0.0%    51       0.2%        103      0.2%    95         0.0%       191       0.0%
   9600        23        0.0%      47        0.0%    25       0.2%        51       0.2%    47         0.0%       95        0.0%
   14.4k       15        0.0%      31        0.0%    16       2.1%        34      -0.8%    31         0.0%       63        0.0%
   19.2k       11        0.0%      23        0.0%    12       0.2%        25       0.2%    23         0.0%       47        0.0%
   28.8k        7        0.0%      15        0.0%     8       -3.5%       16       2.1%    15         0.0%       31        0.0%
   38.4k        5        0.0%       11       0.0%     6       -7.0%       12       0.2%     11        0.0%       23        0.0%
   57.6k        3        0.0%        7       0.0%     3       8.5%         8      -3.5%     7         0.0%       15        0.0%
   76.8k        2        0.0%        5       0.0%     2       8.5%         6      -7.0%     5         0.0%        11       0.0%
  115.2k        1        0.0%        3       0.0%     1       8.5%         3       8.5%     3         0.0%        7        0.0%
  230.4k        0        0.0%        1       0.0%     0       8.5%         1       8.5%     1         0.0%        3        0.0%
   250k         0       -7.8%        1      -7.8%     0       0.0%         1       0.0%     1        -7.8%        3       -7.8%
   0.5M         –          –         0      -7.8%     –          –         0       0.0%     0        -7.8%        1       -7.8%
    1M          –          –         –          –     –          –         –         –      –           –         0       -7.8%
  Max.(1)       230.4kbps            460.8kbps         250kbps              0.5Mbps          460.8kbps             921.6kbps
 Note:    1.  UBRRn = 0, Error = 0.0%
                                                                                         ATA6614Q [DATASHEET]                 185
                                                                                                        9240I–AUTO–03/16


Table 5-79. Examples of UBRRn Settings for Commonly Used Oscillator Frequencies (Continued)
                         fosc = 8.0000MHz                       fosc = 11.0592MHz                        fosc = 14.7456MHz
  Baud
   Rate            U2Xn = 0            U2Xn = 1            U2Xn = 0              U2Xn = 1           U2Xn = 0            U2Xn = 1
   (bps)       UBRRn       Error    UBRRn      Error   UBRRn       Error    UBRRn      Error   UBRRn       Error    UBRRn      Error
   2400          207        0.2%      416      -0.1%     287       0.0%        575      0.0%      383       0.0%      767       0.0%
   4800          103        0.2%      207      0.2%      143       0.0%        287      0.0%      191       0.0%      383       0.0%
   9600           51        0.2%      103      0.2%      71        0.0%        143      0.0%      95        0.0%      191       0.0%
   14.4k          34       -0.8%      68       0.6%      47        0.0%        95       0.0%      63        0.0%      127       0.0%
   19.2k          25        0.2%      51       0.2%      35        0.0%        71       0.0%      47        0.0%       95       0.0%
   28.8k          16        2.1%      34       -0.8%     23        0.0%        47       0.0%      31        0.0%       63       0.0%
   38.4k          12        0.2%      25       0.2%      17        0.0%        35       0.0%      23        0.0%       47       0.0%
   57.6k           8       -3.5%      16       2.1%       11       0.0%        23       0.0%      15        0.0%       31       0.0%
   76.8k           6       -7.0%      12       0.2%       8        0.0%        17       0.0%       11       0.0%       23       0.0%
  115.2k           3        8.5%       8       -3.5%      5        0.0%         11      0.0%       7        0.0%       15       0.0%
  230.4k           1        8.5%       3       8.5%       2        0.0%         5       0.0%       3        0.0%        7       0.0%
   250k            1        0.0%       3       0.0%       2        -7.8%        5      -7.8%       3       -7.8%        6       5.3%
   0.5M            0        0.0%       1       0.0%       –           –         2      -7.8%       1       -7.8%        3      -7.8%
    1M             –          –        0       0.0%       –           –         –         –        0       -7.8%        1      -7.8%
      .(1)
  Max               0.5Mbps              1Mbps             691.2kbps           1.3824Mbps           921.6kbps         1.8432Mbps
 Note:      1.   UBRRn = 0, Error = 0.0%
Table 5-80. Examples of UBRRn Settings for Commonly Used Oscillator Frequencies (Continued)
                                                                         fosc = 16.0000MHz
                                                    U2Xn = 0                                            U2Xn = 1
     Baud Rate (bps)                     UBRRn                      Error                    UBRRn                       Error
             2400                          416                      -0.1%                     832                        0.0%
             4800                          207                       0.2%                     416                       -0.1%
             9600                          103                       0.2%                     207                        0.2%
             14.4k                          68                       0.6%                     138                       -0.1%
             19.2k                          51                       0.2%                     103                        0.2%
             28.8k                          34                      -0.8%                      68                        0.6%
             38.4k                          25                       0.2%                      51                        0.2%
             57.6k                          16                       2.1%                      34                       -0.8%
             76.8k                          12                       0.2%                      25                        0.2%
            115.2k                          8                       -3.5%                      16                        2.1%
            230.4k                          3                        8.5%                       8                       -3.5%
             250k                           3                        0.0%                       7                        0.0%
             0.5M                           1                        0.0%                       3                        0.0%
               1M                           0                        0.0%                       1                        0.0%
                  (1)
            Max.                                     1Mbps                                               2Mbps
 Note:      1. UBRRn = 0, Error = 0.0%
186        ATA6614Q [DATASHEET]
           9240I–AUTO–03/16


5.20   USART in SPI Mode
5.20.1 Features
         ●     Full duplex, three-wire synchronous data transfer
         ●     Master operation
         ●     Supports all four SPI modes of operation (mode 0, 1, 2, and 3)
         ●     LSB first or MSB first data transfer (configurable data order)
         ●     Queued operation (double buffered)
         ●     High resolution baud rate generator
         ●     High speed operation (fXCKmax = fCK/2)
         ●     Flexible interrupt generation
5.20.2 Overview
       The universal synchronous and asynchronous serial receiver and transmitter (USART) can be set to a master SPI compliant
       mode of operation.
       Setting both UMSELn1:0 bits to one enables the USART in MSPIM logic. In this mode of operation the SPI master control
       logic takes direct control over the USART resources. These resources include the transmitter and receiver shift register and
       buffers, and the baud rate generator. The parity generator and checker, the data and clock recovery logic, and the RX and
       TX control logic is disabled. The USART RX and TX control logic is replaced by a common SPI transfer control logic.
       However, the pin control logic and interrupt generation logic is identical in both modes of operation.
       The I/O register locations are the same in both modes. However, some of the functionality of the control registers changes
       when using MSPIM.
5.20.3 Clock Generation
       The clock generation logic generates the base clock for the transmitter and receiver. For USART MSPIM mode of operation
       only internal clock generation (i.e. master operation) is supported. The data direction register for the XCKn pin (DDR_XCKn)
       must therefore be set to one (i.e. as output) for the USART in MSPIM to operate correctly. Preferably the DDR_XCKn should
       be set up before the USART in MSPIM is enabled (i.e. TXENn and RXENn bit set to one).
       The internal clock generation used in MSPIM mode is identical to the USART synchronous master mode. The baud rate or
       UBRRn setting can therefore be calculated using the same equations, see Table 5-81:
       Table 5-81. Equations for Calculating Baud Rate Register Setting
        Operating Mode                       Equation for Calculating Baud Rate(1)         Equation for Calculating UBRRn Value
        Synchronous Master mode
                                                               f OSC                                     f OSC
                                           BAUD = -------------------------------------- UBRRn = -------------------- – 1
                                                      2  UBRRn + 1                                  2BAUD
        Note:     1.   The baud rate is defined to be the transfer rate in bit per second (bps)
                BAUD               Baud rate (in bits per second, bps)
                fOSC               System oscillator clock frequency
                UBRRn              Contents of the UBRRnH and UBRRnL registers, (0-4095)
                                                                                                ATA6614Q [DATASHEET]               187
                                                                                                                  9240I–AUTO–03/16


5.20.4 SPI Data Modes and Timing
      There are four combinations of XCKn (SCK) phase and polarity with respect to serial data, which are determined by control
      bits UCPHAn and UCPOLn. The data transfer timing diagrams are shown in Figure 5-76. Data bits are shifted out and
      latched in on opposite edges of the XCKn signal, ensuring sufficient time for data signals to stabilize. The UCPOLn and
      UCPHAn functionality is summarized in Table 5-82. Note that changing the setting of any of these bits will corrupt all ongoing
      communication for both the receiver and transmitter.
      Table 5-82. UCPOLn and UCPHAn Functionality-
            UCPOLn                       UCPHAn          SPI Mode      Leading Edge                      Trailing Edge
                        0                       0               0      Sample (rising)                   Setup (falling)
                        0                       1               1      Setup (rising)                    Sample (falling)
                        1                       0               2      Sample (falling)                  Setup (rising)
                        1                       1               3      Setup (falling)                   Sample (rising)
      Figure 5-76. UCPHAn and UCPOLn Data Transfer Timing Diagrams
                                                    UCPOL = 0                                             UCPOL = 1
            UCPHA = 1
                                         XCK                                                XCK
                             Data setup (TXD)                                    Data setup (TXD)
                            Data sample (RXD)                                  Data sample (RXD)
                                         XCK                                                XCK
            UCPHA = 0
                             Data setup (TXD)                                    Data setup (TXD)
                            Data sample (RXD)                                  Data sample (RXD)
5.20.5 Frame Formats
      A serial frame for the MSPIM is defined to be one character of 8 data bits. The USART in MSPIM mode has two valid frame
      formats:
        ● 8-bit data with MSB first
        ●    8-bit data with LSB first
      A frame starts with the least or most significant data bit. Then the next data bits, up to a total of eight, are succeeding, ending
      with the most or least significant bit accordingly. When a complete frame is transmitted, a new frame can directly follow it, or
      the communication line can be set to an idle (high) state.
      The UDORDn bit in UCSRnC sets the frame format used by the USART in MSPIM mode. The receiver and transmitter use
      the same setting. Note that changing the setting of any of these bits will corrupt all ongoing communication for both the
      receiver and Transmitter.
      16-bit data transfer can be achieved by writing two data bytes to UDRn. A UART transmit complete interrupt will then signal
      that the 16-bit value has been shifted out.
188   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.20.5.1 USART MSPIM Initialization
        The USART in MSPIM mode has to be initialized before any communication can take place. The initialization process
        normally consists of setting the baud rate, setting master mode of operation (by setting DDR_XCKn to one), setting frame
        format and enabling the transmitter and the receiver. Only the transmitter can operate independently. For interrupt driven
        USART operation, the global interrupt flag should be cleared (and thus interrupts globally disabled) when doing the
        initialization.
        Note:           To ensure immediate initialization of the XCKn output the baud-rate register (UBRRn) must be zero at the time
                        the transmitter is enabled. Contrary to the normal mode USART operation the UBRRn must then be written to
                        the desired value after the transmitter is enabled, but before the first transmission is started. Setting UBRRn to
                        zero before enabling the transmitter is not necessary if the initialization is done immediately after a reset since
                        UBRRn is reset to zero.
        Before doing a re-initialization with changed baud rate, data mode, or frame format, be sure that there is no ongoing
        transmissions during the period the registers are changed. The TXCn flag can be used to check that the transmitter has
        completed all transfers, and the RXCn flag can be used to check that there are no unread data in the receive buffer. Note
        that the TXCn flag must be cleared before each transmission (before UDRn is written) if it is used for this purpose.
        The following simple USART initialization code examples show one assembly and one C function that are equal in
        functionality. The examples assume polling (no interrupts enabled). The baud rate is given as a function parameter. For the
        assembly code, the baud rate parameter is assumed to be stored in the r17:r16 registers.
         Assembly Code Example(1)
                     USART_Init:
                              clr r18
                              out UBRRnH,r18
                              out UBRRnL,r18
                              ; Setting the XCKn port pin as output, enables master mode.
                              sbi XCKn_DDR, XCKn
                              ; Set MSPI mode of operation and SPI data mode 0.
                              ldi r18, (1<<UMSELn1)|(1<<UMSELn0)|(0<<UCPHAn)|(0<<UCPOLn)
                              out UCSRnC,r18
                              ; Enable receiver and transmitter.
                              ldi r18, (1<<RXENn)|(1<<TXENn)
                              out UCSRnB,r18
                              ; Set baud rate.
                              ; IMPORTANT: The Baud Rate must be set after the transmitter is enabled!
                              out UBRRnH, r17
                              out UBRRnL, r18
                              ret
         C Code Example(1)
                     void USART_Init(unsigned int baud)
                     {
                              UBRRn = 0;
                              /* Setting the XCKn port pin as output, enables master mode. */
                              XCKn_DDR |= (1<<XCKn);
                              /* Set MSPI mode of operation and SPI data mode 0. */
                              UCSRnC = (1<<UMSELn1)|(1<<UMSELn0)|(0<<UCPHAn)|(0<<UCPOLn);
                              /* Enable receiver and transmitter. */
                              UCSRnB = (1<<RXENn)|(1<<TXENn);
                              /* Set baud rate. */
                              /* IMPORTANT: The Baud Rate must be set after the transmitter is enabled */
                              UBRRn = baud;
                     }
        Note:       1.  See Section 5.5 “About Code Examples” on page 32.
                                                                                                    ATA6614Q [DATASHEET]                189
                                                                                                                  9240I–AUTO–03/16


5.20.6 Data Transfer
       Using the USART in MSPI mode requires the transmitter to be enabled, i.e. the TXENn bit in the UCSRnB register is set to
       one. When the transmitter is enabled, the normal port operation of the TxDn pin is overridden and given the function as the
       transmitter's serial output. Enabling the receiver is optional and is done by setting the RXENn bit in the UCSRnB register to
       one. When the receiver is enabled, the normal pin operation of the RxDn pin is overridden and given the function as the
       receiver's serial input. The XCKn will in both cases be used as the transfer clock.
       After initialization the USART is ready for doing data transfers. A data transfer is initiated by writing to the UDRn I/O location.
       This is the case for both sending and receiving data since the transmitter controls the transfer clock. The data written to
       UDRn is moved from the transmit buffer to the shift register when the shift register is ready to send a new frame.
       Note:           To keep the input buffer in sync with the number of data bytes transmitted, the UDRn register must be read
                       once for each byte transmitted. The input buffer operation is identical to normal USART mode, i.e. if an over-
                       flow occurs the character last received will be lost, not the first data in the buffer. This means that if four bytes
                       are transferred, byte 1 first, then byte 2, 3, and 4, and the UDRn is not read before all transfers are completed,
                       then byte 3 to be received will be lost, and not byte 1.
       The following code examples show a simple USART in MSPIM mode transfer function based on polling of the data register
       empty (UDREn) flag and the receive complete (RXCn) flag. The USART has to be initialized before the function can be used.
       For the assembly code, the data to be sent is assumed to be stored in register R16 and the data received will be available in
       the same register (R16) after the function returns.
       The function simply waits for the transmit buffer to be empty by checking the UDREn flag, before loading it with new data to
       be transmitted. The function then waits for data to be present in the receive buffer by checking the RXCn flag, before reading
       the buffer and returning the value.
        Assembly Code Example(1)
                   USART_MSPIM_Transfer:
                              ; Wait for empty transmit buffer
                              sbis UCSRnA, UDREn
                              rjmp USART_MSPIM_Transfer
                              ; Put data (r16) into buffer, sends the data
                              out UDRn,r16
                              ; Wait for data to be received
                   USART_MSPIM_Wait_RXCn:
                              sbis UCSRnA, RXCn
                              rjmp USART_MSPIM_Wait_RXCn
                              ; Get and return received data from buffer
                              in r16, UDRn
                              ret
        C Code Example(1)
                   unsigned char USART_Receive(void)
                   {
                              /* Wait for empty transmit buffer */
                              while (!(UCSRnA & (1<<UDREn)));
                              /* Put data into buffer, sends the data */
                              UDRn = data;
                              /* Wait for data to be received */
                              while (!(UCSRnA & (1<<RXCn)));
                              /* Get and return received data from buffer */
                              return UDRn;
                   }
       Note:      1.   See Section 5.5 “About Code Examples” on page 32.
190    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.20.6.1 Transmitter and Receiver Flags and Interrupts
        The RXCn, TXCn, and UDREn flags and corresponding interrupts in USART in MSPIM mode are identical in function to the
        normal USART operation. However, the receiver error status flags (FE, DOR, and PE) are not in use and is always read as
        zero.
5.20.6.2 Disabling the Transmitter or Receiver
        The disabling of the transmitter or receiver in USART in MSPIM mode is identical in function to the normal USART operation.
5.20.7 AVR USART MSPIM versus AVR SPI
        The USART in MSPIM mode is fully compatible with the AVR® SPI regarding:
          ● Master mode timing diagram.
          ●    The UCPOLn bit functionality is identical to the SPI CPOL bit.
          ●    The UCPHAn bit functionality is identical to the SPI CPHA bit.
          ●    The UDORDn bit functionality is identical to the SPI DORD bit.
        However, since the USART in MSPIM mode reuses the USART resources, the use of the USART in MSPIM mode is
        somewhat different compared to the SPI. In addition to differences of the control register bits, and that only master operation
        is supported by the USART in MSPIM mode, the following features differ between the two modules:
          ● The USART in MSPIM mode includes (double) buffering of the transmitter. The SPI has no buffer.
          ●    The USART in MSPIM mode receiver includes an additional buffer level.
          ●    The SPI WCOL (write collision) bit is not included in USART in MSPIM mode.
          ●    The SPI double speed mode (SPI2X) bit is not included. However, the same effect is achieved by setting UBRRn
               accordingly.
          ●    Interrupt timing is not compatible.
          ●    Pin control differs due to the master only operation of the USART in MSPIM mode.
        A comparison of the USART in MSPIM mode and the SPI pins is shown in Table 5-83.
        Table 5-83. Comparison of USART in MSPIM Mode and SPI Pins
                     USART_MSPIM                                       SPI                     Comment
                            TxDn                                     MOSI                      Master out only
                           RxDn                                      MISO                      Master In only
                           XCKn                                       SCK                      (Functionally identical)
                            (N/A)                                       SS                     Not supported by USART in MSPIM
5.20.8 Register Description
        The following section describes the registers used for SPI operation using the USART.
5.20.8.1 UDRn – USART MSPIM I/O Data Register
        The function and bit description of the USART data register (UDRn) in MSPI mode is identical to normal USART operation.
        See Section 5.19.10.1 “UDRn – USART I/O Data Register n” on page 180.
                                                                                               ATA6614Q [DATASHEET]                191
                                                                                                               9240I–AUTO–03/16


5.20.8.2 UCSRnA – USART MSPIM Control and Status Register n A
                Bit          7       6          5          4         3           2          1           0
                          RXCn     TXCn      UDREn         -         -            -         -           -       UCSRnA
          Read/Write         R      R/W         R          R         R           R          R           R
          Initial Value      0       0          0          0         0           1          1           0
        • Bit 7 - RXCn: USART Receive Complete
        This flag bit is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does
        not contain any unread data). If the receiver is disabled, the receive buffer will be flushed and consequently the RXCn bit will
        become zero. The RXCn flag can be used to generate a receive complete interrupt (see description of the RXCIEn bit).
        • Bit 6 - TXCn: USART Transmit Complete
        This flag bit is set when the entire frame in the transmit shift register has been shifted out and there are no new data currently
        present in the transmit buffer (UDRn). The TXCn flag bit is automatically cleared when a transmit complete interrupt is
        executed, or it can be cleared by writing a one to its bit location. The TXCn flag can generate a transmit complete interrupt
        (see description of the TXCIEn bit).
        • Bit 5 - UDREn: USART Data Register Empty
        The UDREn flag indicates if the transmit buffer (UDRn) is ready to receive new data. If UDREn is one, the buffer is empty,
        and therefore ready to be written. The UDREn flag can generate a data register empty interrupt (see description of the
        UDRIE bit). UDREn is set after a reset to indicate that the transmitter is ready.
        • Bit 4:0 - Reserved Bits in MSPI mode
        When in MSPI mode, these bits are reserved for future use. For compatibility with future devices, these bits must be written
        to zero when UCSRnA is written.
5.20.8.3 UCSRnB – USART MSPIM Control and Status Register n B
                  Bit           7           6          5         4           3         2        1         0
                              RXCIEn    TXCIEn      UDRIE     RXENn       TXENn        -        -         -    UCSRnB
            Read/Write         R/W         R/W       R/W       R/W         R/W         R        R         R
            Initial Value       0           0          0         0           0         1        1         0
        • Bit 7 - RXCIEn: RX Complete Interrupt Enable
        Writing this bit to one enables interrupt on the RXCn flag. A USART receive complete interrupt will be generated only if the
        RXCIEn bit is written to one, the global interrupt flag in SREG is written to one and the RXCn bit in UCSRnA is set.
        • Bit 6 - TXCIEn: TX Complete Interrupt Enable
        Writing this bit to one enables interrupt on the TXCn flag. A USART transmit complete interrupt will be generated only if the
        TXCIEn bit is written to one, the global interrupt flag in SREG is written to one and the TXCn bit in UCSRnA is set.
        • Bit 5 - UDRIE: USART Data Register Empty Interrupt Enable
        Writing this bit to one enables interrupt on the UDREn flag. A data register empty interrupt will be generated only if the
        UDRIE bit is written to one, the global interrupt flag in SREG is written to one and the UDREn bit in UCSRnA is set.
        • Bit 4 - RXENn: Receiver Enable
        Writing this bit to one enables the USART receiver in MSPIM mode. The receiver will override normal port operation for the
        RxDn pin when enabled. Disabling the receiver will flush the receive buffer. Only enabling the receiver in MSPI mode (i.e.
        setting RXENn=1 and TXENn=0) has no meaning since it is the transmitter that controls the transfer clock and since only
        master mode is supported.
192     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        • Bit 3 - TXENn: Transmitter Enable
        Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxDn pin
        when enabled. The disabling of the transmitter (writing TXENn to zero) will not become effective until ongoing and pending
        transmissions are completed, i.e., when the transmit shift register and transmit buffer register do not contain data to be
        transmitted. When disabled, the transmitter will no longer override the TxDn port.
        • Bit 2:0 - Reserved Bits in MSPI mode
        When in MSPI mode, these bits are reserved for future use. For compatibility with future devices, these bits must be written
        to zero when UCSRnB is written.
5.20.8.4 UCSRnC – USART MSPIM Control and Status Register n C
                 Bit          7           6          5      4        3       2           1           0
                          UMSELn1     UMSELn0        -       -       -    UDORDn      UCPHAn      UCPOLn    UCSRnC
           Read/Write        R/W         R/W         R      R        R      R/W         R/W         R/W
           Initial Value      0           0          0      0        0       1           1           0
        • Bit 7:6 - UMSELn1:0: USART Mode Select
        These bits select the mode of operation of the USART as shown in Table 5-84. See Section 5.19.10.4 “UCSRnC – USART
        Control and Status Register n C” on page 183 for full description of the normal USART operation. The MSPIM is enabled
        when both UMSELn bits are set to one. The UDORDn, UCPHAn, and UCPOLn can be set in the same write operation where
        the MSPIM is enabled.
        Table 5-84. UMSELn Bits Settings
                          UMSELn1                                   UMSELn0                                     Mode
                              0                                         0                              Asynchronous USART
                              0                                         1                               Synchronous USART
                              1                                         0                                    Reserved
                              1                                         1                               Master SPI (MSPIM)
        • Bit 5:3 - Reserved Bits in MSPI mode
        When in MSPI mode, these bits are reserved for future use. For compatibility with future devices, these bits must be written
        to zero when UCSRnC is written.
        • Bit 2 - UDORDn: Data Order
        When set to one the LSB of the data word is transmitted first. When set to zero the MSB of the data word is transmitted first.
        Refer to the frame formats section page 4 for details.
        • Bit 1 - UCPHAn: Clock Phase
        The UCPHAn bit setting determine if data is sampled on the leasing edge (first) or tailing (last) edge of XCKn. Refer to the
        SPI data modes and timing section page 4 for details.
        • Bit 0 - UCPOLn: Clock Polarity
        The UCPOLn bit sets the polarity of the XCKn clock. The combination of the UCPOLn and UCPHAn bit settings determine
        the timing of the data transfer. Refer to the SPI data modes and timing section page 4 for details.
5.20.8.5 USART MSPIM Baud Rate Registers - UBRRnL and UBRRnH
        The function and bit description of the baud rate registers in MSPI mode is identical to normal USART operation, see Section
        5.19.10.5 “UBRRnL and UBRRnH – USART Baud Rate Registers” on page 184.
                                                                                                ATA6614Q [DATASHEET]               193
                                                                                                             9240I–AUTO–03/16


5.21   2-wire Serial Interface
5.21.1 Features
         ●    Simple yet powerful and flexible communication interface, only two bus lines needed
         ●    Both master and slave operation supported
         ●    Device can operate as transmitter or receiver
         ●    7-bit address space allows up to 128 different slave addresses
         ●    Multi-master arbitration support
         ●    Up to 400kHz data transfer speed
         ●    Slew-rate limited output drivers
         ●    Noise suppression circuitry rejects spikes on bus lines
         ●    Fully programmable slave address with general call support
         ●    Address recognition causes wake-up when AVR® is in sleep mode
         ●    Compatible with Philips’ I2C protocol
5.21.2 2-wire Serial Interface Bus Definition
       The 2-wire serial interface (TWI) is ideally suited for typical microcontroller applications. The TWI protocol allows the
       systems designer to interconnect up to 128 different devices using only two bi-directional bus lines, one for clock (SCL) and
       one for data (SDA). The only external hardware needed to implement the bus is a single pull-up resistor for each of the TWI
       bus lines. All devices connected to the bus have individual addresses, and mechanisms for resolving bus contention are
       inherent in the TWI protocol.
       Figure 5-77. TWI Bus Interconnection
                                                                                         VCC
                                       Device 1      Device 2     Device 3  ........ Device n     R1      R2
                         SDA
                         SCL
194    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.21.2.1 TWI Terminology
        The following definitions are frequently encountered in this section.
        Table 5-85. TWI Terminology
         Term                Description
         Master              The device that initiates and terminates a transmission. The master also generates the SCL clock.
         Slave               The device addressed by a master.
         Transmitter         The device placing data on the bus.
         Receiver            The device reading data from the bus.
        The PRTWI bit in Section 5.9.10 “Minimizing Power Consumption” on page 60 must be written to zero to enable the 2-wire
        serial interface.
5.21.2.2 Electrical Interconnection
        As depicted in Figure 5-77, both bus lines are connected to the positive supply voltage through pull-up resistors. The bus
        drivers of all TWI-compliant devices are open-drain or open-collector. This implements a wired-AND function which is
        essential to the operation of the interface. A low level on a TWI bus line is generated when one or more TWI devices output
        a zero. A high level is output when all TWI devices tri-state their outputs, allowing the pull-up resistors to pull the line high.
        Note that all AVR® devices connected to the TWI bus must be powered in order to allow any bus operation.
        The number of devices that can be connected to the bus is only limited by the bus capacitance limit of 400pF and the 7-bit
        slave address space. A detailed specification of the electrical characteristics of the TWI is given in Section 5.28.7 “2-wire
        Serial Interface Characteristics” on page 283. Two different sets of specifications are presented there, one relevant for bus
        speeds below 100 kHz, and one valid for bus speeds up to 400kHz.
5.21.3 Data Transfer and Frame Format
5.21.3.1 Transferring Bits
        Each data bit transferred on the TWI bus is accompanied by a pulse on the clock line. The level of the data line must be
        stable when the clock line is high. The only exception to this rule is for generating start and stop conditions.
        Figure 5-78. Data Validity
                                       SDA
                                       SCL
                                                          Data Stable             Data Stable
                                                                     Data Change
                                                                                                 ATA6614Q [DATASHEET]                   195
                                                                                                                9240I–AUTO–03/16


5.21.3.2 START and STOP Conditions
        The master initiates and terminates a data transmission. The transmission is initiated when the Master issues a START
        condition on the bus, and it is terminated when the master issues a STOP condition. Between a START and a STOP
        condition, the bus is considered busy, and no other master should try to seize control of the bus. A special case occurs when
        a new START condition is issued between a START and STOP condition. This is referred to as a REPEATED START
        condition, and is used when the master wishes to initiate a new transfer without relinquishing control of the bus. After a
        REPEATED START, the bus is considered busy until the next STOP. This is identical to the START behavior, and therefore
        START is used to describe both START and REPEATED START for the remainder of this datasheet, unless otherwise
        noted. As depicted below, START and STOP conditions are signalled by changing the level of the SDA line when the SCL
        line is high.
        Figure 5-79. START, REPEATED START and STOP Conditions
                        SDA
                        SCL
                               START                            STOP    START            REPEATED START              STOP
5.21.3.3 Address Packet Format
        All address packets transmitted on the TWI bus are 9 bits long, consisting of 7 address bits, one READ/WRITE control bit
        and an acknowledge bit. If the READ/WRITE bit is set, a read operation is to be performed, otherwise a write operation
        should be performed. When a slave recognizes that it is being addressed, it should acknowledge by pulling SDA low in the
        ninth SCL (ACK) cycle. If the addressed slave is busy, or for some other reason can not service the master’s request, the
        SDA line should be left high in the ACK clock cycle. The master can then transmit a STOP condition, or a REPEATED
        START condition to initiate a new transmission. An address packet consisting of a slave address and a READ or a WRITE
        bit is called SLA+R or SLA+W, respectively.
        The MSB of the address byte is transmitted first. Slave addresses can freely be allocated by the designer, but the address
        0000 000 is reserved for a general call.
        When a general call is issued, all slaves should respond by pulling the SDA line low in the ACK cycle. A general call is used
        when a Master wishes to transmit the same message to several slaves in the system. When the general call address
        followed by a write bit is transmitted on the bus, all slaves set up to acknowledge the general call will pull the SDA line low in
        the ack cycle. The following data packets will then be received by all the slaves that acknowledged the general call. Note that
        transmitting the general call address followed by a read bit is meaningless, as this would cause contention if several slaves
        started transmitting different data.
        All addresses of the format 1111 xxx should be reserved for future purposes.
        Figure 5-80. Address Packet Format
                                                Addr MSB                           Addr LSB      R/W           ACK
                     SDA
                     SCL
                                                    1             2                    7          8             9
                             START
196     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.21.3.4 Data Packet Format
        All data packets transmitted on the TWI bus are nine bits long, consisting of one data byte and an acknowledge bit. During a
        data transfer, the master generates the clock and the START and STOP conditions, while the receiver is responsible for
        acknowledging the reception. An acknowledge (ACK) is signalled by the receiver pulling the SDA line low during the ninth
        SCL cycle. If the receiver leaves the SDA line high, a NACK is signalled. When the receiver has received the last byte, or for
        some reason cannot receive any more bytes, it should inform the transmitter by sending a NACK after the final byte. The
        MSB of the data byte is transmitted first.
        Figure 5-81. Data Packet Format
                                             Data MSB                                 Data LSB        ACK
                 Aggregate
                    SDA
                  SDA from
                 Transmitter
                  SDA from
                  Receiver
                  SCL from
                   Master
                                                 1          2                   7         8           9
                                                                                                                  STOP, REPEATED
                        SLA + R/W                                          Data Byte
                                                                                                                    START or next
                                                                                                                       Data Byte
5.21.3.5 Combining Address and Data Packets into a Transmission
        A transmission basically consists of a START condition, a SLA+R/W, one or more data packets and a STOP condition. An
        empty message, consisting of a START followed by a STOP condition, is illegal. Note that the Wired-ANDing of the SCL line
        can be used to implement handshaking between the master and the slave. The slave can extend the SCL low period by
        pulling the SCL line low. This is useful if the clock speed set up by the master is too fast for the slave, or the Slave needs
        extra time for processing between the data transmissions. The slave extending the SCL low period will not affect the SCL
        high period, which is determined by the master. As a consequence, the slave can reduce the TWI data transfer speed by
        prolonging the SCL duty cycle.
        Figure 5-82 shows a typical data transmission. Note that several data bytes can be transmitted between the SLA+R/W and
        the STOP condition, depending on the software protocol implemented by the application software.
Figure 5-82. Typical Data Transmission
                     Addr MSB            Addr LSB   R/W     ACK            Data MSB                      Data LSB  ACK
    SDA
    SCL
                         1      2            7        8      9                 1     2             7        8       9
         START                        SLA + R/W                                         Data Byte                                 STOP
                                                                                                 ATA6614Q [DATASHEET]                  197
                                                                                                                 9240I–AUTO–03/16


5.21.4 Multi-master Bus Systems, Arbitration and Synchronization
       The TWI protocol allows bus systems with several masters. Special concerns have been taken in order to ensure that
       transmissions will proceed as normal, even if two or more masters initiate a transmission at the same time. Two problems
       arise in multi-master systems:
         ● An algorithm must be implemented allowing only one of the masters to complete the transmission. All other masters
               should cease transmission when they discover that they have lost the selection process. This selection process is
               called arbitration. When a contending master discovers that it has lost the arbitration process, it should immediately
               switch to slave mode to check whether it is being addressed by the winning master. The fact that multiple masters
               have started transmission at the same time should not be detectable to the slaves, i.e. the data being transferred on
               the bus must not be corrupted.
         ●     Different masters may use different SCL frequencies. A scheme must be devised to synchronize the serial clocks
               from all masters, in order to let the transmission proceed in a lockstep fashion. This will facilitate the arbitration
               process.
       The wired-ANDing of the bus lines is used to solve both these problems. The serial clocks from all masters will be wired-
       ANDed, yielding a combined clock with a high period equal to the one from the master with the shortest high period. The low
       period of the combined clock is equal to the low period of the master with the longest low period. Note that all masters listen
       to the SCL line, effectively starting to count their SCL high and low time-out periods when the combined SCL line goes high
       or low, respectively.
       Figure 5-83. SCL Synchronization between Multiple Masters
                                                         TAlow                         TAhigh
                            SCL from
                            Master A
                            SCL from
                            Master B
                            SCL Bus
                               Line
                                                               TBlow                          TBhigh
                                                              Masters Start                  Masters Start
                                                          Counting Low Period            Counting High Period
       Arbitration is carried out by all masters continuously monitoring the SDA line after outputting data. If the value read from the
       SDA line does not match the value the Master had output, it has lost the arbitration. Note that a master can only lose
       arbitration when it outputs a high SDA value while another master outputs a low value. The losing master should
       immediately go to slave mode, checking if it is being addressed by the winning master. The SDA line should be left high, but
       losing masters are allowed to generate a clock signal until the end of the current data or address packet.
       Arbitration will continue until only one master remains, and this may take many bits. If several masters are trying to address
       the same slave, arbitration will continue into the data packet.
198    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


Figure 5-84. Arbitration between Two Masters
                                                                                     Master A Loses
                                  START
                                                                                Arbitration, SDAA ≠ SDA
                     SDA from
                     Master A
                     SDA from
                     Master B
                     SDA Line
                  Synchronized
                    SCL Line
Note that arbitration is not allowed between:
   ● A REPEATED START condition and a data bit.
   ●     A STOP condition and a data bit.
   ●     A REPEATED START and a STOP condition.
It is the user software’s responsibility to ensure that these illegal arbitration conditions never occur. This implies that in multi-
master systems, all data transfers must use the same composition of SLA+R/W and data packets. In other words: All
transmissions must contain the same number of data packets, otherwise the result of the arbitration is undefined.
                                                                                              ATA6614Q [DATASHEET]              199
                                                                                                         9240I–AUTO–03/16


5.21.5 Overview of the TWI Module
       The TWI module is comprised of several submodules, as shown in Figure 5-85. All registers drawn in a thick line are
       accessible through the AVR® data bus.
       Figure 5-85. Overview of the TWI Module
                                                        SCL                                                        SDA
                                            Slew-rate           Spike                                    Slew-rate       Spike
                                             Control            Filter                                    Control        Filter
                                                                        Bus Interface Unit                                                      Bit Rate Generator
                                                 START/ STOP
                                                                                           Spike Suppression                                             Prescaler
                                                    Control
                                                                                          Address/ Data Shift                                         Bit Rate Register
                                            Arbitration detection                                                        Ack
                                                                                           Register (TWDR)                                                 (TWBR)
                                           Address Match Unit                                                                       Control Unit
                                                                                                                                                                          TWI Unit
                                                 Address Register                                                 Status Register                  Control Register
                                                     (TWAR)                                                          (TWSR)                           (TWCR)
                                                                                                                                  State Machine and
                                              Address Comparator                                                                    Status control
5.21.5.1 SCL and SDA Pins
       These pins interface the AVR TWI with the rest of the MCU system. The output drivers contain a slew-rate limiter in order to
       conform to the TWI specification. The input stages contain a spike suppression unit removing spikes shorter than 50ns. Note
       that the internal pull-ups in the AVR pads can be enabled by setting the PORT bits corresponding to the SCL and SDA pins,
       as explained in the I/O port section. The internal pull-ups can in some systems eliminate the need for external ones.
5.21.5.2 Bit Rate Generator Unit
       This unit controls the period of SCL when operating in a master mode. The SCL period is controlled by settings in the TWI bit
       rate register (TWBR) and the prescaler bits in the TWI status register (TWSR). Slave operation does not depend on bit rate
       or prescaler settings, but the CPU clock frequency in the slave must be at least 16 times higher than the SCL frequency.
       Note that slaves may prolong the SCL low period, thereby reducing the average TWI bus clock period. The SCL frequency is
       generated according to the following equation:
                                         CPU Clock frequency
       SCL frequency = ----------------------------------------------------------------------------------------
                       16 + 2(TWBR)   PrescalerValue 
         ●         TWBR = Value of the TWI bit rate register.
         ●         PrescalerValue = Value of the prescaler, see Table 5-92 on page 221.
       Note:                   Pull-up resistor values should be selected according to the SCL frequency and the capacitive bus line load.
                               See Table 5-134 on page 283 for value of pull-up resistor.
200    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.21.5.3 Bus Interface Unit
        This unit contains the data and address shift register (TWDR), a START/STOP controller and arbitration detection hardware.
        The TWDR contains the address or data bytes to be transmitted, or the address or data bytes received. In addition to the 8-
        bit TWDR, the bus interface unit also contains a register containing the (N)ACK bit to be transmitted or received. This
        (N)ACK register is not directly accessible by the application software. However, when receiving, it can be set or cleared by
        manipulating the TWI control register (TWCR). When in Transmitter mode, the value of the received (N)ACK bit can be
        determined by the value in the TWSR.
        The START/STOP Controller is responsible for generation and detection of START, REPEATED START, and STOP
        conditions. The START/STOP controller is able to detect START and STOP conditions even when the AVR® MCU is in one
        of the sleep modes, enabling the MCU to wake up if addressed by a Master.
        If the TWI has initiated a transmission as master, the arbitration detection hardware continuously monitors the transmission
        trying to determine if arbitration is in process. If the TWI has lost an arbitration, the control unit is informed. Correct action
        can then be taken and appropriate status codes generated.
5.21.5.4 Address Match Unit
        The address match unit checks if received address bytes match the seven-bit address in the TWI address register (TWAR).
        If the TWI general call recognition enable (TWGCE) bit in the TWAR is written to one, all incoming address bits will also be
        compared against the general call address. Upon an address match, the control unit is informed, allowing correct action to
        be taken. The TWI may or may not acknowledge its address, depending on settings in the TWCR. The address match unit is
        able to compare addresses even when the AVR MCU is in sleep mode, enabling the MCU to wake up if addressed by a
        master.
        If another interrupt (e.g., INT0) occurs during TWI power-down address match and wakes up the CPU, the TWI aborts
        operation and return to it’s idle state. If this cause any problems, ensure that TWI address match is the only enabled interrupt
        when entering power-down.
5.21.5.5 Control Unit
        The control unit monitors the TWI bus and generates responses corresponding to settings in the TWI control register
        (TWCR). When an event requiring the attention of the application occurs on the TWI bus, the TWI interrupt flag (TWINT) is
        asserted. In the next clock cycle, the TWI status register (TWSR) is updated with a status code identifying the event. The
        TWSR only contains relevant status information when the TWI interrupt flag is asserted. At all other times, the TWSR
        contains a special status code indicating that no relevant status information is available. As long as the TWINT flag is set, the
        SCL line is held low. This allows the application software to complete its tasks before allowing the TWI transmission to
        continue.
        The TWINT flag is set in the following situations:
           ● After the TWI has transmitted a START/REPEATED START condition.
           ●    After the TWI has transmitted SLA+R/W.
           ●    After the TWI has transmitted an address byte.
           ●    After the TWI has lost arbitration.
           ●    After the TWI has been addressed by own slave address or general call.
           ●    After the TWI has received a data byte.
           ●    After a STOP or REPEATED START has been received while still addressed as a slave.
           ●    When a bus error has occurred due to an illegal START or STOP condition.
5.21.6 Using the TWI
        The AVR TWI is byte-oriented and interrupt based. Interrupts are issued after all bus events, like reception of a byte or
        transmission of a START condition. Because the TWI is interrupt-based, the application software is free to carry on other
        operations during a TWI byte transfer. Note that the TWI interrupt enable (TWIE) bit in TWCR together with the global
        interrupt enable bit in SREG allow the application to decide whether or not assertion of the TWINT flag should generate an
        interrupt request. If the TWIE bit is cleared, the application must poll the TWINT flag in order to detect actions on the TWI
        bus.
        When the TWINT flag is asserted, the TWI has finished an operation and awaits application response. In this case, the TWI
        status register (TWSR) contains a value indicating the current state of the TWI bus. The application software can then
        decide how the TWI should behave in the next TWI bus cycle by manipulating the TWCR and TWDR registers.
                                                                                                   ATA6614Q [DATASHEET]                  201
                                                                                                                    9240I–AUTO–03/16


      Figure 5-86 is a simple example of how the application can interface to the TWI hardware. In this example, a master wishes
      to transmit a single data byte to a slave. This description is quite abstract, a more detailed explanation follows later in this
      section. A simple code example implementing the desired behavior is also presented.
      Figure 5-86. Interfacing the Application to the TWI in a Typical Transmission
                                                3. Check TWSR to see if START was          5. Check TWSR to see if SLA + W was           7. Check TWSR to see if data was sent
                            1. Application
            Application
                                                sent. Application loads SLA + W into              sent and ACK received.                            and ACK received.
                          writes to TWCR to
                                                TWDR, and loads appropriate control        Application loads data intoTWDR, and           Application loads appropriate control
                                initiate
                                                 signals into TWCR, makin sure that         loads appropriate control signals into          signals to send STOP into TWCR,
              Action
                           transmission of
                                                      TWINT is written to one,                TWCR, makin sure that TWINT is                    makin sure that TWINT is
                                START
                                                    and TWSTA is written to zero.                       written to one                                 written to one
                          TWI bus    START                    SLA + W                  A                    Data                     A         STOP
                                                                                                                                                             Indicates
                TWI               2. TWINT set.                             4. TWINT set.                               6. TWINT set.                       TWINT set
              Hardware        Status code indicates                     Status code indicates                       Status code indicates
                              START condition sent                         SLA + W sent,                           data sent, ACK received
               Action                                                       ACK received
       1.       The first step in a TWI transmission is to transmit a START condition. This is done by writing a specific value into
                TWCR, instructing the TWI hardware to transmit a START condition. Which value to write is described later on.
                However, it is important that the TWINT bit is set in the value written. Writing a one to TWINT clears the flag. The
                TWI will not start any operation as long as the TWINT bit in TWCR is set. Immediately after the application has
                cleared TWINT, the TWI will initiate transmission of the START condition.
       2.       When the START condition has been transmitted, the TWINT flag in TWCR is set, and TWSR is updated with a
                status code indicating that the START condition has successfully been sent.
       3.       The application software should now examine the value of TWSR, to make sure that the START condition was
                successfully transmitted. If TWSR indicates otherwise, the application software might take some special action,
                like calling an error routine. Assuming that the status code is as expected, the application must load SLA+W into
                TWDR. Remember that TWDR is used both for address and data. After TWDR has been loaded with the desired
                SLA+W, a specific value must be written to TWCR, instructing the TWI hardware to transmit the SLA+W present in
                TWDR. Which value to write is described later on. However, it is important that the TWINT bit is set in the value
                written. Writing a one to TWINT clears the flag. The TWI will not start any operation as long as the TWINT bit in
                TWCR is set. Immediately after the application has cleared TWINT, the TWI will initiate transmission of the
                address packet.
       4.       When the address packet has been transmitted, the TWINT Flag in TWCR is set, and TWSR is updated with a
                status code indicating that the address packet has successfully been sent. The status code will also reflect
                whether a slave acknowledged the packet or not.
       5.       The application software should now examine the value of TWSR, to make sure that the address packet was suc-
                cessfully transmitted, and that the value of the ACK bit was as expected. If TWSR indicates otherwise, the
                application software might take some special action, like calling an error routine. Assuming that the status code is
                as expected, the application must load a data packet into TWDR. Subsequently, a specific value must be written to
                TWCR, instructing the TWI hardware to transmit the data packet present in TWDR. Which value to write is
                described later on.
                However, it is important that the TWINT bit is set in the value written. Writing a one to TWINT clears the flag. The
                TWI will not start any operation as long as the TWINT bit in TWCR is set. Immediately after the application has
                cleared TWINT, the TWI will initiate transmission of the data packet.
       6.       When the data packet has been transmitted, the TWINT flag in TWCR is set, and TWSR is updated with a status
                code indicating that the data packet has successfully been sent. The status code will also reflect whether a slave
                acknowledged the packet or not.
202   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


          7.    The application software should now examine the value of TWSR, to make sure that the data packet was success-
                fully transmitted, and that the value of the ACK bit was as expected. If TWSR indicates otherwise, the application
                software might take some special action, like calling an error routine. Assuming that the status code is as
                expected, the application must write a specific value to TWCR, instructing the TWI hardware to transmit a STOP
                condition. Which value to write is described later on. However, it is important that the TWINT bit is set in the value
                written. Writing a one to TWINT clears the flag. The TWI will not start any operation as long as the TWINT bit in
                TWCR is set. Immediately after the application has cleared TWINT, the TWI will initiate transmission of the STOP
                condition. Note that TWINT is NOT set after a STOP condition has been sent.
        Even though this example is simple, it shows the principles involved in all TWI transmissions. These can be summarized as
        follows:
          ● When the TWI has finished an operation and expects application response, the TWINT flag is set. The SCL line is
                pulled low until TWINT is cleared.
          ●     When the TWINT flag is set, the user must update all TWI registers with the value relevant for the next TWI bus cycle.
                As an example, TWDR must be loaded with the value to be transmitted in the next bus cycle.
          ●     After all TWI register updates and other pending application software tasks have been completed, TWCR is written.
                When writing TWCR, the TWINT bit should be set. Writing a one to TWINT clears the flag. The TWI will then
                commence executing whatever operation was specified by the TWCR setting.
        In Table 5-86 an assembly and C implementation of the example is given. Note that the code below assumes that several
        definitions have been made, for example by using include-files.
Table 5-86. Assembly and C Implementation
       Assembly Code Example                          C Example                                        Comments
                 ldi       r16,                                TWCR =
                 (1<<TWINT)|(1<<TWSTA)|                        (1<<TWINT)|(1<<TWSTA)|
  1                                                                                                    Send START condition
                 (1<<TWEN)                                     (1<<TWEN)
                 out       TWCR, r16
                 wait1:                                        while
                                                                                                       Wait for TWINT flag set. This
                 in        r16,TWCR                            (!(TWCR & (1<<TWINT)))
  2                                                                                                    indicates that the START
                 sbrs      r16,TWINT                           ;
                                                                                                       condition has been transmitted
                 rjmp      wait1
                 in        r16,TWSR                            if ((TWSR & 0xF8)!= START) Check value of TWI status
                 andi      r16, 0xF8                           ERROR();                                register. Mask prescaler bits. If
                 cpi       r16, START                                                                  status different from START go to
                 brne      ERROR                                                                       ERROR
  3              ldi       r16, SLA_W                          TWDR = SLA_W;
                                                                                                       Load SLA_W into TWDR
                 out       TWDR, r16                           TWCR = (1<<TWINT) |
                                                                                                       register. Clear TWINT bit in
                 ldi       r16, (1<<TWINT) |                   (1<<TWEN);
                                                                                                       TWCR to start transmission of
                 (1<<TWEN)
                                                                                                       address
                 out       TWCR, r16
                 wait2:                                        while                                   Wait for TWINT Flag set. This
                 in        r16,TWCR                            (!(TWCR & (1<<TWINT)))                  indicates that the SLA+W has
  4              sbrs      r16,TWINT                           ;                                       been transmitted, and
                 rjmp      wait2                                                                       ACK/NACK has been received.
                 in        r16,TWSR                            if ((TWSR & 0xF8)!=                     Check value of TWI status
                 andi      r16, 0xF8                           MT_SLA_ACK)                             register. Mask prescaler bits. If
                 cpi       r16, MT_SLA_ACK                     ERROR();                                status different from
                 brne      ERROR                                                                       MT_SLA_ACK go to ERROR
  5              ldi       r16, DATA                           TWDR = DATA;
                 out       TWDR, r16                           TWCR = (1<<TWINT) |                     Load DATA into TWDR register.
                 ldi       r16, (1<<TWINT) |                   (1<<TWEN);                              Clear TWINT bit in TWCR to start
                 (1<<TWEN)                                                                             transmission of data
                 out       TWCR, r16
                                                                                                 ATA6614Q [DATASHEET]                  203
                                                                                                                 9240I–AUTO–03/16


Table 5-86. Assembly and C Implementation (Continued)
       Assembly Code Example                        C Example                                         Comments
                 wait3:                                       while                                   Wait for TWINT flag set. This
                 in       r16,TWCR                            (!(TWCR & (1<<TWINT)))                  indicates that the DATA has been
  6              sbrs     r16,TWINT                           ;                                       transmitted, and ACK/NACK has
                 rjmp     wait3                                                                       been received.
                 in       r16,TWSR                            if ((TWSR & 0xF8)!=                     Check value of TWI status
                 andi     r16, 0xF8                           MT_DATA_ACK)                            register. Mask prescaler bits. If
                 cpi      r16, MT_DATA_ACK                    ERROR();                                status different from
                 brne     ERROR                                                                       MT_DATA_ACK go to ERROR
  7
                 ldi      r16,                                TWCR =
                 (1<<TWINT)|(1<<TWEN)|                        (1<<TWINT)|(1<<TWEN)|
                                                                                                      Transmit STOP condition
                 (1<<TWSTO)                                   (1<<TWSTO);
                 out      TWCR, r16
5.21.7 Transmission Modes
        The TWI can operate in one of four major modes. These are named master transmitter (MT), master receiver (MR), slave
        transmitter (ST) and slave receiver (SR). several of these modes can be used in the same application. As an example, the
        TWI can use MT mode to write data into a TWI EEPROM, MR mode to read the data back from the EEPROM. If other
        masters are present in the system, some of these might transmit data to the TWI, and then SR mode would be used. It is the
        application software that decides which modes are legal.
        The following sections describe each of these modes. Possible status codes are described along with figures detailing data
        transmission in each of the modes. These figures contain the following abbreviations:
                S: START condition
                Rs: REPEATED START condition
                R: Read bit (high level at SDA)
                W: Write bit (low level at SDA)
                A: Acknowledge bit (low level at SDA)
                A: Not acknowledge bit (high level at SDA)
                Data: 8-bit data byte
                P: STOP condition
                SLA: Slave Address
        In Figure 5-88 on page 207 to Figure 5-94 on page 217, circles are used to indicate that the TWINT flag is set. The numbers
        in the circles show the status code held in TWSR, with the prescaler bits masked to zero. At these points, actions must be
        taken by the application to continue or complete the TWI transfer. The TWI transfer is suspended until the TWINT flag is
        cleared by software.
        When the TWINT flag is set, the status code in TWSR is used to determine the appropriate software action. For each status
        code, the required software action and details of the following serial transfer are given in Table 5-87 to Table 5-90. Note that
        the prescaler bits are masked to zero in these tables.
204     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.21.7.1 Master Transmitter Mode
        In the master transmitter mode, a number of data bytes are transmitted to a slave receiver (see Figure 5-87). In order to
        enter a master mode, a START condition must be transmitted. The format of the following address packet determines
        whether master transmitter or master receiver mode is to be entered. If SLA+W is transmitted, MT mode is entered, if SLA+R
        is transmitted, MR mode is entered. All the status codes mentioned in this section assume that the prescaler bits are zero or
        are masked to zero.
        Figure 5-87. Data Transfer in Master Transmitter Mode
                                                                                          VCC
                                          Device 1      Device 2
                                            Master       Slave     Device 3  ........ Device n  R1     R2
                                          Transmitter   Receiver
                             SDA
                             SCL
        A START condition is sent by writing the following value to TWCR:
             TWCR        TWINT       TWEA          TWSTA       TWSTO     TWWC          TWEN       –        TWIE
              value        1            X             1          0          X            1        0          X
        TWEN must be set to enable the 2-wire Serial Interface, TWSTA must be written to one to transmit a START condition and
        TWINT must be written to one to clear the TWINT flag. The TWI will then test the 2-wire serial bus and generate a START
        condition as soon as the bus becomes free. After a START condition has been transmitted, the TWINT flag is set by
        hardware, and the status code in TWSR will be 0x08 (see Table 5-87). In order to enter MT mode, SLA+W must be
        transmitted. This is done by writing SLA+W to TWDR. Thereafter the TWINT bit should be cleared (by writing it to one) to
        continue the transfer. This is accomplished by writing the following value to TWCR:
             TWCR        TWINT       TWEA          TWSTA       TWSTO     TWWC          TWEN       –        TWIE
              value        1            X             0          0          X            1        0          X
        When SLA+W have been transmitted and an acknowledgement bit has been received, TWINT is set again and a number of
        status codes in TWSR are possible. Possible status codes in master mode are 0x18, 0x20, or 0x38. The appropriate action
        to be taken for each of these status codes is detailed in Table 5-87.
        When SLA+W has been successfully transmitted, a data packet should be transmitted. This is done by writing the data byte
        to TWDR. TWDR must only be written when TWINT is high. If not, the access will be discarded, and the write collision bit
        (TWWC) will be set in the TWCR register. After updating TWDR, the TWINT bit should be cleared (by writing it to one) to
        continue the transfer. This is accomplished by writing the following value to TWCR:
             TWCR        TWINT       TWEA          TWSTA       TWSTO     TWWC          TWEN       –        TWIE
              value        1            X             0          0          X            1        0          X
        This scheme is repeated until the last byte has been sent and the transfer is ended by generating a STOP condition or a
        repeated START condition. A STOP condition is generated by writing the following value to TWCR:
             TWCR        TWINT       TWEA          TWSTA       TWSTO     TWWC          TWEN       –        TWIE
              value        1            X             0          1          X            1        0          X
        A REPEATED START condition is generated by writing the following value to TWCR:
             TWCR        TWINT       TWEA          TWSTA       TWSTO     TWWC          TWEN       –        TWIE
              value        1            X             1          0          X            1        0          X
                                                                                               ATA6614Q [DATASHEET]              205
                                                                                                           9240I–AUTO–03/16


          After a repeated START condition (state 0x10) the 2-wire serial Interface can access the same slave again, or a new slave
          without transmitting a STOP condition. Repeated START enables the master to switch between slaves, master transmitter
          mode and master receiver mode without losing control of the bus.
Table 5-87. Status codes for Master Transmitter Mode
 Status Code                                          Application Software Response
   (TWSR)                                                                 To TWCR
  Prescaler     Status of the 2-wire Serial
     Bits          Bus and 2-wire Serial
     are 0          Interface Hardware         To/from TWDR      STA    STO   TWINT TWEA Next Action Taken by TWI Hardware
                   A START condition has        Load SLA+W         0     0      1     X   SLA+W will be transmitted;
     0x08
                      been transmitted                                                    ACK or NOT ACK will be received
                                               Load SLA+W or       0     0      1     X   SLA+W will be transmitted;
                A repeated START condition                                                ACK or NOT ACK will be received
     0x10
                    has been transmitted        Load SLA+R         0     0      1     X   SLA+R will be transmitted;
                                                                                          Logic will switch to Master Receiver mode
                                              Load data byte or    0     0      1     X   Data byte will be transmitted and ACK or NOT
                                                                                          ACK will be received
                      SLA+W has been         No TWDR action or     1     0      1     X   Repeated START will be transmitted
     0x18                transmitted;        No TWDR action or     0     1      1     X   STOP condition will be transmitted and
                   ACK has been received                                                  TWSTO Flag will be reset
                                              No TWDR action       1     1      1     X   STOP condition followed by a START condition
                                                                                          will be transmitted and TWSTO Flag will be reset
                                              Load data byte or    0     0      1     X   Data byte will be transmitted and ACK or NOT
                                                                                          ACK will be received
                      SLA+W has been         No TWDR action or     1     0      1     X   Repeated START will be transmitted
                         transmitted;
     0x20                                    No TWDR action or     0     1      1     X   STOP condition will be transmitted and
                    NOT ACK has been
                           received                                                       TWSTO Flag will be reset
                                              No TWDR action       1     1      1     X   STOP condition followed by a START condition
                                                                                          will be transmitted and TWSTO Flag will be reset
                                              Load data byte or    0     0      1     X   Data byte will be transmitted and ACK or NOT
                                                                                          ACK will be received
                     Data byte has been      No TWDR action or     1     0      1     X   Repeated START will be transmitted
     0x28                transmitted;        No TWDR action or     0     1      1     X   STOP condition will be transmitted and
                   ACK has been received                                                  TWSTO Flag will be reset
                                              No TWDR action       1     1      1     X   STOP condition followed by a START condition
                                                                                          will be transmitted and TWSTO Flag will be reset
                                              Load data byte or    0     0      1     X   Data byte will be transmitted and ACK or NOT
                                                                                          ACK will be received
                     Data byte has been      No TWDR action or     1     0      1     X   Repeated START will be transmitted
                         transmitted;
     0x30                                    No TWDR action or     0     1      1     X   STOP condition will be transmitted and
                    NOT ACK has been
                           received                                                       TWSTO Flag will be reset
                                              No TWDR action       1     1      1     X   STOP condition followed by a START condition
                                                                                          will be transmitted and TWSTO Flag will be reset
                                             No TWDR action or     0     0      1     X   2-wire Serial Bus will be released and not
                Arbitration lost in SLA+W or                                              addressed Slave mode entered
     0x38
                          data bytes          No TWDR action       1     0      1     X   A START condition will be transmitted when the
                                                                                          bus becomes free
206       ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


Figure 5-88. Formats and States in the Master Transmitter Mode
                                               MT
      Successfull
      transmission           S          SLA  W      A               DATA             A             P
      to a slave
      receiver
                           $08                     $18                              $28
      Next transfer
      started with a                                                                              RS          SLA        W
      repeated start
      condition
                                                                                                  $10
      Not acknowledge
      received after the                            A         P                                                           R
      slave address
                                                   $20
                                                                                                                             MR
      Not acknowledge
                                                                                     A             P
      received after a
      data byte
                                                                                    $30
      Arbitration lost in slave                            Other master                        Other master
                                                  A or A                          A or A
      address or data byte                                  continues                            continues
                                                   $38                              $38
      Arbitration lost and                                 Other master
                                                    A
      addressed as slave                                    continues
                                                                                    To corresponding
                                                   $68   $78     $B0
                                                                                  states in slave mode
                        From master to slave                              Any number of data bytes
                                                   DATA                 A
                                                                          and their associated acknowledge bits
                        From slave to master                              This number (contained in TWSR) corresponds
                                                             n            to a defined state of the Two-Wire Serial Bus.
                                                                          The prescaler bits are zero or masked to zero
                                                                                            ATA6614Q [DATASHEET]                207
                                                                                                             9240I–AUTO–03/16


5.21.7.2 Master Receiver Mode
        In the master receiver mode, a number of data bytes are received from a slave transmitter (slave see Figure 5-89). In order
        to enter a master mode, a START condition must be transmitted. The format of the following address packet determines
        whether master transmitter or master receiver mode is to be entered. If SLA+W is transmitted, MT mode is entered, if SLA+R
        is transmitted, MR mode is entered. All the status codes mentioned in this section assume that the prescaler bits are zero or
        are masked to zero.
        Figure 5-89. Data Transfer in Master Receiver Mode
                                                                                           VCC
                                          Device 1    Device 2
                                           Master        Slave      Device 3  ........ Device n R1     R2
                                          Receiver    Transmitter
                             SDA
                             SCL
        A START condition is sent by writing the following value to TWCR:
             TWCR        TWINT       TWEA         TWSTA        TWSTO      TWWC          TWEN      –        TWIE
              value        1            X           1             0          X            1       0          X
        TWEN must be written to one to enable the 2-wire serial interface, TWSTA must be written to one to transmit a START
        condition and TWINT must be set to clear the TWINT flag. The TWI will then test the 2-wire serial bus and generate a
        START condition as soon as the bus becomes free. After a START condition has been transmitted, the TWINT flag is set by
        hardware, and the status code in TWSR will be 0x08 (See Table 5-87). In order to enter MR mode, SLA+R must be
        transmitted. This is done by writing SLA+R to TWDR. Thereafter the TWINT bit should be cleared (by writing it to one) to
        continue the transfer. This is accomplished by writing the following value to TWCR:
             TWCR        TWINT       TWEA         TWSTA        TWSTO      TWWC          TWEN       –       TWIE
              value        1            X           0             0          X            1        0         X
        When SLA+R have been transmitted and an acknowledgement bit has been received, TWINT is set again and a number of
        status codes in TWSR are possible. Possible status codes in master mode are 0x38, 0x40, or 0x48. The appropriate action
        to be taken for each of these status codes is detailed in Table 5-88. Received data can be read from the TWDR register
        when the TWINT flag is set high by hardware. This scheme is repeated until the last byte has been received. After the last
        byte has been received, the MR should inform the ST by sending a NACK after the last received data byte. The transfer is
        ended by generating a STOP condition or a repeated START condition. A STOP condition is generated by writing the
        following value to TWCR:
             TWCR        TWINT       TWEA         TWSTA        TWSTO      TWWC          TWEN       –       TWIE
              value        1            X           0             1          X            1        0         X
        A REPEATED START condition is generated by writing the following value to TWCR:
             TWCR        TWINT       TWEA         TWSTA        TWSTO      TWWC          TWEN      –        TWIE
              value        1            X           1             0          X            1       0          X
        After a repeated START condition (state 0x10) the 2-wire serial interface can access the same slave again, or a new slave
        without transmitting a STOP condition. Repeated START enables the master to switch between slaves, master transmitter
        mode and master receiver mode without losing control over the bus.
208     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


Table 5-88. Status codes for Master Receiver Mode
 Status Code                                      Application Software Response
   (TWSR)                                                             To TWCR
  Prescaler  Status of the 2-wire Serial
     Bits       Bus and 2-wire Serial
     are 0       Interface Hardware        To/from TWDR      STA    STO   TWINT TWEA Next Action Taken by TWI Hardware
                A START condition has                                                SLA+R will be transmitted
     0x08                                   Load SLA+R        0      0      1     X
                   been transmitted                                                  ACK or NOT ACK will be received
                                           Load SLA+R or      0      0      1     X  SLA+R will be transmitted
             A repeated START condition                                              ACK or NOT ACK will be received
     0x10
                 has been transmitted       Load SLA+W        0      0      1     X  SLA+W will be transmitted
                                                                                     Logic will switch to master transmitter mode
                                          No TWDR action
                                                              0      0      1     X  2-wire serial bus will be released and not
                                                 or
             Arbitration lost in SLA+R or                                            addressed slave mode will be entered
     0x38
                     NOT ACK bit                                     0      1     X  A START condition will be transmitted when the
                                          No TWDR action
                                                              1                      bus becomes free
                                          No TWDR action
                                                              0      0      1     0  Data byte will be received and NOT ACK will be
                   SLA+R has been                or
                                                                                     returned
     0x40             transmitted;
                                                              0      0      1     1  Data byte will be received and ACK will be
                ACK has been received     No TWDR action
                                                                                     returned
                                          No TWDR action
                                                 or           1      0      1     X  Repeated START will be transmitted
                   SLA+R has been
                      transmitted;        No TWDR action      0      1      1     X  STOP condition will be transmitted and TWSTO
     0x48                                        or                                  Flag will be reset
                 NOT ACK has been
                        received                              1      1      1     X  STOP condition followed by a START condition
                                          No TWDR action                             will be transmitted and TWSTO Flag will be reset
                                          Read data byte or   0      0      1     0  Data byte will be received and NOT ACK will be
                  Data byte has been
                                                                                     returned
     0x50               received;
                                           Read data byte     0      0      1     1  Data byte will be received and ACK will be
                ACK has been returned
                                                                                     returned
                                          Read data byte or   1      0      1     X  Repeated START will be transmitted
                  Data byte has been
                        received;         Read data byte or   0      1      1     X  STOP condition will be transmitted and TWSTO
     0x58                                                                            Flag will be reset
                 NOT ACK has been
                        returned           Read data byte     1      1      1     X  STOP condition followed by a START condition
                                                                                     will be transmitted and TWSTO Flag will be reset
                                                                                           ATA6614Q [DATASHEET]                   209
                                                                                                           9240I–AUTO–03/16


Figure 5-90. Formats and States in the Master Receiver Mode
                                              MR
    Successfull
    reception              S          SLA   R       A               DATA                A           DATA        A            P
    from a slave
    receiver
                         $08                       $40                                 $50                     $58
    Next transfer
    started with a                                                                                                          RS    SLA R
    repeated start
    condition
                                                                                                                            $10
    Not acknowledge
    received after the                              A         P                                                                       W
    slave address
                                                   $48
                                                                                                                                        MT
    Arbitration lost in slave                              Other master                           Other master
                                                  A or A                             A or A
    address or data byte                                    continues                               continues
                                                   $38                                 $38
    Arbitration lost and                                   Other master
                                                     A
    addressed as slave                                      continues
                                                                                       To corresponding
                                                   $68   $78     $B0
                                                                                     states in slave mode
                      From master to slave                                   Any number of data bytes
                                                   DATA                 A
                                                                             and their associated acknowledge bits
                      From slave to master                                   This number (contained in TWSR) corresponds
                                                             n               to a defined state of the Two-Wire Serial Bus.
                                                                             The prescaler bits are zero or masked to zero
5.21.7.3 Slave Receiver Mode
           In the slave receiver mode, a number of data bytes are received from a master transmitter (see Figure 5-91). All the status
           codes mentioned in this section assume that the prescaler bits are zero or are masked to zero.
           Figure 5-91. Data transfer in Slave Receiver Mode
                                                                                                          VCC
                                              Device 1    Device 2
                                               Slave        Master        Device 3    ........ Device n           R1           R2
                                              Receiver    Transmitter
                                        SDA
                                        SCL
210        ATA6614Q [DATASHEET]
           9240I–AUTO–03/16


To initiate the Slave Receiver mode, TWAR and TWCR must be initialized as follows:
       TWAR           TWA6       TWA5         TWA4        TWA3       TWA2          TWA1         TWA0      TWGCE
        value                                  Device’s Own Slave Address
The upper 7 bits are the address to which the 2-wire serial interface will respond when addressed by a master. If the LSB is
set, the TWI will respond to the general call address (0x00), otherwise it will ignore the general call address.
       TWCR          TWINT       TWEA        TWSTA       TWSTO       TWWC          TWEN            –       TWIE
        value            0          1           0           0           0             1            0          X
TWEN must be written to one to enable the TWI. The TWEA bit must be written to one to enable the acknowledgement of
the device’s own slave address or the general call address. TWSTA and TWSTO must be written to zero.
When TWAR and TWCR have been initialized, the TWI waits until it is addressed by its own slave address (or the general
call address if enabled) followed by the data direction bit. If the direction bit is “0” (write), the TWI will operate in SR mode,
otherwise ST mode is entered. After its own slave address and the write bit have been received, the TWINT flag is set and a
valid status code can be read from TWSR. The status code is used to determine the appropriate software action. The
appropriate action to be taken for each status code is detailed in Table 5-89. The slave receiver mode may also be entered if
arbitration is lost while the TWI is in the master mode (see states 0x68 and 0x78).
If the TWEA bit is reset during a transfer, the TWI will return a “Not Acknowledge” (“1”) to SDA after the next received data
byte. This can be used to indicate that the slave is not able to receive any more bytes. While TWEA is zero, the TWI does not
acknowledge its own slave address. However, the 2-wire Serial Bus is still monitored and address recognition may resume
at any time by setting TWEA. This implies that the TWEA bit may be used to temporarily isolate the TWI from the 2-wire
serial bus.
In all sleep modes other than Idle mode, the clock system to the TWI is turned off. If the TWEA bit is set, the interface can
still acknowledge its own slave address or the general call address by using the 2-wire serial bus clock as a clock source.
The part will then wake up from sleep and the TWI will hold the SCL clock low during the wake up and until the TWINT flag is
cleared (by writing it to one). Further data reception will be carried out as normal, with the AVR® clocks running as normal.
Observe that if the AVR is set up with a long start-up time, the SCL line may be held low for a long time, blocking other data
transmissions.
Note that the 2-wire serial interface data register – TWDR does not reflect the last byte present on the bus when waking up
from these sleep modes.
                                                                                            ATA6614Q [DATASHEET]                211
                                                                                                           9240I–AUTO–03/16


Table 5-89. Status Codes for Slave Receiver Mode
 Status Code                                           Application Software Response
   (TWSR)                                                                  To TWCR
  Prescaler      Status of the 2-wire Serial
     Bits           Bus and 2-wire Serial
     are 0           Interface Hardware         To/from TWDR      STA    STO   TWINT TWEA Next Action Taken by TWI Hardware
                    Own SLA+W has been         No TWDR action      X      0      1     0  Data byte will be received and NOT ACK will be
                            received;                 or                                  returned
     0x60
                    ACK has been returned      No TWDR action      X      0      1     1  Data byte will be received and ACK will be
                                                                                          returned
                                               No TWDR action
                Arbitration lost in SLA+R/W as                     X      0      1     0  Data byte will be received and NOT ACK will be
                                                      or
                  master; own SLA+W has                                                   returned
     0x68
                been received; ACK has been                        X      0      1     1  Data byte will be received and ACK will be
                                               No TWDR action
                            returned                                                      returned
                                               No TWDR action
                                                                   X      0      1     0  Data byte will be received and NOT ACK will be
                  General call address has            or
                                                                                          returned
     0x70       been received; ACK has been
                            returned                               X      0      1     1  Data byte will be received and ACK will be
                                               No TWDR action
                                                                                          returned
                                               No TWDR action
                Arbitration lost in SLA+R/W as                     X      0      1     0  Data byte will be received and NOT ACK will be
                                                      or
                 Master; General call address                                             returned
     0x78
                 has been received; ACK has                        X      0      1     1  Data byte will be received and ACK will be
                                               No TWDR action
                         been returned                                                    returned
                  Previously addressed with    Read data byte or   X      0      1     0  Data byte will be received and NOT ACK will be
                 own SLA+W; data has been                                                 returned
     0x80
                   received; ACK has been       Read data byte     X      0      1     1  Data byte will be received and ACK will be
                            returned                                                      returned
                                               Read data byte or    0     0      1     0  Switched to the not addressed Slave mode; no
                                                                                          recognition of own SLA or GCA
                                               Read data byte or    0     0      1     1  Switched to the not addressed Slave mode;
                                                                                          own SLA will be recognized; GCA will be
                                                                                          recognized if TWGCE = “1”
                  Previously addressed with
                 own SLA+W; data has been      Read data byte or    1     0      1     0  Switched to the not addressed Slave mode; no
     0x88                                                                                 recognition of own SLA or GCA; a START
                received; NOT ACK has been
                            returned                                                      condition will be transmitted when the bus
                                                                                          becomes free
                                                Read data byte      1     0      1     1  Switched to the not addressed Slave mode;
                                                                                          own SLA will be recognized; GCA will be
                                                                                          recognized if TWGCE = “1”; a START condition
                                                                                          will be transmitted when the bus becomes free
212       ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


Table 5-89. Status Codes for Slave Receiver Mode (Continued)
 Status Code                                        Application Software Response
   (TWSR)                                                               To TWCR
  Prescaler   Status of the 2-wire Serial
     Bits        Bus and 2-wire Serial
     are 0        Interface Hardware         To/from TWDR      STA    STO   TWINT TWEA Next Action Taken by TWI Hardware
               Previously addressed with    Read data byte or   X      0      1     0  Data byte will be received and NOT ACK will be
              general call; data has been                                              returned
     0x90
                received; ACK has been       Read data byte     X      0      1     1  Data byte will be received and ACK will be
                        returned                                                       returned
                                            Read data byte or    0     0      1     0  Switched to the not addressed Slave mode; no
                                                                                       recognition of own SLA or GCA
                                            Read data byte or    0     0      1     1  Switched to the not addressed Slave mode;
                                                                                       own SLA will be recognized; GCA will be
                                                                                       recognized if TWGCE = “1”
               Previously addressed with
              general call; data has been   Read data byte or    1     0      1     0  Switched to the not addressed Slave mode; no
     0x98                                                                              recognition of own SLA or GCA; a START
             received; NOT ACK has been
                        returned                                                       condition will be transmitted when the bus
                                                                                       becomes free
                                             Read data byte      1     0      1     1  Switched to the not addressed Slave mode;
                                                                                       own SLA will be recognized; GCA will be
                                                                                       recognized if TWGCE = “1”; a START condition
                                                                                       will be transmitted when the bus becomes free
                                                                 0     0      1     0  Switched to the not addressed Slave mode; no
                                                                                       recognition of own SLA or GCA
                                                                 0     0      1     1  Switched to the not addressed Slave mode;
                                                                                       own SLA will be recognized; GCA will be
                                                                                       recognized if TWGCE = “1”
             A STOP condition or repeated
               START condition has been                          1     0      1     0  Switched to the not addressed Slave mode; no
     0xA0                                       No action                              recognition of own SLA or GCA; a START
             received while still addressed
                        as Slave                                                       condition will be transmitted when the bus
                                                                                       becomes free
                                                                 1     0      1     1  Switched to the not addressed Slave mode;
                                                                                       own SLA will be recognized; GCA will be
                                                                                       recognized if TWGCE = “1”; a START condition
                                                                                       will be transmitted when the bus becomes free
                                                                                            ATA6614Q [DATASHEET]                  213
                                                                                                            9240I–AUTO–03/16


    Figure 5-92. Formats and States in the Slave Receiver Mode
        Reception of the own
        slave address and one or         S            SLA          W  A     DATA            A          DATA         A          P or S
        more data bytes. All are
        acknowledged
                                                                     $60                   $80                     $80          $A0
        Last data byte received
        is not acknowledged                                                                                         A          P or S
                                                                                                                   $88
        Arbitration lost as master
        and addressed as slave                                        A
        Reception of the general call                                $68
        address and one or more
        data bytes
                                                        General Call  A     DATA            A          DATA         A          P or S
                                                                     $70                   $90                     $90          $A0
        Last data byte received
                                                                                                                    A          P or S
        is not acknowledged
                                                                                                                   $98
        Arbitration lost as master
                                                                      A
        and as slave by general call
                                                                     $78
                                      From master to slave                       Any number of data bytes
                                                                     DATA     A
                                                                                 and their associated acknowledge bits
                                      From slave to master                       This number (contained in TWSR) corresponds
                                                                          n      to a defined state of the Two-Wire Serial Bus.
                                                                                 The prescaler bits are zero or masked to zero
214 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.21.7.4 Slave Transmitter Mode
        In the slave transmitter mode, a number of data bytes are transmitted to a master receiver (see Figure 5-93). All the status
        codes mentioned in this section assume that the prescaler bits are zero or are masked to zero.
        Figure 5-93. Data Transfer in Slave Transmitter Mode
                                                                                                VCC
                                            Device 1       Device 2
                                               Slave         Master     Device 3  ........ Device n   R1       R2
                                            Transmitter    Receiver
                              SDA
                              SCL
        To initiate the slave transmitter mode, TWAR and TWCR must be initialized as follows:
               TWAR           TWA6         TWA5          TWA4        TWA3        TWA2        TWA1      TWA0       TWGCE
                value                                     Device’s Own Slave Address
        The upper seven bits are the address to which the 2-wire serial interface will respond when addressed by a master. If the
        LSB is set, the TWI will respond to the general call address (0x00), otherwise it will ignore the general call address.
               TWCR          TWINT         TWEA         TWSTA       TWSTO        TWWC        TWEN         –        TWIE
                value            0            1            0           0           0            1         0           X
        TWEN must be written to one to enable the TWI. The TWEA bit must be written to one to enable the acknowledgement of
        the device’s own slave address or the general call address. TWSTA and TWSTO must be written to zero.
        When TWAR and TWCR have been initialized, the TWI waits until it is addressed by its own slave address (or the general
        call address if enabled) followed by the data direction bit. If the direction bit is “1” (read), the TWI will operate in ST mode,
        otherwise SR mode is entered. After its own slave address and the write bit have been received, the TWINT flag is set and a
        valid status code can be read from TWSR. The status code is used to determine the appropriate software action. The
        appropriate action to be taken for each status code is detailed in Table 5-90. The slave transmitter mode may also be
        entered if arbitration is lost while the TWI is in the master mode (see state 0xB0).
        If the TWEA bit is written to zero during a transfer, the TWI will transmit the last byte of the transfer. State 0xC0 or state 0xC8
        will be entered, depending on whether the master receiver transmits a NACK or ACK after the final byte. The TWI is
        switched to the not addressed slave mode, and will ignore the master if it continues the transfer. Thus the master receiver
        receives all “1” as serial data. State 0xC8 is entered if the master demands additional data bytes (by transmitting ACK), even
        though the slave has transmitted the last byte (TWEA zero and expecting NACK from the master).
        While TWEA is zero, the TWI does not respond to its own slave address. However, the 2-wire serial bus is still monitored
        and address recognition may resume at any time by setting TWEA. This implies that the TWEA bit may be used to
        temporarily isolate the TWI from the 2-wire serial bus.
        In all sleep modes other than Idle mode, the clock system to the TWI is turned off. If the TWEA bit is set, the interface can
        still acknowledge its own slave address or the general call address by using the 2-wire serial bus clock as a clock source.
        The part will then wake up from sleep and the TWI will hold the SCL clock will low during the wake up and until the TWINT
        flag is cleared (by writing it to one). Further data transmission will be carried out as normal, with the AVR® clocks running as
        normal. Observe that if the AVR is set up with a long start-up time, the SCL line may be held low for a long time, blocking
        other data transmissions.
        Note that the 2-wire serial interface data register – TWDR does not reflect the last byte present on the bus when waking up
        from these sleep modes.
                                                                                                    ATA6614Q [DATASHEET]                215
                                                                                                                   9240I–AUTO–03/16


Table 5-90. Status Codes for Slave Transmitter Mode
   Status                                             Application Software Response
   Code                                                                   To TWCR
  (TWSR)
 Prescaler      Status of the 2-wire Serial
    Bits           Bus and 2-wire Serial
    are 0           Interface Hardware         To/from TWDR      STA    STO   TWINT TWEA Next Action Taken by TWI Hardware
                   Own SLA+R has been         Load data byte or    X      0     1     0  Last data byte will be transmitted and NOT ACK
                          received;                                                      should be received
    0xA8
                  ACK has been returned        Load data byte      X      0     1     1  Data byte will be transmitted and ACK should be
                                                                                         received
              Arbitration lost in SLA+R/W as  Load data byte or    X      0     1     0  Last data byte will be transmitted and NOT ACK
              master; own SLA+R has been                                                 should be received
    0xB0
                  received; ACK has been       Load data byte      X      0     1     1  Data byte will be transmitted and ACK should be
                          returned                                                       received
                                              Load data byte or    X      0     1     0  Last data byte will be transmitted and NOT ACK
               Data byte in TWDR has been                                                should be received
    0xB8        transmitted; ACK has been
                          received             Load data byte      X      0     1     1  Data byte will be transmitted and ACK should be
                                                                                         received
                                             No TWDR action or     0      0     1     0  Switched to the not addressed slave mode; no
                                                                                         recognition of own SLA or GCA
                                             No TWDR action or     0      0     1     1  Switched to the not addressed slave mode; own
                                                                                         SLA will be recognized; GCA will be recognized
                                                                                         if TWGCE = “1”
               Data byte in TWDR has been No TWDR action or        1      0     1     0  Switched to the not addressed slave mode; no
    0xC0        transmitted; NOT ACK has                                                 recognition of own SLA or GCA; a START
                       been received                                                     condition will be transmitted when the bus
                                                                                         becomes free
                                              No TWDR action       1      0     1     1  Switched to the not addressed slave mode; own
                                                                                         SLA will be recognized; GCA will be recognized
                                                                                         if TWGCE = “1”; a START condition will be
                                                                                         transmitted when the bus becomes free
                                             No TWDR action or     0      0     1     0  Switched to the not addressed slave mode; no
                                                                                         recognition of own SLA or GCA
                                             No TWDR action or     0      0     1     1  Switched to the not addressed slave mode; own
                                                                                         SLA will be recognized; GCA will be recognized
                                                                                         if TWGCE = “1”
               Last data byte in TWDR has
                      been transmitted       No TWDR action or     1      0     1     0  Switched to the not addressed slave mode; no
    0xC8                                                                                 recognition of own SLA or GCA; a START
                       (TWEA = “0”);
                  ACK has been received                                                  condition will be transmitted when the bus
                                                                                         becomes free
                                              No TWDR action       1      0     1     1  Switched to the not addressed slave mode; own
                                                                                         SLA will be recognized; GCA will be recognized
                                                                                         if TWGCE = “1”; a START condition will be
                                                                                         transmitted when the bus becomes free
216       ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


        Figure 5-94. Formats and States in the Slave Transmitter Mode
         Reception of the own
         slave address and one            S        SLA        R        A             DATA                   A        DATA            A     P or S
         or more data bytes
                                                                      $A8                                 $B8                      $C0
         Arbitration lost as master
                                                                       A
         and addressed as slave
                                                                      $B0
         Last data byte transmitted.
                                                                                                                                     A     All 1’s  P or S
         Switched to not adressed
         slave (TWEA = “0”
                                                                                                                                   $C8
                            From master to slave                                      Any number of data bytes
                                                               DATA            A
                                                                                      and their associated acknowledge bits
                            From slave to master                                      This number (contained in TWSR) corresponds
                                                                        n             to a defined state of the Two-Wire Serial Bus.
                                                                                      The prescaler bits are zero or masked to zero
5.21.7.5 Miscellaneous States
        There are two status codes that do not correspond to a defined TWI state, see Table 5-91.
        Status 0xF8 indicates that no relevant information is available because the TWINT flag is not set. This occurs between other
        states, and when the TWI is not involved in a serial transfer.
        Status 0x00 indicates that a bus error has occurred during a 2-wire serial bus transfer. A bus error occurs when a START or
        STOP condition occurs at an illegal position in the format frame. Examples of such illegal positions are during the serial
        transfer of an address byte, a data byte, or an acknowledge bit. When a bus error occurs, TWINT is set. To recover from a
        bus error, the TWSTO flag must set and TWINT must be cleared by writing a logic one to it. This causes the TWI to enter the
        not addressed slave mode and to clear the TWSTO flag (no other bits in TWCR are affected). The SDA and SCL lines are
        released, and no STOP condition is transmitted.
        Table 5-91. Miscellaneous States
         Status Code                                            Application Software Response
             (TWSR)              Status of the 2-wire                              To TWCR
            Prescaler          Serial Bus and 2-wire
               Bits                 Serial Interface
               are 0                   Hardware           To/from TWDR     STA   STO TWINT TWEA Next Action Taken by TWI Hardware
                                   No relevant state
               0xF8             information available;    No TWDR action        No TWCR action                Wait or proceed current transfer
                                     TWINT = “0”
                                                                                                              Only the internal hardware is affected, no
                              Bus error due to an illegal                                                     STOP condition is sent on the bus. In all
               0x00                                       No TWDR action    0      1        1         X
                              START or STOP condition                                                         cases, the bus is released and TWSTO is
                                                                                                              cleared.
                                                                                                                ATA6614Q [DATASHEET]                    217
                                                                                                                                  9240I–AUTO–03/16


5.21.7.6 Combining Several TWI Modes
        In some cases, several TWI modes must be combined in order to complete the desired action. Consider for example reading
        data from a serial EEPROM. Typically, such a transfer involves the following steps:
           1. The transfer must be initiated.
           2.   The EEPROM must be instructed what location should be read.
           3.   The reading must be performed.
           4.   The transfer must be finished.
        Note that data is transmitted both from master to slave and vice versa. The master must instruct the slave what location it
        wants to read, requiring the use of the MT mode. Subsequently, data must be read from the slave, implying the use of the
        MR mode. Thus, the transfer direction must be changed. The master must keep control of the bus during all these steps, and
        the steps should be carried out as an atomical operation. If this principle is violated in a multi master system, another master
        can alter the data pointer in the EEPROM between steps 2 and 3, and the master will read the wrong data location. Such a
        change in transfer direction is accomplished by transmitting a REPEATED START between the transmission of the address
        byte and reception of the data. After a REPEATED START, the master keeps ownership of the bus. The following figure
        shows the flow in this transfer.
        Figure 5-95. Combining Several TWI Modes to Access a Serial EEPROM
                                                        Master Transmitter                                   Master Receiver
                             S       SLA + W         A     ADDRESS        A   RS        SLA + R         A       DATA         A P
                              S = START                                     RS = REPEATED START                         P = STOP
                                    Transmitted from master to slave           Transmitted from slave to master
5.21.8 Multi-master Systems and Arbitration
        If multiple masters are connected to the same bus, transmissions may be initiated simultaneously by one or more of them.
        The TWI standard ensures that such situations are handled in such a way that one of the masters will be allowed to proceed
        with the transfer, and that no data will be lost in the process. An example of an arbitration situation is depicted below, where
        two masters are trying to transmit data to a slave receiver.
        Figure 5-96. An Arbitration Example
                                                                                                   VCC
                                            Device 1      Device 2      Device 3
                                              Master        Master         Slave    ........  Device n       R1       R2
                                           Transmitter    Transmitter    Receiver
                            SDA
                            SCL
        Several different scenarios may arise during arbitration, as described below:
           ● Two or more masters are performing identical communication with the same slave. In this case, neither the slave nor
                any of the masters will know about the bus contention.
           ●    Two or more masters are accessing the same slave with different data or direction bit. In this case, arbitration will
                occur, either in the READ/WRITE bit or in the data bits. The masters trying to output a one on SDA while another
                master outputs a zero will lose the arbitration. Losing masters will switch to not addressed slave mode or wait until the
                bus is free and transmit a new START condition, depending on application software action.
218     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


          ●      Two or more masters are accessing different slaves. In this case, arbitration will occur in the SLA bits. masters trying
                 to output a one on SDA while another master outputs a zero will lose the arbitration. Masters losing arbitration in SLA
                 will switch to slave mode to check if they are being addressed by the winning master. If addressed, they will switch to
                 SR or ST mode, depending on the value of the READ/WRITE bit. If they are not being addressed, they will switch to
                 not addressed slave mode or wait until the bus is free and transmit a new START condition, depending on application
                 software action.
        This is summarized in Figure 5-97. Possible status values are given in circles.
        Figure 5-97. Possible Status Codes Caused by Arbitration
                     START                             SLA                                          DATA                                STOP
                                                 Arbitration lost in SLA      Arbitration lost in DATA
                                            Own               NO           38       TWI bus will be released and not addressed slave mode will be entered
                                    Address/ General Call                           A START condition will be transmitted when the bus becomes free
                                          received
                                               YES
                                                        Write             68/78     Data byte will be received and NOT ACK will be returned
                                          Direction
                                                                                    Data byte will be received and ACK will be returned
                                                        Read                        Last data byte will be transmitted and NOT ACK should be received
                                                                           B0       Data byte will be transmitted and ACK should be received
5.21.9 Register Description
5.21.9.1 TWBR – TWI Bit Rate Register
                 Bit           7            6             5           4    3           2                1             0
              (0xB8)        TWBR7       TWBR6         TWBR5        TWBR4 TWBR3     TWBR2           TWBR1         TWBR0           TWBR
           Read/Write         R/W         R/W           R/W          R/W  R/W        R/W             R/W            R/W
           Initial Value       0            0             0           0    0           0                0             0
        • Bits 7..0 – TWI Bit Rate Register
        TWBR selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the
        SCL clock frequency in the Master modes. See Section 5.21.5.2 “Bit Rate Generator Unit” on page 200 for calculating bit
        rates.
5.21.9.2 TWCR – TWI Control Register
                 Bit           7            6             5           4    3           2                1             0
             (0xBC)         TWINT       TWEA          TWSTA        TWSTO TWWC       TWEN                –          TWIE          TWCR
           Read/Write         R/W         R/W           R/W          R/W   R         R/W               R            R/W
           Initial Value       0            0             0           0    0           0                0             0
        The TWCR is used to control the operation of the TWI. It is used to enable the TWI, to initiate a master access by applying a
        START condition to the bus, to generate a receiver acknowledge, to generate a stop condition, and to control halting of the
        bus while the data to be written to the bus are written to the TWDR. It also indicates a write collision if data is attempted
        written to TWDR while the register is inaccessible.
                                                                                                               ATA6614Q [DATASHEET]                       219
                                                                                                                                  9240I–AUTO–03/16


    • Bit 7 – TWINT: TWI Interrupt Flag
    This bit is set by hardware when the TWI has finished its current job and expects application software response. If the I-bit in
    SREG and TWIE in TWCR are set, the MCU will jump to the TWI interrupt vector. While the TWINT flag is set, the SCL low
    period is stretched. The TWINT flag must be cleared by software by writing a logic one to it. Note that this flag is not
    automatically cleared by hardware when executing the interrupt routine. Also note that clearing this flag starts the operation
    of the TWI, so all accesses to the TWI address register (TWAR), TWI status register (TWSR), and TWI data register (TWDR)
    must be complete before clearing this flag.
    • Bit 6 – TWEA: TWI Enable Acknowledge Bit
    The TWEA bit controls the generation of the acknowledge pulse. If the TWEA bit is written to one, the ACK pulse is
    generated on the TWI bus if the following conditions are met:
      1. The device’s own slave address has been received.
      2.   A general call has been received, while the TWGCE bit in the TWAR is set.
      3.   A data byte has been received in Master Receiver or Slave Receiver mode.
    By writing the TWEA bit to zero, the device can be virtually disconnected from the 2-wire serial bus temporarily. Address
    recognition can then be resumed by writing the TWEA bit to one again.
    • Bit 5 – TWSTA: TWI START Condition Bit
    The application writes the TWSTA bit to one when it desires to become a master on the 2-wire serial bus. The TWI hardware
    checks if the bus is available, and generates a START condition on the bus if it is free. However, if the bus is not free, the
    TWI waits until a STOP condition is detected, and then generates a new START condition to claim the bus master status.
    TWSTA must be cleared by software when the START condition has been transmitted.
    • Bit 4 – TWSTO: TWI STOP Condition Bit
    Writing the TWSTO bit to one in master mode will generate a STOP condition on the 2-wire serial bus. When the STOP
    condition is executed on the bus, the TWSTO bit is cleared automatically. In slave mode, setting the TWSTO bit can be used
    to recover from an error condition. This will not generate a STOP condition, but the TWI returns to a well-defined
    unaddressed Slave mode and releases the SCL and SDA lines to a high impedance state.
    • Bit 3 – TWWC: TWI Write Collision Flag
    The TWWC bit is set when attempting to write to the TWI data register – TWDR when TWINT is low. This flag is cleared by
    writing the TWDR register when TWINT is high.
    • Bit 2 – TWEN: TWI Enable Bit
    The TWEN bit enables TWI operation and activates the TWI interface. When TWEN is written to one, the TWI takes control
    over the I/O pins connected to the SCL and SDA pins, enabling the slew-rate limiters and spike filters. If this bit is written to
    zero, the TWI is switched off and all TWI transmissions are terminated, regardless of any ongoing operation.
    • Bit 1 – Res: Reserved Bit
    This bit is a reserved bit and will always read as zero.
    • Bit 0 – TWIE: TWI Interrupt Enable
    When this bit is written to one, and the I-bit in SREG is set, the TWI interrupt request will be activated for as long as the
    TWINT Flag is high.
220 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.21.9.3 TWSR – TWI Status Register
                 Bit          7          6         5          4           3          2         1         0
              (0xB9)        TWS7      TWS6      TWS5        TWS4        TWS3         –     TWPS1      TWPS0      TWSR
           Read/Write         R          R         R          R           R          R       R/W        R/W
           Initial Value      1          1         1          1           1          0         0         0
        • Bits 7..3 – TWS: TWI Status
        These 5 bits reflect the status of the TWI logic and the 2-wire serial bus. The different status codes are described later in this
        section. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The
        application designer should mask the prescaler bits to zero when checking the status bits. This makes status checking
        independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted.
        • Bit 2 – Res: Reserved Bit
        This bit is reserved and will always read as zero.
        • Bits 1..0 – TWPS: TWI Prescaler Bits
        These bits can be read and written, and control the bit rate prescaler.
        Table 5-92. TWI Bit Rate Prescaler
                        TWPS1                            TWPS0                                       Prescaler Value
                          0                                 0                                                1
                          0                                 1                                                4
                          1                                 0                                               16
                          1                                 1                                               64
        To calculate bit rates, see Section 5.21.5.2 “Bit Rate Generator Unit” on page 200. The value of TWPS1..0 is used in the
        equation.
5.21.9.4 TWDR – TWI Data Register
                 Bit          7          6         5           4          3          2         1         0
             (0xBB)         TWD7      TWD6      TWD5        TWD4        TWD3       TWD2     TWD1       TWD0      TWDR
           Read/Write        R/W       R/W       R/W         R/W         R/W        R/W      R/W        R/W
           Initial Value      1          1         1           1          1          1         1         1
        In transmit mode, TWDR contains the next byte to be transmitted. In receive mode, the TWDR contains the last byte
        received. It is writable while the TWI is not in the process of shifting a byte. This occurs when the TWI interrupt flag (TWINT)
        is set by hardware. Note that the data register cannot be initialized by the user before the first interrupt occurs. The data in
        TWDR remains stable as long as TWINT is set. While data is shifted out, data on the bus is simultaneously shifted in. TWDR
        always contains the last byte present on the bus, except after a wake up from a sleep mode by the TWI interrupt. In this
        case, the contents of TWDR is undefined.
        In the case of a lost bus arbitration, no data is lost in the transition from master to slave. Handling of the ACK bit is controlled
        automatically by the TWI logic, the CPU cannot access the ACK bit directly.
        • Bits 7..0 – TWD: TWI Data Register
        These eight bits constitute the next data byte to be transmitted, or the latest data byte received on the 2-wire serial bus.
                                                                                                    ATA6614Q [DATASHEET]                221
                                                                                                                  9240I–AUTO–03/16


5.21.9.5 TWAR – TWI (Slave) Address Register
                 Bit          7           6        5          4         3          2         1         0
             (0xBA)         TWA6        TWA5     TWA4      TWA3       TWA2      TWA1       TWA0      TWGCE   TWAR
            Read/Write       R/W         R/W      R/W        R/W       R/W       R/W        R/W       R/W
           Initial Value      1           1        1          1         1          1         1         0
        The TWAR should be loaded with the 7-bit Slave address (in the seven most significant bits of TWAR) to which the TWI will
        respond when programmed as a slave transmitter or receiver, and not needed in the Master modes. In multi master
        systems, TWAR must be set in masters which can be addressed as slaves by other masters.
        The LSB of TWAR is used to enable recognition of the general call address (0x00). There is an associated address
        comparator that looks for the slave address (or general call address if enabled) in the received serial address. If a match is
        found, an interrupt request is generated.
        • Bits 7..1 – TWA: TWI (Slave) Address Register
        These seven bits constitute the slave address of the TWI unit.
        • Bit 0 – TWGCE: TWI General Call Recognition Enable Bit
        If set, this bit enables the recognition of a general call given over the 2-wire serial bus.
5.21.9.6 TWAMR – TWI (Slave) Address Mask Register
                 Bit          7           6        5          4         3          2         1         0
             (0xBD)                                      TWAM[6:0]                                     –    TWAMR
            Read/Write       R/W         R/W      R/W        R/W       R/W       R/W        R/W        R
           Initial Value      0           0        0          0         0          0         0         0
        • Bits 7..1 – TWAM: TWI Address Mask
        The TWAMR can be loaded with a 7-bit slave address mask. Each of the bits in TWAMR can mask (disable) the
        corresponding address bits in the TWI address register (TWAR). If the mask bit is set to one then the address match logic
        ignores the compare between the incoming address bit and the corresponding bit in TWAR. Figure 5-98 shown the address
        match logic in detail.
        Figure 5-98. TWI Address Match Logic, Block Diagram
                                 TWAR0
                                                                                                           Address
                                                                                                            Match
                                 Address
                                   Bit 0
                                TWAMR0
                                                          Address Bit Comparator 0
                                                 Address Bit Comparator 6 to 1
        • Bit 0 – Res: Reserved Bit
        This bit is an unused bit in the ATmega328P, and will always read as zero.
222     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.22   Analog Comparator
5.22.1 Overview
       The analog comparator compares the input values on the positive pin AIN0 and negative pin AIN1. When the voltage on the
       positive pin AIN0 is higher than the voltage on the negative pin AIN1, the analog comparator output, ACO, is set. The
       comparator’s output can be set to trigger the Timer/Counter1 input capture function. In addition, the comparator can trigger a
       separate interrupt, exclusive to the analog comparator. The user can select Interrupt triggering on comparator output rise,
       fall or toggle. A block diagram of the comparator and its surrounding logic is shown in Figure 5-99.
       The power reduction ADC bit, PRADC, in Section 5.9.10 “Minimizing Power Consumption” on page 60 must be disabled by
       writing a logical zero to be able to use the ADC input MUX.
       Figure 5-99. Analog Comparator Block Diagram(2)
                        Bandgap                            VCC
                        Reference
                                      ACBG
                                                   ACD
                                                                                              ACIE
                               AIN0
                                                                                                                  Analog
                                                          +
                                                                              Interrupt                           Comparator
                                                                               Select                             IRQ
                                                          -
                               AIN1                                                                               ACI
                                                                           ACIS1    ACIS0     ACIC
                    ACME
                    ADEN
                                                                                                                  To T/C1 Capture
                                                                                              ACO                 Trigger MUX
                  ADC Multiplexer
                     Output(1)
       Notes:     1.   See Table 5-93 on page 223.
                  2.   Refer to Table 5-37 on page 94 for Analog Comparator pin placement.
5.22.2 Analog Comparator Multiplexed Input
       It is possible to select any of the ADC7..0 pins to replace the negative input to the analog comparator. The ADC multiplexer
       is used to select this input, and consequently, the ADC must be switched off to utilize this feature. If the analog comparator
       multiplexer enable bit (ACME in ADCSRB) is set and the ADC is switched off (ADEN in ADCSRA is zero), MUX2..0 in
       ADMUX select the input pin to replace the negative input to the analog comparator, as shown in Table 5-93. If ACME is
       cleared or ADEN is set, AIN1 is applied to the negative input to the analog comparator.
       Table 5-93. Analog Comparator Multiplexed Input
              ACME                ADEN           MUX2..0                        Analog Comparator Negative Input
                 0                  x               xxx                                          AIN1
                 1                  1               xxx                                          AIN1
                 1                  0              000                                          ADC0
                 1                  0              001                                          ADC1
                 1                  0              010                                          ADC2
                 1                  0               011                                         ADC3
                 1                  0              100                                          ADC4
                 1                  0              101                                          ADC5
                 1                  0               110                                         ADC6
                 1                  0               111                                         ADC7
                                                                                               ATA6614Q [DATASHEET]               223
                                                                                                              9240I–AUTO–03/16


5.22.3 Register Description
5.22.3.1 ADCSRB – ADC Control and Status Register B
                 Bit         7          6         5          4         3          2           1           0
              (0x7B)         –        ACME        –          –         –       ADTS2       ADTS1      ADTS0       ADCSRB
           Read/Write        R         R/W        R          R         R         R/W         R/W        R/W
           Initial Value     0          0         0          0         0          0           0           0
        • Bit 6 – ACME: Analog Comparator Multiplexer Enable
        When this bit is written logic one and the ADC is switched off (ADEN in ADCSRA is zero), the ADC multiplexer selects the
        negative input to the analog comparator. When this bit is written logic zero, AIN1 is applied to the negative input of the
        analog comparator. For a detailed description of this bit, see Section 5.22.2 “Analog Comparator Multiplexed Input” on page
        223.
5.22.3.2 ACSR – Analog Comparator Control and Status Register
                 Bit         7          6         5          4         3          2            1          0
           0x30 (0x50)      ACD       ACBG      ACO         ACI      ACIE        ACIC       ACIS1      ACIS0        ACSR
            Read/Write      R/W        R/W        R        R/W       R/W         R/W         R/W         R/W
           Initial Value     0          0        N/A         0         0          0            0          0
        • Bit 7 – ACD: Analog Comparator Disable
        When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn
        off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the
        analog comparator interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the
        bit is changed.
        • Bit 6 – ACBG: Analog Comparator Bandgap Select
        When this bit is set, a fixed bandgap reference voltage replaces the positive input to the analog comparator. When this bit is
        cleared, AIN0 is applied to the positive input of the analog comparator. When the bandgap reference is used as input to the
        analog comparator, it will take a certain time for the voltage to stabilize. If not stabilized, the first conversion may give a
        wrong value. See Section 5.10.7 “Internal Voltage Reference” on page 67.
        • Bit 5 – ACO: Analog Comparator Output
        The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a
        delay of 1 - 2 clock cycles.
        • Bit 4 – ACI: Analog Comparator Interrupt Flag
        This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The
        analog comparator interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hardware
        when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.
        • Bit 3 – ACIE: Analog Comparator Interrupt Enable
        When the ACIE bit is written logic one and the I-bit in the status register is set, the analog comparator interrupt is activated.
        When written logic zero, the interrupt is disabled.
        • Bit 2 – ACIC: Analog Comparator Input Capture Enable
        When written logic one, this bit enables the input capture function in Timer/Counter1 to be triggered by the analog
        comparator. The comparator output is in this case directly connected to the input capture front-end logic, making the
        comparator utilize the noise canceler and edge select features of the Timer/Counter1 input capture interrupt. When written
        logic zero, no connection between the analog comparator and the input capture function exists. To make the comparator
        trigger the Timer/Counter1 input capture interrupt, the ICIE1 bit in the timer interrupt mask register (TIMSK1) must be set.
224     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        • Bits 1, 0 – ACIS1, ACIS0: Analog Comparator Interrupt Mode Select
        These bits determine which comparator events that trigger the analog comparator interrupt. The different settings are shown
        in Table 5-94.
        Table 5-94. ACIS1/ACIS0 Settings
                ACIS1             ACIS0         Interrupt Mode
                    0                0          Comparator interrupt on output toggle.
                    0                1          Reserved
                    1                0          Comparator interrupt on falling output edge.
                    1                1          Comparator interrupt on rising output edge.
        When changing the ACIS1/ACIS0 bits, the analog comparator interrupt must be disabled by clearing its interrupt enable bit in
        the ACSR register. Otherwise an interrupt can occur when the bits are changed.
5.22.3.3 DIDR1 – Digital Input Disable Register 1
                 Bit         7          6          5          4          3         2          1         0
              (0x7F)         –          –          –          –          –         –        AIN1D     AIN0D     DIDR1
           Read/Write        R          R          R          R          R         R         R/W       R/W
           Initial Value     0          0          0          0          0         0          0         0
        • Bit 7..2 – Res: Reserved Bits
        These bits are unused bits in the ATmega328P, and will always read as zero.
        • Bit 1, 0 – AIN1D, AIN0D: AIN1, AIN0 Digital Input Disable
        When this bit is written logic one, the digital input buffer on the AIN1/0 pin is disabled. The corresponding PIN register bit will
        always read as zero when this bit is set. When an analog signal is applied to the AIN1/0 pin and the digital input from this pin
        is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.
                                                                                                   ATA6614Q [DATASHEET]               225
                                                                                                                9240I–AUTO–03/16


5.23   Analog-to-Digital Converter
5.23.1 Features
         ●    10-bit resolution
         ●    0.5 LSB integral non-linearity
         ●    ±2 LSB absolute accuracy
         ●    65µs to 260µs conversion time
         ●    Up to 15kSPS
         ●    6 multiplexed single ended input channels
         ●    2 additional multiplexed single ended input channels
         ●    Temperature sensor input channel
         ●    Optional left adjustment for ADC result readout
         ●    0 to VCC ADC input voltage range
         ●    Selectable 1.1V ADC reference voltage
         ●    Free running or single conversion mode
         ●    Interrupt on ADC conversion complete
         ●    Sleep mode noise canceler
5.23.2 Overview
       The ATmega328P features a 10-bit successive approximation ADC. The ADC is connected to an 8-channel analog
       multiplexer which allows eight single-ended voltage inputs constructed from the pins of Port A. The single-ended voltage
       inputs refer to 0V (GND).
       The ADC contains a sample and hold circuit which ensures that the input voltage to the ADC is held at a constant level
       during conversion. A block diagram of the ADC is shown in Figure 5-100 on page 227.
       The ADC has a separate analog supply voltage pin, AVCC. AVCC must not differ more than ±0.3V from VCC. See the
       paragraph Section 5.23.6 “ADC Noise Canceler” on page 232 on how to connect this pin.
       Internal reference voltages of nominally 1.1V or AVCC are provided on-chip. The voltage reference may be externally
       decoupled at the AREF pin by a capacitor for better noise performance.
       The power reduction ADC bit, PRADC, in Section 5.9.10 “Minimizing Power Consumption” on page 60 must be disabled by
       writing a logical zero to enable the ADC.
       The ADC converts an analog input voltage to a 10-bit digital value through successive approximation. The minimum value
       represents GND and the maximum value represents the voltage on the AREF pin minus 1 LSB. Optionally, AVCC or an
       internal 1.1V reference voltage may be connected to the AREF pin by writing to the REFSn bits in the ADMUX register. The
       internal voltage reference may thus be decoupled by an external capacitor at the AREF pin to improve noise immunity.
226    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


Figure 5-100. Analog to Digital Converter Block Schematic Operation
                                                                                                                     ADC Conversion
                                                                                                                      Complete IRQ
               8-Bit Data Bus
                                                                                                                            ADIF    ADIE                        15                              0
                                               ADC Multiplexer                                                ADC CTRL and Status                                    ADC Data Register
                                               Select (ADMUX)                                                  Register (ADCSRA)                                       (ADCH/ADCL)
                                   REFS1   REFS0   ADLAR     MUX3               MUX2   MUX1   MUX0     ADEN   ADSC   ADFR   ADIF
                                                                                                                                    ADPS2   ADPS1   ADPS0
                                                                                                                                                                           ADC[9:0]
                                                           MUX Decoder                                                                Prescaler
                                                                Channel Selection
        AVCC                                                                                                                       Conversion Logic
                 Internal 1.1V
                  Reference                                                                                                                         Sample and Hold
                                                                                                                                                      Comparator
        AREF                                                                                         10-Bit DAC                                             -
                                                                                                                                                            +
                 Temperature
                   Sensor
         GND
                  Bandgap
                  Reference
        ADC7
        ADC6                     Input                                                                                                                                                ADC
                                 MUX                                                                                                                                                  Multiplexer
        ADC5                                                                                                                                                                          Output
        ADC4
        ADC3
        ADC2
        ADC1
        ADC0
The analog input channel is selected by writing to the MUX bits in ADMUX. Any of the ADC input pins, as well as GND and a
fixed bandgap voltage reference, can be selected as single ended inputs to the ADC. The ADC is enabled by setting the
ADC Enable bit, ADEN in ADCSRA. Voltage reference and input channel selections will not go into effect until ADEN is set.
The ADC does not consume power when ADEN is cleared, so it is recommended to switch off the ADC before entering
power saving sleep modes.
The ADC generates a 10-bit result which is presented in the ADC data registers, ADCH and ADCL. By default, the result is
presented right adjusted, but can optionally be presented left adjusted by setting the ADLAR bit in ADMUX.
If the result is left adjusted and no more than 8-bit precision is required, it is sufficient to read ADCH. Otherwise, ADCL must
be read first, then ADCH, to ensure that the content of the data registers belongs to the same conversion. Once ADCL is
read, ADC access to data registers is blocked.
                                                                                                                                                    ATA6614Q [DATASHEET]                            227
                                                                                                                                                                         9240I–AUTO–03/16


       This means that if ADCL has been read, and a conversion completes before ADCH is read, neither register is updated and
       the result from the conversion is lost. When ADCH is read, ADC access to the ADCH and ADCL registers is re-enabled.
       The ADC has its own interrupt which can be triggered when a conversion completes. When ADC access to the data registers
       is prohibited between reading of ADCH and ADCL, the interrupt will trigger even if the result is lost.
5.23.3 Starting a Conversion
       A single conversion is started by disabling the power reduction ADC bit, PRADC, in Section 5.9.10 “Minimizing Power
       Consumption” on page 60 by writing a logical zero to it and writing a logical one to the ADC start conversion bit, ADSC. This
       bit stays high as long as the conversion is in progress and will be cleared by hardware when the conversion is completed. If
       a different data channel is selected while a conversion is in progress, the ADC will finish the current conversion before
       performing the channel change.
       Alternatively, a conversion can be triggered automatically by various sources. Auto triggering is enabled by setting the ADC
       auto trigger enable bit, ADATE in ADCSRA. The trigger source is selected by setting the ADC trigger select bits, ADTS in
       ADCSRB (See description of the ADTS bits for a list of the trigger sources). When a positive edge occurs on the selected
       trigger signal, the ADC prescaler is reset and a conversion is started. This provides a method of starting conversions at fixed
       intervals. If the trigger signal still is set when the conversion completes, a new conversion will not be started. If another
       positive edge occurs on the trigger signal during conversion, the edge will be ignored. Note that an Interrupt flag will be set
       even if the specific interrupt is disabled or the global interrupt enable bit in SREG is cleared. A conversion can thus be
       triggered without causing an interrupt. However, the interrupt flag must be cleared in order to trigger a new conversion at the
       next interrupt event.
       Figure 5-101. ADC Auto Trigger Logic
                                                   ADTS[2:0]
                                                                                                       Prescaler
                                                                                         START               CLKADC
                                     ADIF                                ADATE
                              SOURCE 1
                                         .
                                                                                                      Conversion
                                         .                                                               Logic
                                         .
                                         .                       Edge
                                                                Detector
                              SOURCE n
                                    ADSC
       Using the ADC interrupt flag as a trigger source makes the ADC start a new conversion as soon as the ongoing conversion
       has finished. The ADC then operates in free running mode, constantly sampling and updating the ADC data register. The
       first conversion must be started by writing a logical one to the ADSC bit in ADCSRA. In this mode the ADC will perform
       successive conversions independently of whether the ADC Interrupt Flag, ADIF is cleared or not.
       If auto triggering is enabled, single conversions can be started by writing ADSC in ADCSRA to one. ADSC can also be used
       to determine if a conversion is in progress. The ADSC bit will be read as one during a conversion, independently of how the
       conversion was started.
228    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.23.4 Prescaling and Conversion Timing
       Figure 5-102. ADC Prescaler
                                            ADEN
                                                                  Reset
                                           START                            7-Bit ADC Prescaler
                                                    CK
                                                                     CK/2   CK/4   CK/8   CK/16   CK/32   CK/64   CK/128
                                                ADPS0
                                                ADPS1
                                                ADPS2
                                                                             ADC Clock Source
       By default, the successive approximation circuitry requires an input clock frequency between 50kHz and 200kHz to get
       maximum resolution. If a lower resolution than 10 bits is needed, the input clock frequency to the ADC can be higher than
       200kHz to get a higher sample rate.
       The ADC module contains a prescaler, which generates an acceptable ADC clock frequency from any CPU frequency above
       100kHz. The prescaling is set by the ADPS bits in ADCSRA. The prescaler starts counting from the moment the ADC is
       switched on by setting the ADEN bit in ADCSRA. The prescaler keeps running for as long as the ADEN bit is set, and is
       continuously reset when ADEN is low.
       When initiating a single ended conversion by setting the ADSC bit in ADCSRA, the conversion starts at the following rising
       edge of the ADC clock cycle.
       A normal conversion takes 13 ADC clock cycles. The first conversion after the ADC is switched on (ADEN in ADCSRA is set)
       takes 25 ADC clock cycles in order to initialize the analog circuitry.
       When the bandgap reference voltage is used as input to the ADC, it will take a certain time for the voltage to stabilize. If not
       stabilized, the first value read after the first conversion may be wrong.
       The actual sample-and-hold takes place 1.5 ADC clock cycles after the start of a normal conversion and 13.5 ADC clock
       cycles after the start of an first conversion. When a conversion is complete, the result is written to the ADC data registers,
       and ADIF is set. In single conversion mode, ADSC is cleared simultaneously. The software may then set ADSC again, and a
       new conversion will be initiated on the first rising ADC clock edge.
       When auto triggering is used, the prescaler is reset when the trigger event occurs. This assures a fixed delay from the trigger
       event to the start of conversion. In this mode, the sample-and-hold takes place two ADC clock cycles after the rising edge on
       the trigger source signal. Three additional CPU clock cycles are used for synchronization logic.
       In free running mode, a new conversion will be started immediately after the conversion completes, while ADSC remains
       high. For a summary of conversion times, see Table 5-95 on page 231.
                                                                                                                           ATA6614Q [DATASHEET]        229
                                                                                                                                    9240I–AUTO–03/16


Figure 5-103. ADC Timing Diagram, First Conversion (Single Conversion Mode)
                                                                                                                     Next
                                                               First Conversion                                      Conversion
   Cycle Number            1 2        12   13   14   15  16    17     18    19  20 21    22   23   24  25          1      2     3
      ADC Clock
          ADEN
          ADSC
            ADIF
          ADCH                                                                                              Sign and MSB of Result
           ADCL                                                                                                   LSB of Result
                               MUX and REFS                                             Conversion
                               Update                     Sample and Hold                 Complete               MUX and REFS
                                                                                                                 Update
         Figure 5-104. ADC Timing Diagram, Single Conversion
                                                                    One Conversion                             Next Conversion
               Cycle Number         1    2    3    4    5     6       7    8    9   10   11    12   13         1      2     3
                  ADC Clock
                      ADSC
                       ADIF
                      ADCH                                                                              Sign and MSB of Result
                      ADCL                                                                                    LSB of Result
                                                    Sample and Hold                Conversion
                                            MUX and REFS                             Complete                MUX and REFS
                                            Update                                                           Update
230      ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


Figure 5-105. ADC Timing Diagram, Auto Triggered Conversion
                                                               One Conversion                                  Next Conversion
  Cycle Number                1     2      3    4     5    6    7      8    9      10   11    12   13                1      2
     ADC Clock
         Trigger
         Source
         ADATE
           ADIF
          ADCH                                                                                          Sign and MSB of Result
          ADCL                                                                                                LSB of Result
                                                Sample and Hold                   Conversion                            Prescaler
                 Prescaler                                                                                              Reset
                 Reset                  MUX and REFS                                Complete
                                        Update
Figure 5-106. ADC Timing Diagram, Free Running Conversion
                                             One Conversion       Next Conversion
                              Cycle Number     11    12   13    1      2    3       4
                                ADC Clock
                                     ADSC
                                       ADIF
                                     ADCH                      Sign and MSB of Result
                                      ADCL                          LSB of Result
                                          Conversion                               Sample and Hold
                                            Complete                     MUX and REFS
                                                                         Update
Table 5-95. ADC Conversion Time
                                                          Sample and Hold                             Conversion Time
 Condition                                        (Cycles from Start of Conversion)                        (Cycles)
 First conversion                                                 13.5                                         25
 Normal conversions, single ended                                  1.5                                         13
 Auto Triggered conversions                                         2                                         13.5
                                                                                         ATA6614Q [DATASHEET]                  231
                                                                                                       9240I–AUTO–03/16


5.23.5 Changing Channel or Reference Selection
        The MUXn and REFS1:0 bits in the ADMUX register are single buffered through a temporary register to which the CPU has
        random access. This ensures that the channels and reference selection only takes place at a safe point during the
        conversion. The channel and reference selection is continuously updated until a conversion is started. Once the conversion
        starts, the channel and reference selection is locked to ensure a sufficient sampling time for the ADC. Continuous updating
        resumes in the last ADC clock cycle before the conversion completes (ADIF in ADCSRA is set). Note that the conversion
        starts on the following rising ADC clock edge after ADSC is written. The user is thus advised not to write new channel or
        reference selection values to ADMUX until one ADC clock cycle after ADSC is written.
        If auto triggering is used, the exact time of the triggering event can be indeterministic. Special care must be taken when
        updating the ADMUX register, in order to control which conversion will be affected by the new settings.
        If both ADATE and ADEN is written to one, an interrupt event can occur at any time. If the ADMUX register is changed in this
        period, the user cannot tell if the next conversion is based on the old or the new settings. ADMUX can be safely updated in
        the following ways:
           a. When ADATE or ADEN is cleared.
           b.   During conversion, minimum one ADC clock cycle after the trigger event.
           c.   After a conversion, before the Interrupt Flag used as trigger source is cleared.
        When updating ADMUX in one of these conditions, the new settings will affect the next ADC conversion.
5.23.5.1 ADC Input Channels
        When changing channel selections, the user should observe the following guidelines to ensure that the correct channel is
        selected:
        In single conversion mode, always select the channel before starting the conversion. The channel selection may be changed
        one ADC clock cycle after writing one to ADSC. However, the simplest method is to wait for the conversion to complete
        before changing the channel selection.
        In free running mode, always select the channel before starting the first conversion. The channel selection may be changed
        one ADC clock cycle after writing one to ADSC. However, the simplest method is to wait for the first conversion to complete,
        and then change the channel selection. Since the next conversion has already started automatically, the next result will
        reflect the previous channel selection. Subsequent conversions will reflect the new channel selection.
5.23.5.2 ADC Voltage Reference
        The reference voltage for the ADC (VREF) indicates the conversion range for the ADC. Single ended channels that exceed
        VREF will result in codes close to 0x3FF. VREF can be selected as either AVCC, internal 1.1V reference, or external AREF pin.
        AVCC is connected to the ADC through a passive switch. The internal 1.1V reference is generated from the internal bandgap
        reference (VBG) through an internal amplifier. In either case, the external AREF pin is directly connected to the ADC, and the
        reference voltage can be made more immune to noise by connecting a capacitor between the AREF pin and ground. VREF
        can also be measured at the AREF pin with a high impedance voltmeter. Note that VREF is a high impedance source, and
        only a capacitive load should be connected in a system.
        If the user has a fixed voltage source connected to the AREF pin, the user may not use the other reference voltage options
        in the application, as they will be shorted to the external voltage. If no external voltage is applied to the AREF pin, the user
        may switch between AVCC and 1.1V as reference selection. The first ADC conversion result after switching reference voltage
        source may be inaccurate, and the user is advised to discard this result.
5.23.6 ADC Noise Canceler
        The ADC features a noise canceler that enables conversion during sleep mode to reduce noise induced from the CPU core
        and other I/O peripherals. The noise canceler can be used with ADC Noise Reduction and Idle mode. To make use of this
        feature, the following procedure should be used:
           a. Make sure that the ADC is enabled and is not busy converting. Single conversion mode must be selected and the
                ADC conversion complete interrupt must be enabled.
           b.   Enter ADC noise reduction mode (or Idle mode). The ADC will start a conversion once the CPU has been halted.
232     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


           c.    If no other interrupts occur before the ADC conversion completes, the ADC interrupt will wake up the CPU and
                 execute the ADC conversion complete interrupt routine. If another interrupt wakes up the CPU before the ADC
                 conversion is complete, that interrupt will be executed, and an ADC conversion complete interrupt request will be
                 generated when the ADC conversion completes. The CPU will remain in active mode until a new sleep command
                 is executed.
        Note that the ADC will not be automatically turned off when entering other sleep modes than Idle mode and ADC noise
        reduction mode. The user is advised to write zero to ADEN before entering such sleep modes to avoid excessive power
        consumption.
5.23.6.1 Analog Input Circuitry
        The analog input circuitry for single ended channels is illustrated in Figure 5-107 on page 233 An analog source applied to
        ADCn is subjected to the pin capacitance and input leakage of that pin, regardless of whether that channel is selected as
        input for the ADC. When the channel is selected, the source must drive the S/H capacitor through the series resistance
        (combined resistance in the input path).
        The ADC is optimized for analog signals with an output impedance of approximately 10k or less. If such a source is used,
        the sampling time will be negligible. If a source with higher impedance is used, the sampling time will depend on how long
        time the source needs to charge the S/H capacitor, with can vary widely. The user is recommended to only use low
        impedance sources with slowly varying signals, since this minimizes the required charge transfer to the S/H capacitor.
        Signal components higher than the Nyquist frequency (fADC/2) should not be present for either kind of channels, to avoid
        distortion from unpredictable signal convolution. The user is advised to remove high frequency components with a low-pass
        filter before applying the signals as inputs to the ADC.
        Figure 5-107. Analog Input Circuitry
                                                                  IIH
                                              ADCn
                                                                                   1 to 100kΩ
                                                                       IIL                CS/H = 14pF
                                                                                                     VCC/2
5.23.6.2 Analog Noise Canceling Techniques
        Digital circuitry inside and outside the device generates EMI which might affect the accuracy of analog measurements. If
        conversion accuracy is critical, the noise level can be reduced by applying the following techniques:
           a. Keep analog signal paths as short as possible. Make sure analog tracks run over the analog ground plane, and
                 keep them well away from high-speed switching digital tracks.
           b.    The AVCC pin on the device should be connected to the digital VCC supply voltage via an LC network as shown in
                 Figure 5-108.
           c.    Use the ADC noise canceler function to reduce induced noise from the CPU.
           d.    If any ADC [3..0] port pins are used as digital outputs, it is essential that these do not switch while a conversion is
                 in progress. However, using the 2-wire Interface (ADC4 and ADC5) will only affect the conversion on ADC4 and
                 ADC5 and not the other ADC channels.
                                                                                                     ATA6614Q [DATASHEET]               233
                                                                                                                   9240I–AUTO–03/16


       Figure 5-108. ADC Power Connections
                                                           PC5 (ADC5/SCL)   PC4 (ADC4/SDA)
                                                                                             PC3 (ADC3)   PC2 (ADC2)
                                                                                                                                     Analog Ground Plane
                                            GND   VCC
                                                                                                                       PC1 (ADC1)
                                                                                                                       PC0 (ADC0)
                                                                                                                       ADC7
                                                                                                                       GND
                                                                                                                       AREF          10μH
                                                                                                                       ADC8
                                                                                                                       AVCC          100nF
                                                                                                                       PB5
5.23.6.3 ADC Accuracy Definitions
       An n-bit single-ended ADC converts a voltage linearly between GND and VREF in 2n steps (LSBs). The lowest code is read
       as 0, and the highest code is read as 2n-1.
       Several parameters describe the deviation from the ideal behavior:
        ● Offset: The deviation of the first transition (0x000 to 0x001) compared to the ideal transition (at 0.5 LSB). Ideal value:
             0 LSB.
       Figure 5-109. Offset Error
                                   Output Code
                                                                                                                                     Ideal ADC
                                                                                                                                     Actual ADC
                                                  Offset
                                                  Error
                                                                                                                        VREF Input Voltage
234    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


 ●    Gain error: After adjusting for offset, the gain error is found as the deviation of the last transition (0x3FE to 0x3FF)
      compared to the ideal transition (at 1.5 LSB below maximum). Ideal value: 0 LSB
Figure 5-110. Gain Error
                            Output Code                                  Gain
                                                                         Error
                                                                                              Ideal ADC
                                                                                              Actual ADC
                                                                                 VREF Input Voltage
 ●    Integral non-linearity (INL): After adjusting for offset and gain error, the INL is the maximum deviation of an actual
      transition compared to an ideal transition for any code. Ideal value: 0 LSB.
Figure 5-111. Integral Non-linearity (INL)
                            Output Code
                                                                 INL
                                                                                              Ideal ADC
                                                                                              Actual ADC
                                                                                 VREF Input Voltage
                                                                                           ATA6614Q [DATASHEET]               235
                                                                                                           9240I–AUTO–03/16


         ●     Differential non-linearity (DNL): The maximum deviation of the actual code width (the interval between two adjacent
               transitions) from the ideal code width (1 LSB). Ideal value: 0 LSB.
       Figure 5-112. Differential Non-linearity (DNL)
                                         Output Code
                                              0x3FF
                                                           1 LSB
                                                                 DNL
                                               0x000
                                                     0                                    VREF Input Voltage
         ●     Quantization error: Due to the quantization of the input voltage into a finite number of codes, a range of input voltages
               (1 LSB wide) will code to the same value. Always ±0.5 LSB.
         ●     Absolute accuracy: The maximum deviation of an actual (unadjusted) transition compared to an ideal transition for
               any code. This is the compound effect of offset, gain error, differential error, non-linearity, and quantization error. Ideal
               value: ±0.5 LSB.
5.23.7 ADC Conversion Result
       After the conversion is complete (ADIF is high), the conversion result can be found in the ADC result registers (ADCL,
       ADCH).
       For single ended conversion, the result is
                  V IN  1024
       ADC = -------------------------
                     V REF
       where VIN is the voltage on the selected input pin and VREF the selected voltage reference (see Table 5-97 on page 238 and
       Table 5-98 on page 238). 0x000 represents analog ground, and 0x3FF represents the selected reference voltage minus one
       LSB.
5.23.8 Temperature Measurement
       The temperature measurement is based on an on-chip temperature sensor that is coupled to a single ended ADC input.
       MUX[4..0] bits in ADMUX register enables the temperature sensor. The internal 1.1V voltage reference must also be
       selected for the ADC voltage reference source in the temperature sensor measurement. When the temperature sensor is
       enabled, the ADC converter can be used in single conversion mode to measure the voltage over the temperature sensor.
       The measured voltage has a linear relationship to the temperature as described in Table 5-96 on page 236.
       The voltage sensitivity is approximately 1LSB/°C and the accuracy of the temperature measurement is ±10°C using
       manufacturing calibration values (TS_GAIN, TS_OFFSET).
       The values described in Table 5-96 on page 236 are typical values. However, due to the process variation the temperature
       sensor output varies from one chip to another.
       Table 5-96. Sensor output code vs Temperature (typical values)
              Temperature / °C                         -40°C                          +25 °C                           +125 °C
                                                      0x010D                          0x0160                           0x01E0
236    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.23.8.1 Manufacturing Calibration
        Calibration values determined during test are available in the signature row.
        The temperature in degrees Celsius can be calculated using the formula:
           ADCH « 8  + ADCL    273 + 100 – TS_OFFSET    128
        ------------------------------------------------------------------------------------------------------------------------------------------------------- + 25
                                                                       TS_GAIN
        Where:.
                         a.                        ADCH & ADCL are the ADC data registers,
                         b.                        is the temperature sensor gain
                         c.                      TS_OFFSET is the temperature sensor offset correction term
                                                 TS_GAIN is the unsigned fixed point 8-bit temperature sensor gain factor in
                                                 1/128th units stored in the signature row.
                                                 TS_OFFSET is the signed twos complement temperature sensor offset reading
                                                 stored in the signature row. See Table 5-106 on page 257 for signature row
                                                 parameter address
        The following code example allows to read Signature Row data
                               .equ TS_GAIN = 0x0003
                               .equ TS_OFFSET = 0x0002
                               LDI R30,LOW(TS_GAIN)
                               LDI R31,HIGH (TS_GAIN)
                               RCALL Read_signature_row
                               MOV R17,R16 ; Save R16 result
                               LDI R30,LOW(TS_OFFSET)
                               LDI R31,HIGH (TS_OFFSET)
                               RCALL Read_signature_row
                               ; R16 holds TS_OFFSET and R17 holds TS_GAIN
                               Read_signature_row:
                               IN R16,SPMCSR ; Wait for SPMEN ready
                               SBRC R16,SPMEN ; Exit loop here when SPMCSR is free
                               RJMP Read_signature_row
                               LDI R16,((1<<SIGRD)|(1<<SPMEN)) ; We need to set SIGRD and SPMEN together
                               OUT SPMCSR,R16 ; and execute the LPM within 3 cycles
                               LPM R16,Z
                               RET
5.23.9 Register Description
5.23.9.1 ADMUX – ADC Multiplexer Selection Register
                        Bit                                7                         6                          5                          4                     3    2    1      0
                   (0x7C)                           REFS1                     REFS0                     ADLAR                              –                   MUX3  MUX2 MUX1   MUX0   ADMUX
              Read/Write                               R/W                        R/W                       R/W                           R                     R/W  R/W  R/W    R/W
             Initial Value                                 0                         0                          0                          0                     0    0    0      0
        • Bit 7:6 – REFS1:0: Reference Selection Bits
        These bits select the voltage reference for the ADC, as shown in Table 5-97. If these bits are changed during a conversion,
        the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set). The internal voltage reference
        options may not be used if an external reference voltage is being applied to the AREF pin.
                                                                                                                                                                               ATA6614Q [DATASHEET]       237
                                                                                                                                                                                         9240I–AUTO–03/16


    Table 5-97. Voltage Reference Selections for ADC
       REFS1           REFS0       Voltage Reference Selection
           0              0        AREF, Internal Vref turned off
           0              1        AVCC with external capacitor at AREF pin
           1              0        Reserved
           1              1        Internal 1.1V voltage reference with external capacitor at AREF pin
    • Bit 5 – ADLAR: ADC Left Adjust Result
    The ADLAR bit affects the presentation of the ADC conversion result in the ADC data register. Write one to ADLAR to left
    adjust the result. Otherwise, the result is right adjusted. Changing the ADLAR bit will affect the ADC data register
    immediately, regardless of any ongoing conversions. For a complete description of this bit, see Section 5.23.9.3 “ADCL and
    ADCH – The ADC Data Register” on page 240.
    • Bit 4 – Res: Reserved Bit
    This bit is an unused bit in the ATmega328P, and will always read as zero.
    • Bits 3:0 – MUX3:0: Analog Channel Selection Bits
    The value of these bits selects which analog inputs are connected to the ADC. See Table 5-98 for details. If these bits are
    changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set).
    Table 5-98. Input Channel Selections
     MUX3..0                                      Single Ended Input
     0000                                         ADC0
     0001                                         ADC1
     0010                                         ADC2
     0011                                         ADC3
     0100                                         ADC4
     0101                                         ADC5
     0110                                         ADC6
     0111                                         ADC7
     1000                                         ADC8(1)
     1001                                         (reserved)
     1010                                         (reserved)
     1011                                         (reserved)
     1100                                         (reserved)
     1101                                         (reserved)
     1110                                         1.1V (VBG)
     1111                                         0V (GND)
     Note:      1.  For temperature sensor.
238 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.23.9.2 ADCSRA – ADC Control and Status Register A
                 Bit           7         6        5           4         3        2          1          0
              (0x7A)        ADEN      ADSC     ADATE        ADIF     ADIE     ADPS2      ADPS1      ADPS0    ADCSRA
            Read/Write       R/W       R/W       R/W        R/W       R/W       R/W        R/W       R/W
           Initial Value       0         0        0           0         0        0          0          0
        • Bit 7 – ADEN: ADC Enable
        Writing this bit to one enables the ADC. By writing it to zero, the ADC is turned off. Turning the ADC off while a conversion is
        in progress, will terminate this conversion.
        • Bit 6 – ADSC: ADC Start Conversion
        In single conversion mode, write this bit to one to start each conversion. In free running mode, write this bit to one to start the
        first conversion. The first conversion after ADSC has been written after the ADC has been enabled, or if ADSC is written at
        the same time as the ADC is enabled, will take 25 ADC clock cycles instead of the normal 13. This first conversion performs
        initialization of the ADC.
        ADSC will read as one as long as a conversion is in progress. When the conversion is complete, it returns to zero. Writing
        zero to this bit has no effect.
        • Bit 5 – ADATE: ADC Auto Trigger Enable
        When this bit is written to one, auto triggering of the ADC is enabled. The ADC will start a conversion on a positive edge of
        the selected trigger signal. The trigger source is selected by setting the ADC trigger Select bits, ADTS in ADCSRB.
        • Bit 4 – ADIF: ADC Interrupt Flag
        This bit is set when an ADC conversion completes and the data registers are updated. The ADC conversion complete
        interrupt is executed if the ADIE bit and the I-bit in SREG are set. ADIF is cleared by hardware when executing the
        corresponding interrupt handling vector. Alternatively, ADIF is cleared by writing a logical one to the flag. Beware that if
        doing a read-modify-write on ADCSRA, a pending interrupt can be disabled. This also applies if the SBI and CBI instructions
        are used.
        • Bit 3 – ADIE: ADC Interrupt Enable
        When this bit is written to one and the I-bit in SREG is set, the ADC conversion complete interrupt is activated.
        • Bits 2:0 – ADPS2:0: ADC Prescaler Select Bits
        These bits determine the division factor between the system clock frequency and the input clock to the ADC.
        Table 5-99. ADC Prescaler Selections
                ADPS2               ADPS1               ADPS0                                   Division Factor
                     0                  0                  0                                            2
                     0                  0                  1                                            2
                     0                  1                  0                                            4
                     0                  1                  1                                            8
                     1                  0                  0                                           16
                     1                  0                  1                                           32
                     1                  1                  0                                           64
                     1                  1                  1                                          128
                                                                                                 ATA6614Q [DATASHEET]                  239
                                                                                                              9240I–AUTO–03/16


5.23.9.3 ADCL and ADCH – The ADC Data Register
5.23.9.4 ADLAR = 0
                Bit           15         14       13         12         11          10        9     8
             (0x79)           –          –         –          –          –           –      ADC9  ADC8     ADCH
             (0x78)         ADC7       ADC6     ADC5      ADC4         ADC3      ADC2       ADC1  ADC0     ADCL
                               7          6        5          4          3           2        1     0
          Read/Write          R          R        R          R           R          R         R    R
                              R          R        R          R           R          R         R    R
          Initial Value       0          0         0          0          0           0        0     0
                               0          0        0          0          0           0        0     0
5.23.9.5 ADLAR = 1
                Bit           15         14       13         12         11          10        9     8
             (0x79)         ADC9       ADC8     ADC7      ADC6         ADC5      ADC4       ADC3  ADC2     ADCH
             (0x78)         ADC1       ADC0        –          –          –          –         –     –      ADCL
                               7          6        5          4          3           2        1     0
          Read/Write          R          R        R          R           R          R         R    R
                              R          R        R          R           R          R         R    R
          Initial Value       0          0         0          0          0           0        0     0
                               0          0        0          0          0           0        0     0
        When an ADC conversion is complete, the result is found in these two registers.
        When ADCL is read, the ADC data register is not updated until ADCH is read. Consequently, if the result is left adjusted and
        no more than 8-bit precision is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH.
        The ADLAR bit in ADMUX, and the MUXn bits in ADMUX affect the way the result is read from the registers. If ADLAR is set,
        the result is left adjusted. If ADLAR is cleared (default), the result is right adjusted.
        • ADC9:0: ADC Conversion Result
        These bits represent the result from the conversion, as detailed in Section 5.23.7 “ADC Conversion Result” on page 236.
240     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.23.9.6 ADCSRB – ADC Control and Status Register B
                 Bit           7        6          5          4          3         2        1          0
              (0x7B)           –      ACME         –          –          –      ADTS2    ADTS1       ADTS0      ADCSRB
           Read/Write         R        R/W         R          R          R       R/W      R/W         R/W
           Initial Value       0        0          0          0          0         0        0          0
        • Bit 7, 5:3 – Res: Reserved Bits
        These bits are reserved for future use. To ensure compatibility with future devices, these bits must be written to zero when
        ADCSRB is written.
        • Bit 2:0 – ADTS2:0: ADC Auto Trigger Source
        If ADATE in ADCSRA is written to one, the value of these bits selects which source will trigger an ADC conversion. If ADATE
        is cleared, the ADTS2:0 settings will have no effect. A conversion will be triggered by the rising edge of the selected interrupt
        flag. Note that switching from a trigger source that is cleared to a trigger source that is set, will generate a positive edge on
        the trigger signal. If ADEN in ADCSRA is set, this will start a conversion. Switching to free running mode (ADTS[2:0]=0) will
        not cause a trigger event, even if the ADC interrupt flag is set.
        Table 5-100. ADC Auto Trigger Source Selections
                    ADTS2                  ADTS1                      ADTS0           Trigger Source
                       0                      0                           0           Free running mode
                       0                      0                           1           Analog comparator
                       0                      1                           0           External interrupt request 0
                       0                      1                           1           Timer/Counter0 compare match A
                       1                      0                           0           Timer/Counter0 overflow
                       1                      0                           1           Timer/Counter1 compare match B
                       1                      1                           0           Timer/Counter1 overflow
                       1                      1                           1           Timer/Counter1 capture event
5.23.9.7 DIDR0 – Digital Input Disable Register 0
                 Bit          7         6         5           4          3        2         1          0
              (0x7E)          –         –      ADC5D       ADC4D      ADC3D     ADC2D    ADC1D      ADC0D        DIDR0
           Read/Write         R         R        R/W        R/W        R/W       R/W      R/W         R/W
           Initial Value      0         0         0           0          0        0         0          0
        • Bits 7:6 – Res: Reserved Bits
        These bits are reserved for future use. To ensure compatibility with future devices, these bits must be written to zero when
        DIDR0 is written.
        • Bit 5:0 – ADC5D..ADC0D: ADC5..0 Digital Input Disable
        When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN
        register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC5..0 pin and the digital
        input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.
        Note that ADC pins ADC7 and ADC6 do not have digital input buffers, and therefore do not require digital input disable bits.
                                                                                                 ATA6614Q [DATASHEET]                 241
                                                                                                                 9240I–AUTO–03/16


5.24   debugWIRE On-chip Debug System
5.24.1 Features
         ●     Complete program flow control
         ●     Emulates all on-chip functions, both digital and analog, except RESET pin
         ●     Real-time operation
         ●     Symbolic debugging support (both at C and assembler source level, or for other HLLs)
         ●     Unlimited number of program break points (using software break points)
         ●     Non-intrusive operation
         ●     Electrical characteristics identical to real device
         ●     Automatic configuration system
         ●     High-speed operation
         ●     Programming of non-volatile memories
5.24.2 Overview
       The debugWIRE on-chip debug system uses a one-wire, bi-directional interface to control the program flow, execute AVR®
       instructions in the CPU and to program the different non-volatile memories.
5.24.3 Physical Interface
       When the debugWIRE Enable (DWEN) Fuse is programmed and lock bits are unprogrammed, the debugWIRE system
       within the target device is activated. The RESET port pin is configured as a wire-AND (open-drain) bi-directional I/O pin with
       pull-up enabled and becomes the communication gateway between target and emulator.
       Figure 5-113. The debugWIRE Setup
                                                                                    1.8 - 5.5V
                                                                               VCC
                                                    dw             dw(RESET)
                                                                   GND
       Figure 5-113 shows the schematic of a target MCU, with debugWIRE enabled, and the emulator connector. The system
       clock is not affected by debugWIRE and will always be the clock source selected by the CKSEL fuses.
       When designing a system where debugWIRE will be used, the following observations must be made for correct operation:
         ● Pull-up resistors on the dW/(RESET) line must not be smaller than 10k. The pull-up resistor is not required for
               debugWIRE functionality.
         ●     Connecting the RESET pin directly to VCC will not work.
         ●     Capacitors connected to the RESET pin must be disconnected when using debugWire.
         ●     All external reset sources must be disconnected.
242    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.24.4 Software Break Points
        debugWIRE supports program memory break points by the AVR® Break instruction. Setting a Break Point in AVR Studio®
        will insert a BREAK instruction in the program memory. The instruction replaced by the BREAK instruction will be stored.
        When program execution is continued, the stored instruction will be executed before continuing from the program memory. A
        break can be inserted manually by putting the BREAK instruction in the program.
        The flash must be re-programmed each time a break point is changed. This is automatically handled by AVR Studio through
        the debugWIRE interface. The use of break points will therefore reduce the flash data retention. Devices used for debugging
        purposes should not be shipped to end customers.
5.24.5 Limitations of debugWIRE
        The debugWIRE communication pin (dW) is physically located on the same pin as external reset (RESET). An external reset
        source is therefore not supported when the debugWIRE is enabled.
        A programmed DWEN Fuse enables some parts of the clock system to be running in all sleep modes. This will increase the
        power consumption while in sleep. Thus, the DWEN Fuse should be disabled when debugWire is not used.
5.24.6 Register Description
        The following section describes the registers used with the debugWire.
5.24.6.1 DWDR – debugWire Data Register
         Bit               7         6          5        4       3        2         1          0
                           DWDR[7:0]                                                                     DWDR
         Read/Write        R/W       R/W        R/W      R/W     R/W      R/W       R/W        R/W
         Initial Value     0         0          0        0       0        0         0          0
        The DWDR register provides a communication channel from the running program in the MCU to the debugger. This register
        is only accessible by the debugWIRE and can therefore not be used as a general purpose register in the normal operations.
5.25    Self-programming the Flash, ATmega328P
5.25.1 Overview
        In ATmega328P, there is no read-while-write support, and no separate boot loader section. The SPM instruction can be
        executed from the entire flash.
        The device provides a self-programming mechanism for downloading and uploading program code by the MCU itself. The
        self-programming can use any available data interface and associated protocol to read code and write (program) that code
        into the program memory.
        The program memory is updated in a page by page fashion. Before programming a page with the data stored in the
        temporary page buffer, the page must be erased. The temporary page buffer is filled one word at a time using SPM and the
        buffer can be filled either before the page erase command or between a page erase and a page write operation:
        Alternative 1, fill the buffer before a page erase
           ● Fill temporary page buffer
           ●      Perform a page erase
           ●      Perform a page write
        Alternative 2, fill the buffer after page erase
           ● Perform a page erase
           ●      Fill temporary page buffer
           ●      Perform a page Write
                                                                                             ATA6614Q [DATASHEET]              243
                                                                                                           9240I–AUTO–03/16


        If only a part of the page needs to be changed, the rest of the page must be stored (for example in the temporary page
        buffer) before the erase, and then be re-written. When using alternative 1, the boot loader provides an effective read-modify-
        write feature which allows the user software to first read the page, do the necessary changes, and then write back the
        modified data. If alternative 2 is used, it is not possible to read the old data while loading since the page is already erased.
        The temporary page buffer can be accessed in a random sequence. It is essential that the page address used in both the
        page erase and page write operation is addressing the same page.
5.25.1.1 Performing Page Erase by SPM
        To execute page erase, set up the address in the Z-pointer, write “00000011” to SPMCSR and execute SPM within four
        clock cycles after writing SPMCSR. The data in R1 and R0 is ignored. The page address must be written to PCPAGE in the
        Z-register. Other bits in the Z-pointer will be ignored during this operation.
           ● The CPU is halted during the page erase operation.
5.25.1.2 Filling the Temporary Buffer (Page Loading)
        To write an instruction word, set up the address in the Z-pointer and data in R1:R0, write “00000001” to SPMCSR and
        execute SPM within four clock cycles after writing SPMCSR. The content of PCWORD in the Z-register is used to address
        the data in the temporary buffer. The temporary buffer will auto-erase after a Page Write operation or by writing the
        RWWSRE bit in SPMCSR. It is also erased after a system reset. Note that it is not possible to write more than one time to
        each address without erasing the temporary buffer. If the EEPROM is written in the middle of an SPM Page Load operation,
        all data loaded will be lost.
5.25.1.3 Performing a Page Write
        To execute page write, set up the address in the Z-pointer, write “00000101” to SPMCSR and execute SPM within four clock
        cycles after writing SPMCSR. The data in R1 and R0 is ignored. The page address must be written to PCPAGE. Other bits
        in the Z-pointer must be written to zero during this operation.
           ● The CPU is halted during the page write operation.
5.25.2 Addressing the Flash During Self-programming
        The Z-pointer is used to address the SPM commands.
                Bit           15        14          13        12          11        10         9          8
            ZH (R31)         Z15       Z14         Z13        Z12        Z11       Z10        Z9         Z8
             ZL (R30)         Z7        Z6          Z5        Z4         Z3         Z2        Z1         Z0
                              7          6           5         4           3         2         1          0
        Since the flash is organized in pages (see Table 5-119 on page 265), the program counter can be treated as having two
        different sections. One section, consisting of the least significant bits, is addressing the words within a page, while the most
        significant bits are addressing the pages. This is shown in Figure 5-117 on page 254. Note that the page erase and page
        write operations are addressed independently. Therefore it is of major importance that the software addresses the same
        page in both the page erase and page write operation.
        The LPM instruction uses the Z-pointer to store the address. Since this instruction addresses the flash byte-by-byte, also the
        LSB (bit Z0) of the Z-pointer is used.
244     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        Figure 5-114. Addressing the Flash During SPM(1)
                                 BIT   15      ZPCMSB               ZPAGEMSB    1 0
                         Z-REGISTER                                               0
                                                PCMSB                PAGEMSB
                                    PROGRAM
                                     COUNTER             PCPAGE        PCWORD
                                              PAGE ADDRESS                  WORD ADDRESS
                                           WITHIN THE FLASH                 WITHIN PAGE
                                Program Memory                                              Page             PCWORD[PAGEMSB:0]
                                      Page                                            Instructions Word      00
                                                                                                             01
                                                                                                             02
                                                                                                             PAGEEND
        Note:       1.  The different variables used in Figure 5-117 are listed in Table 5-119 on page 265.
5.25.2.1 EEPROM Write Prevents Writing to SPMCSR
        Note that an EEPROM write operation will block all software programming to flash. Reading the fuses and lock bits from
        software will also be prevented during the EEPROM write operation. It is recommended that the user checks the status bit
        (EEPE) in the EECR register and verifies that the bit is cleared before writing to the SPMCSR register.
5.25.2.2 Reading the Fuse and Lock Bits from Software
        It is possible to read both the fuse and lock bits from software. To read the lock bits, load the Z-pointer with 0x0001 and set
        the BLBSET and SELFPRGEN bits in SPMCSR. When an LPM instruction is executed within three CPU cycles after the
        BLBSET and SELFPRGEN bits are set in SPMCSR, the value of the lock bits will be loaded in the destination register. The
        BLBSET and SELFPRGEN bits will auto-clear upon completion of reading the lock bits or if no LPM instruction is executed
        within three CPU cycles or no SPM instruction is executed within four CPU cycles. When BLBSET and SELFPRGEN are
        cleared, LPM will work as described in the instruction set manual.
                Bit            7           6           5         4       3            2             1        0
                Rd             –           –           –         –       –            –           LB2       LB1
        The algorithm for reading the fuse low byte is similar to the one described above for reading the lock bits. To read the fuse
        low byte, load the Z-pointer with 0x0000 and set the BLBSET and SELFPRGEN bits in SPMCSR. When an LPM instruction
        is executed within three cycles after the BLBSET and SELFPRGEN bits are set in the SPMCSR, the value of the fuse low
        byte (FLB) will be loaded in the destination register as shown below.See Table 5-115 on page 264 for a detailed description
        and mapping of the fuse low byte.
                Bit            7           6          5          4        3           2             1        0
                Rd           FLB7        FLB6       FLB5       FLB4     FLB3        FLB2         FLB1      FLB0
        Similarly, when reading the fuse high byte (FHB), load 0x0003 in the Z-pointer. When an LPM instruction is executed within
        three cycles after the BLBSET and SELFPRGEN bits are set in the SPMCSR, the value of the fuse high byte will be loaded
        in the destination register as shown below. See Table 5-114 on page 263 for detailed description and mapping of the
        extended fuse byte.
                Bit            7           6          5          4        3           2             1        0
                Rd           FHB7        FHB6       FHB5      FHB4     FHB3         FHB2         FHB1      FHB0
        Similarly, when reading the extended fuse byte (EFB), load 0x0002 in the Z-pointer. When an LPM instruction is executed
        within three cycles after the BLBSET and SELFPRGEN bits are set in the SPMCSR, the value of the extended fuse byte will
                                                                                                        ATA6614Q [DATASHEET]        245
                                                                                                                   9240I–AUTO–03/16


        be loaded in the destination register as shown below. See Table 5-115 on page 264 for detailed description and mapping of
        the extended fuse byte.
                Bit           7          6        5          4          3          2         1          0
                Rd         FHB7       FHB6      FHB5       FHB4      FHB3       FHB2      FHB1        FHB0
        Fuse and lock bits that are programmed, will be read as zero. Fuse and Lock bits that are unprogrammed, will be read as
        one.
5.25.2.3 Preventing Flash Corruption
        During periods of low VCC, the flash program can be corrupted because the supply voltage is too low for the CPU and the
        flash to operate properly. These issues are the same as for board level systems using the flash, and the same design
        solutions should be applied.
        A flash program corruption can be caused by two situations when the voltage is too low. First, a regular write sequence to
        the flash requires a minimum voltage to operate correctly. Secondly, the CPU itself can execute instructions incorrectly, if the
        supply voltage for executing instructions is too low.
        Flash corruption can easily be avoided by following these design recommendations (one is sufficient):
           1. Keep the AVR RESET active (low) during periods of insufficient power supply voltage. This can be done by
                enabling the internal brown-out detector (BOD) if the operating voltage matches the detection level. If not, an
                external low VCC reset protection circuit can be used. If a reset occurs while a write operation is in progress, the
                write operation will be completed provided that the power supply voltage is sufficient.
           2.   Keep the AVR core in power-down sleep mode during periods of low VCC. This will prevent the CPU from attempt-
                ing to decode and execute instructions, effectively protecting the SPMCSR register and thus the flash from
                unintentional writes.
5.25.2.4 Programming Time for Flash when Using SPM
        The calibrated RC oscillator is used to time flash accesses. Table 5-107 shows the typical programming time for flash
        accesses from the CPU.
        Table 5-101. SPM Programming Time(1)
                                 Symbol                               Min Programming Time                Max Programming Time
          Flash write (page erase, page write, and write lock
                                                                                3.7ms                                4.5ms
          bits by SPM)
          Note:     1. Minimum and maximum programming time is per individual operation.
246     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.25.2.5 Simple Assembly Code Example for a Boot Loader
        Note that the RWWSB bit will always be read as zero in ATmega328P. Nevertheless, it is recommended to check this bit as
        shown in the code example, to ensure compatibility with devices supporting read-while-write.
                         ;-the routine writes one page of data from RAM to Flash
                         ; the first data location in RAM is pointed to by the Y pointer
                         ; the first data location in Flash is pointed to by the Z-pointer
                         ;-error handling is not included
                         ;-the routine must be placed inside the Boot space
                         ; (at least the Do_spm sub routine). Only code inside NRWW section can
                         ; be read during Self-programming (Page Erase and Page Write).
                         ;-registers used: r0, r1, temp1 (r16), temp2 (r17), looplo (r24),
                         ; loophi (r25), spmcrval (r20)
                         ; storing and restoring of registers is not included in the routine
                         ; register usage can be optimized at the expense of code size
                         ;-It is assumed that either the interrupt table is moved to the Boot
                         ; loader section or that the interrupts are disabled.
                 .equ                      PAGESIZEB = PAGESIZE*2;PAGESIZEB is page size in BYTES, not words
                 .org SMALLBOOTSTART
                 Write_page:
                         ;       Page Erase
                         ldi     spmcrval, (1<<PGERS) | (1<<SELFPRGEN)
                         rcall Do_spm
                         ;       re-enable the RWW section
                         ldi     spmcrval, (1<<RWWSRE) | (1<<SELFPRGEN)
                         rcall Do_spm
                         ;       transfer data from RAM to Flash page buffer
                         ldi     looplo, low(PAGESIZEB)               ;init loop variable
                         ldi     loophi, high(PAGESIZEB)              ;not required for PAGESIZEB<=256
                 Wrloop:
                         ld      r0, Y+
                         ld      r1, Y+
                         ldi     spmcrval, (1<<SELFPRGEN)
                         rcall Do_spm
                         adiw    ZH:ZL, 2
                         sbiw    loophi:looplo, 2                     ;use subi for PAGESIZEB<=256
                         brne    Wrloop
                         ;       execute Page Write
                         subi    ZL, low(PAGESIZEB)                   ;restore pointer
                         sbci    ZH, high(PAGESIZEB)                  ;not required for PAGESIZEB<=256
                         ldi     spmcrval, (1<<PGWRT) | (1<<SELFPRGEN)
                         rcall Do_spm
                         ;       re-enable the RWW section
                         ldi     spmcrval, (1<<RWWSRE) | (1<<SELFPRGEN)
                         rcall Do_spm
                         ;       read back and check, optional
                         ldi     looplo, low(PAGESIZEB)               ;init loop variable
                         ldi     loophi, high(PAGESIZEB)              ;not required for PAGESIZEB<=256
                         subi    YL, low(PAGESIZEB)                   ;restore pointer
                         sbci    YH, high(PAGESIZEB)
                                                                                          ATA6614Q [DATASHEET]             247
                                                                                                      9240I–AUTO–03/16


             Rdloop:
                     lpm   r0, Z+
                     ld    r1, Y+
                     cpse  r0, r1
                     rjmp  Error
                     sbiw  loophi:looplo, 1           ;use subi for PAGESIZEB<=256
                     brne  Rdloop
                     ;     return to RWW section
                     ;     verify that RWW section is safe to read
             Return:
                     in    temp1, SPMCSR
                     sbrs  temp1, RWWSB               ; If RWWSB is set, the RWW section is not
             ready
                                                        yet
                     ret
                     ;     re-enable the RWW section
                     ldi   spmcrval, (1<<RWWSRE) | (1<<SELFPRGEN)
                     rcall Do_spm
                     rjmp  Return
             Do_spm:
                     ;     check for previous SPM complete
             Wait_spm:
                     in    temp1, SPMCSR
                     sbrc  temp1, SELFPRGEN
                     rjmp  Wait_spm
                     ;     input: spmcrval determines SPM action
                     ;     disable interrupts if enabled, store status
                     in    temp2, SREG
                     cli
                     ;     check that no EEPROM write access is present
             Wait_ee:
                     sbic  EECR, EEPE
                     rjmp  Wait_ee
                     ;     SPM timed sequence
                     out   SPMCSR, spmcrval
                     spm
                     ;     restore SREG (to enable interrupts if originally enabled)
                     out   SREG, temp2
                     ret
248 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.25.3 Register Description
5.25.3.1 SPMCSR – Store Program Memory Control and Status Register
        The Store Program Memory Control and Status Register contains the control bits needed to control the Program memory
        operations.
                  Bit          7         6        5        4          3         2           1          0
           0x37 (0x57)       SPMIE   RWWSB        –     RWWSRE    BLBSET     PGWRT       PGERS    SELFPRGEN     SPMCSR
            Read/Write        R/W        R       R        R/W        R/W      R/W          R/W        R/W
            Initial Value      0         0        0        0          0         0           0          0
        • Bit 7 – SPMIE: SPM Interrupt Enable
        When the SPMIE bit is written to one, and the I-bit in the status register is set (one), the SPM ready interrupt will be enabled.
        The SPM ready Interrupt will be executed as long as the SELFPRGEN bit in the SPMCSR register is cleared. The interrupt
        will not be generated during EEPROM write or SPM.
        • Bit 6 – RWWSB: Read-While-Write Section Busy
        This bit is for compatibility with devices supporting read-while-write. It will always read as zero in ATmega328P.
        • Bit 5 – Res: Reserved Bit
        This bit is a reserved bit in the ATmega328P and will always read as zero.
        • Bit 4 – RWWSRE: Read-While-Write Section Read Enable
        If the RWWSRE bit is written while filling the temporary page buffer, the temporary page buffer will be cleared and the data
        will be lost.
        • Bit 3 – BLBSET: Boot Lock Bit Set
        An LPM instruction within three cycles after BLBSET and SELFPRGEN are set in the SPMCSR register, will read either the
        lock bits or the fuse bits (depending on Z0 in the Z-pointer) into the destination register. See Section 5.25.2.2 “Reading the
        Fuse and Lock Bits from Software” on page 245 for details.
        • Bit 2 – PGWRT: Page Write
        If this bit is written to one at the same time as SELFPRGEN, the next SPM instruction within four clock cycles executes page
        Write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z-pointer. The data in
        R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a page write, or if no SPM instruction is executed
        within four clock cycles. The CPU is halted during the entire page write operation.
        • Bit 1 – PGERS: Page Erase
        If this bit is written to one at the same time as SELFPRGEN, the next SPM instruction within four clock cycles executes page
        erase. The page address is taken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PGERS bit will
        auto-clear upon completion of a page erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted
        during the entire page write operation.
        • Bit 0 – SELFPRGEN: Self Programming Enable
        This bit enables the SPM instruction for the next four clock cycles. If written to one together with either RWWSRE, BLBSET,
        PGWRT, or PGERS, the following SPM instruction will have a special meaning, see description above. If only SELFPRGEN
        is written, the following SPM instruction will store the value in R1:R0 in the temporary page buffer addressed by the Z-
        pointer. The LSB of the Z-pointer is ignored. The SELFPRGEN bit will auto-clear upon completion of an SPM instruction, or
        if no SPM instruction is executed within four clock cycles. During page erase and page write, the SELFPRGEN bit remains
        high until the operation is completed.
        Writing any other combination than “10001”, “01001”, “00101”, “00011” or “00001” in the lower five bits will have no effect.
                                                                                                  ATA6614Q [DATASHEET]               249
                                                                                                                9240I–AUTO–03/16


5.26    Boot Loader Support – Read-while-write Self-programming
5.26.1 Features
           ●   Read-while-write self-programming
           ●   Flexible boot memory size
           ●   High security (separate boot lock bits for a flexible protection)
           ●   Separate fuse to select reset vector
           ●   Optimized page(1) size
           ●   Code efficient algorithm
           ●   Efficient read-modify-write support
        Note:     1.   A page is a section in the flash consisting of several bytes (see Table 5-119 on page 265) used during program-
                       ming. The page organization does not affect normal operation.
5.26.2 Overview
        The boot loader support provides a real read-while-write self-programming mechanism for downloading and uploading
        program code by the MCU itself. This feature allows flexible application software updates controlled by the MCU using a
        flash-resident boot loader program. The boot loader program can use any available data interface and associated protocol to
        read code and write (program) that code into the flash memory, or read the code from the program memory. The program
        code within the boot loader section has the capability to write into the entire flash, including the boot loader memory. The
        boot loader can thus even modify itself, and it can also erase itself from the code if the feature is not needed anymore. The
        size of the Boot Loader memory is configurable with fuses and the boot loader has two separate sets of boot lock bits which
        can be set independently. This gives the user a unique flexibility to select different levels of protection.
5.26.3 Application and Boot Loader Flash Sections
        The flash memory is organized in two main sections, the application section and the boot loader section (see Figure 5-116).
        The size of the different sections is configured by the BOOTSZ Fuses as shown in Figure 5-116. These two sections can
        have different level of protection since they have different sets of lock bits.
5.26.3.1 Application Section
        The application section is the section of the flash that is used for storing the application code. The protection level for the
        application section can be selected by the application boot lock bits (boot lock bits 0), see Table 5-103 on page 253. The
        application section can never store any boot loader code since the SPM instruction is disabled when executed from the
        application section.
5.26.3.2 BLS – Boot Loader Section
        While the application section is used for storing the application code, the The boot loader software must be located in the
        BLS since the SPM instruction can initiate a programming when executing from the BLS only. The SPM instruction can
        access the entire flash, including the BLS itself. The protection level for the boot loader section can be selected by the boot
        loader lock bits (boot lock bits 1), see Table 5-104 on page 253.
5.26.4 Read-While-Write and No Read-While-Write Flash Sections
        Whether the CPU supports read-while-write or if the CPU is halted during a Boot Loader software update is dependent on
        which address that is being programmed. In addition to the two sections that are configurable by the BOOTSZ Fuses as
        described above, the flash is also divided into two fixed sections, the read-while-write (RWW) section and the no read-while-
        write (NRWW) section. The limit between the RWW- and NRWW sections is given in Figure 5-116 on page 252. The main
        difference between the two sections is:
           ● When erasing or writing a page located inside the RWW section, the NRWW section can be read during the
               operation.
           ●   When erasing or writing a page located inside the NRWW section, the CPU is halted during the entire operation.
        Note that the user software can never read any code that is located inside the RWW section during a boot loader software
        operation. The syntax “Read-While-Write section” refers to which section that is being programmed (erased or written), not
        which section that actually is being read during a boot loader software update.
250     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.26.4.1 RWW – Read-while-write Section
        If a boot loader software update is programming a page inside the RWW section, it is possible to read code from the flash,
        but only code that is located in the NRWW section. During an on-going programming, the software must ensure that the
        RWW section never is being read. If the user software is trying to read code that is located inside the RWW section (i.e., by
        a call/jmp/lpm or an interrupt) during programming, the software might end up in an unknown state. To avoid this, the
        interrupts should either be disabled or moved to the boot loader section. The boot loader section is always located in the
        NRWW section. The RWW section busy bit (RWWSB) in the store program memory control and status register (SPMCSR)
        will be read as logical one as long as the RWW section is blocked for reading. After a programming is completed, the
        RWWSB must be cleared by software before reading code located in the RWW section. See Section 5.26.9.1 “SPMCSR –
        Store Program Memory Control and Status Register” on page 261 for details on how to clear RWWSB.
5.26.4.2 NRWW – No Read-While-Write Section
        The code located in the NRWW section can be read when the boot loader software is updating a page in the RWW section.
        When the boot loader code updates the NRWW section, the CPU is halted during the entire page erase or page write
        operation.
        Table 5-102. Read-while-write Features
              Which Section does the
            Z-pointer Address during the            Which Section can be read                                    Read-while-write
                    Programming?                      during Programming?              CPU Halted?                  Supported?
                     RWW Section                          NRWW Section                        No                        Yes
                    NRWW Section                              None                            Yes                       No
        Figure 5-115. Read-while-write versus No Read-while-write
                                                                Read-while-write
                                                                 (RWW) Section
                                                                                       Z-pointer
                                                                                       Addresses NRWW
                                      Z-pointer                                        Section
                                      Addresses RWW
                                      Section                  No Read-while-write
                                                                 (RWW) Section         CPU is Halted During
                                                                                       the Operation
                                      Code located in
                                      NRWW Section
                                      can be Read During
                                      the Operation
                                                                                               ATA6614Q [DATASHEET]              251
                                                                                                             9240I–AUTO–03/16


       Figure 5-116. Memory Sections
                                                                 Program Memory                                                                     Program Memory
                                                                  BOOTSZ = ’11’                                                                      BOOTSZ = ’10’
                                                                                         0x0000                                                                             0x0000
                                  Read-while-write Section                                                           Read-while-write Section
                                                             Application Flash Section                                                          Application Flash Section
                                                                                         End RWW                                                                            End RWW
                                                                                         Start NRWW                                                                         Start NRWW
                          No Read-while-                     Application Flash Section                       No Read-while-                     Application Flash Section
                                                                                                                                                                            End Application
                                                                                         End Application
                           write Section                                                                      write Section
                                                                                                                                                                            Start Boot Loader
                                                                                         Start Boot Loader                                      Boot Loader Flash Section
                                                             Boot Loader Flash Section   Flashend                                                                           Flashend
                                                                 Program Memory                                                                     Program Memory
                                                                  BOOTSZ = ’01’                                                                      BOOTSZ = ’00’
                                                                                         0x0000                                                                             0x0000
                                  Read-while-write Section                                                           Read-while-write Section
                                                             Application Flash Section                                                          Application Flash Section
                                                                                                                                                                            End RWW, End
                                                                                         End RWW                                                                            Application
                                                                                         Start NRWW                                                                         Start RWW,
                          No Read-while-                                                                     No Read-while-
                                                             Application Flash Section                                                                                      Start Boot Loader
                                                                                         End Application                                        Boot Loader Flash Section
                                                                                         Start Boot Loader
                           write Section                                                                      write Section
                                                             Boot Loader Flash Section
                                                                                         Flashend                                                                           Flashend
5.26.5 Boot Loader Lock Bits
       If no boot loader capability is needed, the entire flash is available for application code. The boot loader has two separate sets
       of boot lock bits which can be set independently. This gives the user a unique flexibility to select different levels of protection.
       The user can select:
        ● To protect the entire flash from a software update by the MCU.
        ●     To protect only the boot loader flash section from a software update by the MCU.
        ●     To protect only the application flash section from a software update by the MCU.
        ●     Allow software update in the entire flash.
       See Table 5-103 and Table 5-104 for further details. The boot lock bits can be set in software and in serial or parallel
       programming mode, but they can be cleared by a chip erase command only. The general write lock (lock bit mode 2) does
       not control the programming of the flash memory by SPM instruction. Similarly, the general read/write lock (lock bit mode 1)
       does not control reading nor writing by LPM/SPM, if it is attempted.
252    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


       Table 5-103. Boot Lock Bit0 Protection Modes (Application Section)(1)
           BLB0 Mode            BLB02         BLB01      Protection
                 1                 1             1       No restrictions for SPM or LPM accessing the application section.
                 2                 1             0       SPM is not allowed to write to the application section.
                                                         SPM is not allowed to write to the application section, and LPM executing
                                                         from the boot loader section is not allowed to read from the application
                 3                 0             0
                                                         section. If interrupt vectors are placed in the boot loader section, interrupts
                                                         are disabled while executing from the application section.
                                                         LPM executing from the boot loader section is not allowed to read from the
                 4                 0             1       application section. If interrupt vectors are placed in the boot loader section,
                                                         interrupts are disabled while executing from the application section.
        Note:     1.   “s unpr1” unprogrammed, “0” means programmed.
       Table 5-104. Boot Lock Bit1 Protection Modes (Boot Loader Section)(1)
           BLB1 Mode            BLB12         BLB11      Protection
                 1                 1             1       No restrictions for SPM or LPM accessing the boot loader section.
                 2                 1             0       SPM is not allowed to write to the boot loader section.
                                                         SPM is not allowed to write to the boot loader section, and LPM executing
                                                         from the application section is not allowed to read from the boot loader
                 3                 0             0
                                                         section. If interrupt vectors are placed in the application section, interrupts
                                                         are disabled while executing from the boot loader section.
                                                         LPM executing from the application section is not allowed to read from the
                 4                 0             1       boot loader section. If interrupt vectors are placed in the application section,
                                                         interrupts are disabled while executing from the boot loader section.
        Note:     1.   “1” means unprogrammed, “0” means programmed
5.26.6 Entering the Boot Loader Program
       Entering the boot loader takes place by a jump or call from the application program. This may be initiated by a trigger such
       as a command received via USART, or SPI interface. Alternatively, the boot reset fuse can be programmed so that the reset
       vector is pointing to the boot flash start address after a reset. In this case, the boot loader is started after a reset. After the
       application code is loaded, the program can start executing the application code. Note that the fuses cannot be changed by
       the MCU itself. This means that once the boot reset fuse is programmed, the reset vector will always point to the boot loader
       reset and the fuse can only be changed through the serial or parallel programming interface.
       Table 5-105. Boot Reset Fuse(1)
            BOOTRST            Reset Address
                  1            Reset vector = Application reset (address 0x0000)
                  0            Reset vector = Boot loader reset
        Note:     1.   “1” means unprogrammed, “0” means programmed
                                                                                                  ATA6614Q [DATASHEET]                  253
                                                                                                                 9240I–AUTO–03/16


5.26.7 Addressing the Flash During Self-programming
       The Z-pointer is used to address the SPM commands.
               Bit          15           14          13        12       11          10             9   8
           ZH (R31)         Z15         Z14         Z13        Z12     Z11          Z10           Z9   Z8
           ZL (R30)         Z7           Z6          Z5        Z4       Z3          Z2            Z1   Z0
                             7            6           5         4        3           2             1    0
       Since the flash is organized in pages (see Table 5-119 on page 265), the program counter can be treated as having two
       different sections. One section, consisting of the least significant bits, is addressing the words within a page, while the most
       significant bits are addressing the pages. This is1 shown in Figure 5-117. Note that the page erase and page write
       operations are addressed independently. Therefore it is of major importance that the boot loader software addresses the
       same page in both the page erase and page write operation. Once a programming operation is initiated, the address is
       latched and the Z-pointer can be used for other operations.
       The only SPM operation that does not use the Z-pointer is setting the boot loader lock bits. The content of the Z-pointer is
       ignored and will have no effect on the operation. The LPM instruction does also use the Z-pointer to store the address. Since
       this instruction addresses the Flash byte-by-byte, also the LSB (bit Z0) of the Z-pointer is used.
       Figure 5-117. Addressing the Flash During SPM
                               BIT   15       ZPCMSB               ZPAGEMSB    1 0
                       Z-REGISTER                                                0
                                               PCMSB                PAGEMSB
                                  PROGRAM
                                   COUNTER              PCPAGE        PCWORD
                                             PAGE ADDRESS                  WORD ADDRESS
                                          WITHIN THE FLASH                 WITHIN PAGE
                              Program Memory                                               Page         PCWORD[PAGEMSB:0]
                                    Page                                             Instructions Word  00
                                                                                                        01
                                                                                                        02
                                                                                                        PAGEEND
254    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


5.26.8 Self-programming the Flash
        The program memory is updated in a page by page fashion. Before programming a page with the data stored in the
        temporary page buffer, the page must be erased. The temporary page buffer is filled one word at a time using SPM and the
        buffer can be filled either before the page erase command or between a page erase and a page write operation:
        Alternative 1, fill the buffer before a page erase
           ● Fill temporary page buffer
           ●    Perform a page erase
           ●    Perform a page write
        Alternative 2, fill the buffer after page erase
           ● Perform a page erase
           ●    Fill temporary page buffer
           ●    Perform a page write
        If only a part of the page needs to be changed, the rest of the page must be stored (for example in the temporary page
        buffer) before the erase, and then be rewritten. When using alternative 1, the boot loader provides an effective read-modify-
        write feature which allows the user software to first read the page, do the necessary changes, and then write back the
        modified data. If alternative 2 is used, it is not possible to read the old data while loading since the page is already erased.
        The temporary page buffer can be accessed in a random sequence. It is essential that the page address used in both the
        page erase and page write operation is addressing the same page. See Section 5.26.8.13 “Simple Assembly Code Example
        for a Boot Loader” on page 258 for an assembly code example.
5.26.8.1 Performing Page Erase by SPM
        To execute page erase, set up the address in the Z-pointer, write “X0000011” to SPMCSR and execute SPM within four
        clock cycles after writing SPMCSR. The data in R1 and R0 is ignored. The page address must be written to PCPAGE in the
        Z-register. Other bits in the Z-pointer will be ignored during this operation.
           ● Page erase to the RWW section: The NRWW section can be read during the page erase.
           ●    Page erase to the NRWW section: The CPU is halted during the operation.
5.26.8.2 Filling the Temporary Buffer (Page Loading)
        To write an instruction word, set up the address in the Z-pointer and data in R1:R0, write “00000001” to SPMCSR and
        execute SPM within four clock cycles after writing SPMCSR. The content of PCWORD in the Z-register is used to address
        the data in the temporary buffer. The temporary buffer will auto-erase after a page write operation or by writing the
        RWWSRE bit in SPMCSR. It is also erased after a system reset. Note that it is not possible to write more than one time to
        each address without erasing the temporary buffer.
        If the EEPROM is written in the middle of an SPM page load operation, all data loaded will be lost.
5.26.8.3 Performing a Page Write
        To execute page write, set up the address in the Z-pointer, write “X0000101” to SPMCSR and execute SPM within four clock
        cycles after writing SPMCSR. The data in R1 and R0 is ignored. The page address must be written to PCPAGE. Other bits
        in the Z-pointer must be written to zero during this operation.
           ● Page write to the RWW section: The NRWW section can be read during the page write.
           ●    Page write to the NRWW section: The CPU is halted during the operation.
5.26.8.4 Using the SPM Interrupt
        If the SPM interrupt is enabled, the SPM interrupt will generate a constant interrupt when the SELFPRGEN bit in SPMCSR is
        cleared. This means that the interrupt can be used instead of polling the SPMCSR register in software. When using the SPM
        interrupt, the Interrupt Vectors should be moved to the BLS section to avoid that an interrupt is accessing the RWW section
        when it is blocked for reading. How to move the interrupts is described in Section 5.11 “Interrupts” on page 73.
5.26.8.5 Consideration While Updating BLS
        Special care must be taken if the user allows the boot loader section to be updated by leaving boot lock bit11
        unprogrammed. An accidental write to the boot loader itself can corrupt the entire boot loader, and further software updates
        might be impossible. If it is not necessary to change the boot loader software itself, it is recommended to program the boot
        lock bit11 to protect the boot loader software from any internal software changes.
                                                                                                  ATA6614Q [DATASHEET]                255
                                                                                                                 9240I–AUTO–03/16


5.26.8.6 Prevent Reading the RWW Section During Self-programming
        During self-programming (either page erase or page write), the RWW section is always blocked for reading. The user
        software itself must prevent that this section is addressed during the self programming operation. The RWWSB in the
        SPMCSR will be set as long as the RWW section is busy. During self-programming the interrupt vector table should be
        moved to the BLS as described in Section 5.10.8 “Watchdog Timer” on page 68, or the interrupts must be disabled. Before
        addressing the RWW section after the programming is completed, the user software must clear the RWWSB by writing the
        RWWSRE. See Section 5.26.8.13 “Simple Assembly Code Example for a Boot Loader” on page 258 for an example.
5.26.8.7 Setting the Boot Loader Lock Bits by SPM
        To set the boot loader lock bits and general lock bits, write the desired data to R0, write “X0001001” to SPMCSR and
        execute SPM within four clock cycles after writing SPMCSR.
                Bit            7         6          5         4         3           2       1           0
                R0             1         1       BLB12     BLB11     BLB02       BLB01     LB2         LB1
        See Table 5-103 and Table 5-104 for how the different settings of the boot loader bits affect the flash access.
        If bits 5..0 in R0 are cleared (zero), the corresponding lock bit will be programmed if an SPM instruction is executed within
        four cycles after BLBSET and SELFPRGEN are set in SPMCSR. The Z-pointer is don’t care during this operation, but for
        future compatibility it is recommended to load the Z-pointer with 0x0001 (same as used for reading the lOck bits). For future
        compatibility it is also recommended to set bits 7 and 6 in R0 to “1” when writing the lock bits. When programming the lock
        bits the entire flash can be read during the operation.
5.26.8.8 EEPROM Write Prevents Writing to SPMCSR
        Note that an EEPROM write operation will block all software programming to flash. Reading the fuses and lock bits from
        software will also be prevented during the EEPROM write operation. It is recommended that the user checks the status bit
        (EEPE) in the EECR register and verifies that the bit is cleared before writing to the SPMCSR register.
5.26.8.9 Reading the Fuse and Lock Bits from Software
        It is possible to read both the fuse and lock bits from software. To read the lock bits, load the Z-pointer with 0x0001 and set
        the BLBSET and SELFPRGEN bits in SPMCSR. When an LPM instruction is executed within three CPU cycles after the
        BLBSET and SELFPRGEN bits are set in SPMCSR, the value of the lock bits will be loaded in the destination register. The
        BLBSET and SELFPRGEN bits will auto-clear upon completion of reading the lock bits or if no LPM instruction is executed
        within three CPU cycles or no SPM instruction is executed within four CPU cycles. When BLBSET and SELFPRGEN are
        cleared, LPM will work as described in the instruction set manual.
                Bit            7         6          5         4         3           2       1           0
                Rd             –         –       BLB12     BLB11     BLB02       BLB01     LB2        LB1
        The algorithm for reading the fuse low byte is similar to the one described above for reading the lock bits. To read the fuse
        low byte, load the Z-pointer with 0x0000 and set the BLBSET and SELFPRGEN bits in SPMCSR. When an LPM instruction
        is executed within three cycles after the BLBSET and SELFPRGEN bits are set in the SPMCSR, the value of the fuse low
        byte (FLB) will be loaded in the destination register as shown below. Refer to Table 5-115 on page 264 for a detailed
        description and mapping of the fuse low byte.
                Bit            7         6          5         4         3           2       1           0
                Rd           FLB7      FLB6       FLB5      FLB4      FLB3        FLB2    FLB1        FLB0
        Similarly, when reading the fuse high byte, load 0x0003 in the Z-pointer. When an LPM instruction is executed within three
        cycles after the BLBSET and SELFPRGEN bits are set in the SPMCSR, the value of the fuse high byte (FHB) will be loaded
        in the destination register as shown below. Refer to Table 5-117 on page 265 for detailed description and mapping of the
        fuse high byte.
                Bit            7         6          5         4         3           2       1           0
                Rd          FHB7       FHB6      FHB5       FHB4      FHB3        FHB2    FHB1        FHB0
256     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        When reading the extended fuse byte, load 0x0002 in the Z-pointer. When an LPM instruction is executed within three cycles
        after the BLBSET and SELFPRGEN bits are set in the SPMCSR, the value of the extended fuse byte (EFB) will be loaded in
        the destination register as shown below. Refer to Table 5-114 on page 263 for detailed description and mapping of the
        extended fuse byte.
                Bit           7          6        5          4          3          2         1          0
               Rd             –          –        –          –       EFB3        EFB2     EFB1        EFB0
        Fuse and lock bits that are programmed, will be read as zero. Fuse and lock bits that are unprogrammed, will be read as
        one.
5.26.8.10 Reading the Signature Row from Software
        To read the signature row from software, load the Z-pointer with the signature byte address given in Table 5-106 on page
        257 and set the SIGRD and SPMEN bits in SPMCSR. When an LPM instruction is executed within three CPU cycles after
        the SIGRD and SPMEN bits are set in SPMCSR, the signature byte value will be loaded in the destination register. The
        SIGRD and SPMEN bits will auto-clear upon completion of reading the signature row lock bits or if no LPM instruction is
        executed within three CPU cycles. When SIGRD and SPMEN are cleared, LPM will work as described in the instruction set
        manual.
        Table 5-106. Signature Row Addressing
          Signature Byte                                                   Z-Pointer Address
          Device signature byte 1                                          0x0000
          Device signature byte 2                                          0x0002
          Device signature byte 3                                          0x0004
          RC oscillator calibration byte                                   0x0001
          TSOFFSET - Temp sensor offset                                    0x0002
          TSGAIN - Temp sensor gain                                        0x0003
          Note:         All other addresses are reserved for future use.
5.26.8.11 Preventing Flash Corruption
        During periods of low VCC, the flash program can be corrupted because the supply voltage is too low for the CPU and the
        flash to operate properly. These issues are the same as for board level systems using the flash, and the same design
        solutions should be applied.
        A flash program corruption can be caused by two situations when the voltage is too low. First, a regular write sequence to
        the flash requires a minimum voltage to operate correctly. Secondly, the CPU itself can execute instructions incorrectly, if the
        supply voltage for executing instructions is too low.
        Flash corruption can easily be avoided by following these design recommendations (one is sufficient):
           1. If there is no need for a boot loader update in the system, program the boot loader lock bits to prevent any boot
                loader software updates.
           2.   Keep the AVR® RESET active (low) during periods of insufficient power supply voltage. This can be done by
                enabling the internal brown-out detector (BOD) if the operating voltage matches the detection level. If not, an
                external low VCC reset protection circuit can be used. If a reset occurs while a write operation is in progress, the
                write operation will be completed provided that the power supply voltage is sufficient.
           3.   Keep the AVR core in power-down sleep mode during periods of low VCC. This will prevent the CPU from attempt-
                ing to decode and execute instructions, effectively protecting the SPMCSR register and thus the flash from
                unintentional writes.
                                                                                                 ATA6614Q [DATASHEET]                257
                                                                                                               9240I–AUTO–03/16


5.26.8.12 Programming Time for Flash when Using SPM
        The calibrated RC oscillator is used to time flash accesses. Table 5-107 shows the typical programming time for flash
        accesses from the CPU.
        Table 5-107. SPM Programming Time(1)
                              Symbol                              Min Programming Time                Max Programming Time
           Flash write (page erase, page write, and write
                                                                            3.7ms                             4.5ms
                         lock bits by SPM)
         Note:    1. Minimum and maximum programming time is per individual operation.
5.26.8.13 Simple Assembly Code Example for a Boot Loader
                          ;-the routine writes one page of data from RAM to Flash
                          ; the first data location in RAM is pointed to by the Y pointer
                          ; the first data location in Flash is pointed to by the Z-pointer
                          ;-error handling is not included
                          ;-the routine must be placed inside the Boot space
                          ; (at least the Do_spm sub routine). Only code inside NRWW section can
                          ; be read during Self-programming (Page Erase and Page Write).
                          ;-registers used: r0, r1, temp1 (r16), temp2 (r17), looplo (r24),
                          ; loophi (r25), spmcrval (r20)
                          ; storing and restoring of registers is not included in the routine
                          ; register usage can be optimized at the expense of code size
                          ;-It is assumed that either the interrupt table is moved to the Boot
                          ; loader section or that the interrupts are disabled.
                 .equ                        PAGESIZEB = PAGESIZE*2;PAGESIZEB is page size in BYTES, not words
                 .org SMALLBOOTSTART
                 Write_page:
                          ;         Page Erase
                          ldi       spmcrval, (1<<PGERS) | (1<<SELFPRGEN)
                          call      Do_spm
                          ;         re-enable the RWW section
                          ldi       spmcrval, (1<<RWWSRE) | (1<<SELFPRGEN)
                          call      Do_spm
                          ;         transfer data from RAM to Flash page buffer
                          ldi       looplo, low(PAGESIZEB)              ;init loop variable
                          ldi       loophi, high(PAGESIZEB)             ;not required for PAGESIZEB<=256
                 Wrloop:
                          ld        r0, Y+
                          ld        r1, Y+
                          ldi       spmcrval, (1<<SELFPRGEN)
                          call      Do_spm
                          adiw      ZH:ZL, 2
                          sbiw      loophi:looplo, 2                    ;use subi for PAGESIZEB<=256
                          brne      Wrloop
                          ;         execute Page Write
                          subi      ZL, low(PAGESIZEB)                  ;restore pointer
                          sbci      ZH, high(PAGESIZEB)                 ;not required for PAGESIZEB<=256
                          ldi       spmcrval, (1<<PGWRT) | (1<<SELFPRGEN)
                          call      Do_spm
                          ;         re-enable the RWW section
                          ldi       spmcrval, (1<<RWWSRE) | (1<<SELFPRGEN)
                          call      Do_spm
258     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


       ;    read back and check, optional
       ldi  looplo, low(PAGESIZEB)     ;init loop variable
       ldi  loophi, high(PAGESIZEB)    ;not required for PAGESIZEB<=256
       subi YL, low(PAGESIZEB)         ;restore pointer
       sbci YH, high(PAGESIZEB)
Rdloop:
       lpm  r0, Z+
       ld   r1, Y+
       cpse r0, r1
       jmp  Error
       sbiw loophi:looplo, 1           ;use subi for PAGESIZEB<=256
       brne Rdloop
       ;    return to RWW section
       ;    verify that RWW section is safe to read
Return:
       in   temp1, SPMCSR
       sbrs temp1, RWWSB               If RWWSB is set, the RWW section is not
                                       ready yet
       ret
       ;    re-enable the RWW section
       ldi  spmcrval, (1<<RWWSRE) | (1<<SELFPRGEN)
       call Do_spm
       rjmp Return
Do_spm:
       ;    check for previous SPM complete
Wait_spm:
       in   temp1, SPMCSR
       sbrc temp1, SELFPRGEN
       rjmp Wait_spm
       ;    input: spmcrval determines SPM action
       ;    disable interrupts if enabled, store status
       in   temp2, SREG
       cli
       ;    check that no EEPROM write access is present
Wait_ee:
       sbic EECR, EEPE
       rjmp Wait_ee
       ;    SPM timed sequence
       out  SPMCSR, spmcrval
       spm
       ;    restore SREG (to enable interrupts if originally enabled)
       out  SREG, temp2
       ret
                                                      ATA6614Q [DATASHEET]        259
                                                                 9240I–AUTO–03/16


5.26.8.14 ATmega328P Boot Loader Parameters
        In Table 5-108 through Table 5-110, the parameters used in the description of the self programming are given.
Table 5-108. Boot Size Configuration, ATmega328P
                                                                         Boot
                                                  Application           Loader             End
                             Boot                    Flash               Flash         Application    Boot Reset Address (Start Boot
 BOOTSZ1     BOOTSZ0          Size      Pages       Section            Section           Section             Loader Section)
     1           1         256 words      4     0x0000 - 0x3EFF    0x3F00 - 0x3FFF       0x3EFF                   0x3F00
     1           0         512 words      8     0x0000 - 0x3DFF   0x3E00 - 0x3FFF        0x3DFF                   0x3E00
     0           1        1024 words     16     0x0000 - 0x3BFF   0x3C00 - 0x3FFF        0x3BFF                   0x3C00
     0           0        2048 words     32     0x0000 - 0x37FF    0x3800 - 0x3FFF        0x37FF                  0x3800
 Note:       The different BOOTSZ fuse configurations are shown in Figure 5-116 on page 252.
Table 5-109. Read-While-Write Limit, ATmega328P
 Section                                                                Pages         Address
 Read-while-write section (RWW)                                           224         0x0000 - 0x37FF
 No read-while-write section (NRWW)                                        32         0x3800 - 0x3FFF
        For details about these two section, see Section 5.26.4.2 “NRWW – No Read-While-Write Section” on page 251 and Section
        5.26.4.1 “RWW – Read-while-write Section” on page 251
Table 5-110. Explanation of Different Variables used in Figure 5-117 and the Mapping to the Z-pointer, ATmega328P
                                              Corresponding
 Variable                                        Z-value(1)      Description
                                                                 Most significant bit in the program counter. (the program counter is
 PCMSB                          13
                                                                 14 bits PC[13:0])
                                                                 Most significant bit which is used to address the words within one
 PAGEMSB                         5
                                                                 page (64 words in a page requires 6 bits PC [5:0])
                                                                 Bit in Z-register that is mapped to PCMSB. Because Z0 is not
 ZPCMSB                                             Z14
                                                                 used, the ZPCMSB equals PCMSB + 1.
                                                                 Bit in Z-register that is mapped to PAGEMSB. Because Z0 is not
 ZPAGEMSB                                           Z6
                                                                 used, the ZPAGEMSB equals PAGEMSB + 1.
                                                                 Program counter page address: Page select, for page erase and
 PCPAGE                     PC[13:6]              Z14:Z7
                                                                 page write
                                                                 Program counter word address: Word select, for filling temporary
 PCWORD                      PC[5:0]               Z6:Z1
                                                                 buffer (must be zero during page write operation)
 Note:    1. Z15: always ignored
             Z0: should be zero for all SPM commands, byte select for the LPM instruction.
             See Section 5.26.7 “Addressing the Flash During Self-programming” on page 254 for details about the use of Z-pointer
             during self-programming.
260     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.26.9 Register Description
5.26.9.1 SPMCSR – Store Program Memory Control and Status Register
        The store program memory control and status register contains the control bits needed to control the boot loader operations.
                  Bit          7         6       5         4         3         2          1           0
           0x37 (0x57)       SPMIE   RWWSB       –     RWWSRE    BLBSET     PGWRT      PGERS SELFPRGEN SPMCSR
            Read/Write        R/W        R       R        R/W      R/W        R/W       R/W          R/W
            Initial Value      0         0       0         0         0         0          0           0
        • Bit 7 – SPMIE: SPM Interrupt Enable
        When the SPMIE bit is written to one, and the I-bit in the status register is set (one), the SPM ready interrupt will be enabled.
        The SPM ready Interrupt will be executed as long as the SELFPRGEN bit in the SPMCSR register is cleared.
        • Bit 6 – RWWSB: Read-While-Write Section Busy
        When a self-programming (page erase or page write) operation to the RWW section is initiated, the RWWSB will be set
        (one) by hardware. When the RWWSB bit is set, the RWW section cannot be accessed. The RWWSB bit will be cleared if
        the RWWSRE bit is written to one after a self-programming operation is completed. Alternatively the RWWSB bit will
        automatically be cleared if a page load operation is initiated.
        • Bit 5 – Res: Reserved Bit
        This bit is a reserved bit in the ATmega328P and always read as zero.
        • Bit 4 – RWWSRE: Read-While-Write Section Read Enable
        When programming (page erase or page write) to the RWW section, the RWW section is blocked for reading (the RWWSB
        will be set by hardware). To re-enable the RWW section, the user software must wait until the programming is completed
        (SELFPRGEN will be cleared). Then, if the RWWSRE bit is written to one at the same time as SELFPRGEN, the next SPM
        instruction within four clock cycles re-enables the RWW section. The RWW section cannot be re-enabled while the flash is
        busy with a page erase or a page write (SELFPRGEN is set). If the RWWSRE bit is written while the flash is being loaded,
        the flash load operation will abort and the data loaded will be lost.
        • Bit 3 – BLBSET: Boot Lock Bit Set
        If this bit is written to one at the same time as SELFPRGEN, the next SPM instruction within four clock cycles sets boot lock
        bits and memory lock bits, according to the data in R0. The data in R1 and the address in the Z-pointer are ignored. The
        BLBSET bit will automatically be cleared upon completion of the lock bit set, or if no SPM instruction is executed within four
        clock cycles.
        An LPM instruction within three cycles after BLBSET and SELFPRGEN are set in the SPMCSR register, will read either the
        lock bits or the fuse bits (depending on Z0 in the Z-pointer) into the destination register. See Section 5.26.8.9 “Reading the
        Fuse and Lock Bits from Software” on page 256 for details.
        • Bit 2 – PGWRT: Page Write
        If this bit is written to one at the same time as SELFPRGEN, the next SPM instruction within four clock cycles executes page
        write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z-pointer. The data in
        R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a page write, or if no SPM instruction is executed
        within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.
        • Bit 1 – PGERS: Page Erase
        If this bit is written to one at the same time as SELFPRGEN, the next SPM instruction within four clock cycles executes page
        erase. The page address is taken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PGERS bit will
        auto-clear upon completion of a page erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted
        during the entire page write operation if the NRWW section is addressed.
                                                                                                  ATA6614Q [DATASHEET]               261
                                                                                                               9240I–AUTO–03/16


       • Bit 0 – SELFPRGEN: Self Programming Enable
       This bit enables the SPM instruction for the next four clock cycles. If written to one together with either RWWSRE, BLBSET,
       PGWRT or PGERS, the following SPM instruction will have a special meaning, see description above. If only SELFPRGEN
       is written, the following SPM instruction will store the value in R1:R0 in the temporary page buffer addressed by the Z-
       pointer. The LSB of the Z-pointer is ignored. The SELFPRGEN bit will auto-clear upon completion of an SPM instruction, or
       if no SPM instruction is executed within four clock cycles. During Page Erase and Page Write, the SELFPRGEN bit remains
       high until the operation is completed.
       Writing any other combination than “10001”, “01001”, “00101”, “00011” or “00001” in the lower five bits will have no effect.
5.27   Memory Programming
5.27.1 Program And Data Memory Lock Bits
       The ATmega328P provides six lock bits which can be left unprogrammed (“1”) or can be programmed (“0”) to obtain the
       additional features listed in Table 5-112. The Lock bits can only be erased to “1” with the chip erase command.The
       ATmega328P has no separate boot loader section. The SPM instruction is enabled for the whole flash if the SELFPRGEN
       fuse is programmed (“0”), otherwise it is disabled.
       Table 5-111. Lock Bit Byte(1)
                   Lock Bit Byte                 Bit No          Description                   Default Value
                                                    7            –                             1 (unprogrammed)
                                                    6            –                             1 (unprogrammed)
                (2)
         BLB12                                      5            Boot lock bit                 1 (unprogrammed)
                (2)
         BLB11                                      4            Boot lock bit                 1 (unprogrammed)
                (2)
         BLB02                                      3            Boot lock bit                 1 (unprogrammed)
         BLB01(2)                                   2            Boot lock bit                 1 (unprogrammed)
         LB2                                        1            Lock bit                      1 (unprogrammed)
         LB1                                        0            Lock bit                      1 (unprogrammed)
         Notes:     1.  “1” means unprogrammed, “0” means programmed
                    2.  Only on ATmega328P
       Table 5-112. Lock Bit Protection Modes(1)(2)
                       Memory Lock Bits                   Protection Type
             LB Mode              LB2          LB1
                   1               1            1         No memory lock features enabled.
                                                          Further programming of the flash and EEPROM is disabled in parallel and
                   2               1            0         serial programming mode. The fuse bits are locked in both serial and
                                                          parallel programming mode(1).
                                                          Further programming and verification of the flash and EEPROM is disabled
                   3               0            0         in Parallel and serial programming mode. The boot lock bits and fuse bits
                                                          are locked in both serial and parallel programming mode(1).
         Notes:     1.  Program the Fuse bits and Boot Lock bits before programming the LB1 and LB2.
                    2.  “1” means unprogrammed, “0” means programmed
262    ATA6614Q [DATASHEET]
       9240I–AUTO–03/16


       Table 5-113. Lock Bit Protection Modes(1)(2)
           BLB0 Mode         BLB02        BLB01
                1               1            1       No restrictions for SPM or LPM accessing the application section.
                2               1            0       SPM is not allowed to write to the application section.
                                                     SPM is not allowed to write to the application section, and LPM executing
                                                     from the boot loader section is not allowed to read from the application
                3               0            0
                                                     section. If interrupt vectors are placed in the boot loader section, interrupts
                                                     are disabled while executing from the application section.
                                                     LPM executing from the boot loader section is not allowed to read from the
                4               0            1       application section. If interrupt vectors are placed in the boot loader section,
                                                     interrupts are disabled while executing from the application section.
           BLB1 Mode         BLB12        BLB11
                1               1            1       No restrictions for SPM or LPM accessing the boot loader section.
                2               1            0       SPM is not allowed to write to the boot loader section.
                                                     SPM is not allowed to write to the boot loader section, and LPM executing
                                                     from the application section is not allowed to read from the boot loader
                3               0            0
                                                     section. If interrupt vectors are placed in the application section, interrupts
                                                     are disabled while executing from the boot loader section.
                                                     LPM executing from the application section is not allowed to read from the
                4               0            1       boot loader section. If interrupt vectors are placed in the application section,
                                                     interrupts are disabled while executing from the boot loader section.
        Notes:   1.  Program the fuse bits and boot lock bits before programming the LB1 and LB2.
                 2.  “1” means unprogrammed, “0” means programmed
5.27.2 Fuse Bits
       The ATmega328P has three fuse bytes. Table 5-114 - Table 5-117 describe briefly the functionality of all the fuses and how
       they are mapped into the Fuse bytes. Note that the fuses are read as logical zero, “0”, if they are programmed.
       Table 5-114. Extended Fuse Byte for ATmega328P
            Extended Fuse Byte            Bit No                    Description                             Default Value
                      –                      7                            –                                       1
                      –                      6                            –                                       1
                      –                      5                            –                                       1
                      –                      4                            –                                       1
                      –                      3                            –                                       1
                      –                      2                            –                                       1
                      –                      1                            –                                       1
                SELFPRGEN                    0               Self Programming Enable                     1 (unprogrammed)
                                                                                             ATA6614Q [DATASHEET]                 263
                                                                                                            9240I–AUTO–03/16


    Table 5-115. Extended Fuse Byte for ATmega328P
         Extended Fuse Byte              Bit No                  Description                           Default Value
                   –                        7                         –                                     1
                   –                        6                         –                                     1
                   –                        5                         –                                     1
                   –                        4                         –                                     1
                   –                        3                         –                                     1
            BODLEVEL2(1)                    2          Brown-out detector trigger level             1 (unprogrammed)
            BODLEVEL1(1)                    1          Brown-out detector trigger level             1 (unprogrammed)
                         (1)
            BODLEVEL0                       0          Brown-out detector trigger level             1 (unprogrammed)
     Note:    1. See Table 5-132 on page 281 for BODLEVEL Fuse decoding.
    Table 5-116. Fuse High Byte for ATmega328P
     High Fuse Byte                      Bit No     Description                           Default Value
     RSTDISBL(1)                            7       External reset disable                1 (unprogrammed)
     DWEN                                   6       debugWIRE enable                      1 (unprogrammed)
                                                    Enable serial program and data        0 (programmed, SPI programming
     SPIEN(2)                               5
                                                    downloading                           enabled)
     WDTON(3)                               4       Watchdog timer always on              1 (unprogrammed)
                                                    EEPROM memory is preserved            1 (unprogrammed), EEPROM not
     EESAVE                                 3
                                                    through the chip erase                reserved
                                                    Select boot size (see Table 5-108
     BOOTSZ1                                2                                             0 (programmed)(4)
                                                    on page 260 for details)
                                                    Select boot size (see Table 5-108
     BOOTSZ0                                1                                             0 (programmed)(4)
                                                    on page 260 for details)
     BOOTRST                                0       Select reset vector                   1 (unprogrammed)
     Notes: 1.     See Section 5.13.3.2 “Alternate Functions of Port C” on page 92 for description of RSTDISBL fuse.
              2.   The SPIEN Fuse is not accessible in serial programming mode.
              3.   See Section 5.10.9.2 “WDTCSR – Watchdog Timer Control Register” on page 71 for details.
              4.   The default value of BOOTSZ[1:0] results in maximum boot size. See Section 5-121 “Pin Name Mapping” on
                   page 266.
264 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


        Table 5-117. Fuse Low Byte
         Low Fuse Byte                          Bit No      Description                            Default Value
         CKDIV8(4)                                 7        Divide clock by 8                      0 (programmed)
                  (3)
         CKOUT                                     6        Clock output                           1 (unprogrammed)
         SUT1                                      5        Select start-up time                   1 (unprogrammed)(1)
         SUT0                                      4        Select start-up time                   0 (programmed)(1)
         CKSEL3                                    3        Select clock source                    0 (programmed)(2)
         CKSEL2                                    2        Select clock source                    0 (programmed)(2)
         CKSEL1                                    1        Select clock source                    1 (unprogrammed)(2)
         CKSEL0                                    0        Select clock source                    0 (programmed)(2)
         Note:      1.   The default value of SUT1..0 results in maximum start-up time for the default clock source. See Table 5-14 on
                         page 54 for details.
                    2.   The default setting of CKSEL3..0 results in internal RC oscillator at 8MHz. See Table 5-13 on page 54 for
                         details.
                    3.   The CKOUT fuse allows the system clock to be output on PORTB0. See Section 5.8.9 “Clock Output Buffer”
                         on page 56 for details.
                    4.   See Section 5.8.11 “System Clock Prescaler” on page 56 for details.
        The status of the fuse bits is not affected by chip erase. Note that the fuse bits are locked if Lock bit1 (LB1) is programmed.
        Program the fuse bits before programming the lock bits.
5.27.2.1 Latching of Fuses
        The fuse values are latched when the device enters programming mode and changes of the fuse values will have no effect
        until the part leaves programming mode. This does not apply to the EESAVE Fuse which will take effect once it is
        programmed. The fuses are also latched on power-up in normal mode.
5.27.3 Signature Bytes
        All Atmel® microcontrollers have a three-byte signature code which identifies the device. This code can be read in both serial
        and parallel mode, also when the device is locked. The three bytes reside in a separate address space. For the
        ATmega328P the signature bytes are given in Table 5-118.
        Table 5-118. Device ID
                                                                                   Signature Bytes Address
                               Part                               0x000                       0x001                       0x002
                          ATmega328P                               0x1E                        0x95                        0x0F
5.27.4 Calibration Byte
        The ATmega328P has a byte calibration value for the Internal RC oscillator. This byte resides in the high byte of address
        0x000 in the signature address space. During reset, this byte is automatically written into the OSCCAL register to ensure
        correct frequency of the calibrated RC oscillator.
5.27.5 Page Size
        Table 5-119. No. of Words in a Page and No. of Pages in the Flash
         Device                   Flash Size         Page Size       PCWORD            No. of Pages         PCPAGE            PCMSB
                                   16K words
         ATmega328P                                  64 words          PC[5:0]              256             PC[13:6]             13
                                  (32K bytes)
        Table 5-120. No. of Words in a Page and No. of Pages in the EEPROM
         Device                 EEPROM Size         Page Size        PCWORD            No. of Pages         PCPAGE           EEAMSB
         ATmega328P                 1K bytes          4 bytes         EEA[1:0]              256             EEA[9:2]             9
                                                                                                 ATA6614Q [DATASHEET]               265
                                                                                                                9240I–AUTO–03/16


5.27.6 Parallel Programming Parameters, Pin Mapping, and Commands
        This section describes how to parallel program and verify flash program memory, EEPROM data memory, memory lock bits,
        and fuse bits in the ATmega328P. Pulses are assumed to be at least 250ns unless otherwise noted.
5.27.6.1 Signal Names
        In this section, some pins of the ATmega328P are referenced by signal names describing their functionality during parallel
        programming, see Figure 5-118 and Table 5-121. Pins not described in the following table are referenced by pin names.
        The XA1/XA0 pins determine the action executed when the XTAL1 pin is given a positive pulse. The bit coding is shown in
        Table 5-123.
        When pulsing WR or OE, the command loaded determines the action executed. The different commands are shown in Table
        5-124.
        Figure 5-118. Parallel Programming
                                                                                        +4.5 to 5.5V
                                             RDY/BSY           PD1                VCC
                                                   OE          PD2                      +4.5 to 5.5V
                                                  WR           PD3
                                                                                 AVCC
                                                  BS1          PD4
                                                                        PC[1:0]:PB[5:0]           DATA
                                                  XA0          PD5
                                                  XA1          PD6
                                               PAGEL           PD7
                                                 +12V          RESET
                                                  BS2          PC2
                                                               XTAL1
                                                               GND
        Note:          VCC – 0.3V < AVCC < VCC + 0.3V, however, AVCC should always be within 4.5 to 5.5V
        Table 5-121. Pin Name Mapping
         Signal Name in
         Programming Mode                       Pin Name             I/O     Function
                                                                             0: Device is busy programming, 1: Device is ready for
         RDY/BSY                                    PD1               O
                                                                             new command
         OE                                         PD2                I     Output enable (active low)
         WR                                         PD3                I     Write pulse (active low)
         BS1                                        PD4                I     Byte select 1 (“0” selects low byte, “1” selects high byte)
         XA0                                        PD5                I     XTAL action bit 0
         XA1                                        PD6                I     XTAL action bit 1
         PAGEL                                      PD7                I     Program memory and EEPROM data page load
                                                                             Byte select 2 (“0” selects low byte, “1” selects 2’nd high
         BS2                                        PC2                I
                                                                             byte)
         DATA                               {PC[1:0]: PB[5:0]}       I/O     Bi-directional data bus (output when OE is low)
266     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        Table 5-122. Pin Values Used to Enter Programming Mode
                        Pin                               Symbol                                           Value
                       PAGEL                         Prog_enable[3]                                          0
                        XA1                          Prog_enable[2]                                          0
                        XA0                          Prog_enable[1]                                          0
                        BS1                          Prog_enable[0]                                          0
        Table 5-123. XA1 and XA0 Coding
              XA1            XA0       Action when XTAL1 is Pulsed
                0              0       Load flash or EEPROM address (High or low address byte determined by BS1).
                0              1       Load data (high or low data byte for flash determined by BS1).
                1              0       Load command
                1              1       No action, idle
        Table 5-124. Command Byte Bit Coding
              Command Byte             Command Executed
                  1000 0000            Chip erase
                  0100 0000            Write fuse bits
                  0010 0000            Write lock bits
                  0001 0000            Write flash
                  0001 0001            Write EEPROM
                  0000 1000            Read signature bytes and calibration byte
                  0000 0100            Read fuse and lock bits
                  0000 0010            Read flash
                  0000 0011            Read EEPROM
5.27.7 Parallel Programming
5.27.7.1 Enter Programming Mode
        The following algorithm puts the device in parallel (high-voltage) programming mode:
           1. Set Prog_enable pins listed in Table 5-122 on page 267 to “0000”, RESET pin to 0V and VCC to 0V.
           2.    Apply 4.5 to 5.5V between VCC and GND.
        Ensure that VCC reaches at least àpçV within the next 20µs.
           3. Wait 20 to 60µs, and apply 11.5 to 12.5V to RESET.
           4.    Keep the Prog_enable pins unchanged for at least 10µs after the high-voltage has been applied to ensure the
                 Prog_enable signature has been latched.
           5.    Wait at least 300µs before giving any parallel programming commands.
           6.    Exit programming mode by power the device down or by bringing RESET pin to 0V.
        If the rise time of the VCC is unable to fulfill the requirements listed above, the following alternative algorithm can be used.
           1. Set Prog_enable pins listed in Table 5-122 on page 267 to “0000”, RESET pin to 0V and VCC to 0V.
           2.    Apply 4.5 to 5.5V between VCC and GND.
           3.    Monitor VCC, and as soon as VCC reaches 0.9 - 1.1V, apply 11.5 - 12.5V to RESET.
           4.    Keep the Prog_enable pins unchanged for at least 10µs after the high-voltage has been applied to ensure the
                 Prog_enable signature has been latched.
                                                                                                   ATA6614Q [DATASHEET]               267
                                                                                                                  9240I–AUTO–03/16


          5.   Wait until VCC actually reaches 4.5 to 5.5V before giving any parallel programming commands.
          6.   Exit programming mode by power the device down or by bringing RESET pin to 0V.
5.27.7.2 Considerations for Efficient Programming
        The loaded command and address are retained in the device during programming. For efficient programming, the following
        should be considered.
          ● The command needs only be loaded once when writing or reading multiple memory locations.
          ●    Skip writing the data value 0xFF, that is the contents of the entire EEPROM (unless the EESAVE Fuse is
               programmed) and flash after a chip erase.
          ●    Address high byte needs only be loaded before programming or reading a new 256 word window in flash or 256 byte
               EEPROM. This consideration also applies to signature bytes reading.
5.27.7.3 Chip Erase
        The chip erase will erase the flash and EEPROM(1) memories plus lock bits. The lock bits are not reset until the program
        memory has been completely erased. The fuse bits are not changed. A chip erase must be performed before the flash
        and/or EEPROM are reprogrammed.
        Note:    1.    The EEPRPOM memory is preserved during chip erase if the EESAVE fuse is programmed.
        Load command “Chip Erase”
          1. Set XA1, XA0 to “10”. This enables command loading.
          2.   Set BS1 to “0”.
          3.   Set DATA to “1000 0000”. This is the command for chip erase.
          4.   Give XTAL1 a positive pulse. This loads the command.
          5.   Give WR a negative pulse. This starts the chip erase. RDY/BSY goes low.
          6.   Wait until RDY/BSY goes high before loading a new command.
5.27.7.4 Programming the Flash
        The flash is organized in pages, see Table 5-119 on page 265. When programming the flash, the program data is latched into
        a page buffer. This allows one page of program data to be programmed simultaneously. The following procedure describes
        how to program the entire Flash memory:
        A. Load command “Write Flash”
          1. Set XA1, XA0 to “10”. This enables command loading.
          2.   Set BS1 to “0”.
          3.   Set DATA to “0001 0000”. This is the command for write flash.
          4.   Give XTAL1 a positive pulse. This loads the command.
        B. Load address low byte
          1. Set XA1, XA0 to “00”. This enables address loading.
          2.   Set BS1 to “0”. This selects low address.
          3.   Set DATA = Address low byte (0x00 - 0xFF).
          4.   Give XTAL1 a positive pulse. This loads the address low byte.
        C. Load data low byte
          1. Set XA1, XA0 to “01”. This enables data loading.
          2.   Set DATA = Data low byte (0x00 - 0xFF).
          3.   Give XTAL1 a positive pulse. This loads the data byte.
        D. Load data high byte
          1. Set BS1 to “1”. This selects high data byte.
          2.   Set XA1, XA0 to “01”. This enables data loading.
          3.   Set DATA = Data high byte (0x00 - 0xFF).
          4.   Give XTAL1 a positive pulse. This loads the data byte.
268     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


E. Latch Data
   1. Set BS1 to “1”. This selects high data byte.
   2.  Give PAGEL a positive pulse. This latches the data bytes. (See Figure 5-120 for signal waveforms)
F. Repeat B through E until the entire buffer is filled or until all data within the page is loaded.
While the lower bits in the address are mapped to words within the page, the higher bits address the pages within the
FLASH. This is illustrated in Figure 5-119 on page 269. Note that if less than eight bits are required to address words in the
page (pagesize < 256), the most significant bit(s) in the address low byte are used to address the page when performing a
page write.
G. Load address high byte
   1. Set XA1, XA0 to “00”. This enables address loading.
   2.  Set BS1 to “1”. This selects high address.
   3.  Set DATA = Address high byte (0x00 - 0xFF).
   4.  Give XTAL1 a positive pulse. This loads the address high byte.
H. Program Page
   1. Give WR a negative pulse. This starts programming of the entire page of data. RDY/BSY goes low.
   2.  Wait until RDY/BSY goes high (See Figure 5-120 for signal waveforms).
I. Repeat B through H until the entire flash is programmed or until all data has been programmed.
J. End page programming
   1. 1. Set XA1, XA0 to “10”. This enables command loading.
   2.  Set DATA to “0000 0000”. This is the command for no operation.
   3.  Give XTAL1 a positive pulse. This loads the command, and the internal write signals are reset.
Figure 5-119. Addressing the Flash Which is Organized in Pages(1)
                                    PCMSB                   PAGEMSB
                        PROGRAM
                         COUNTER             PCPAGE           PCWORD
                                  PAGE ADDRESS                    WORD ADDRESS
                               WITHIN THE FLASH                   WITHIN PAGE
                    Program Memory                                                 Page            PCWORD [PAGEMSB : 0]
                          Page                                               Instructions Word     00
                                                                                                   01
                                                                                                   02
                                                                                                   PAGEEND
Note:    1.   PCPAGE and PCWORD are listed in Table 5-119 on page 265.
                                                                                               ATA6614Q [DATASHEET]        269
                                                                                                          9240I–AUTO–03/16


        Figure 5-120. Programming the Flash Waveforms(1)
                                                                                    F
                           A      B         C        D      E       B         C          D      E     G           H       I
              DATA       0x10  ADDR. LOW DATA LOW DATA HIGH XX   ADDR. LOW DATA LOW   DATA HIGH XX ADDR. HIGH ADDR.EXT.H XX
               XA1
               XA0
               BS1
             XTAL1
               WR
           RDY/BSY
        RESET +12V
                OE
             PAGEL
               BS2
        Note:      1.  “XX” is don’t care. The letters refer to the programming description above.
5.27.7.5 Programming the EEPROM
        The EEPROM is organized in pages, see Table 5-120 on page 265. When programming the EEPROM, the program data is
        latched into a page buffer. This allows one page of data to be programmed simultaneously. The programming algorithm for
        the EEPROM data memory is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page 268 for details on
        Command, Address and Data loading):
          1. A: Load command “0001 0001”.
          2.    G: Load address high byte (0x00 - 0xFF).
          3.    B: Load address low byte (0x00 - 0xFF).
          4.    C: Load data (0x00 - 0xFF).
          5.    E: Latch data (give PAGEL a positive pulse).
        K: Repeat 3 through 5 until the entire buffer is filled.
        L: Program EEPROM page
          1. Set BS1 to “0”.
          2.    Give WR a negative pulse. This starts programming of the EEPROM page. RDY/BSY goes low.
          3.    Wait until to RDY/BSY goes high before programming the next page (See Figure 5-121 on page 271 for signal
                waveforms).
270     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


        Figure 5-121. Programming the EEPROM Waveforms
                                                                                  K
                             A        G         B       C      E         B        C        E       L
               DATA         0x11  ADDR. HIGH ADDR. LOW DATA    XX    ADDR. LOW   DATA      XX
                XA1
                XA0
                BS1
              XTAL1
                WR
           RDY/BSY
        RESET +12V
                 OE
             PAGEL
                BS2
5.27.7.6 Reading the Flash
        The algorithm for reading the flash memory is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page 268 for
        details on command and address loading):
          1. A: Load command “0000 0010”.
          2.   G: Load address high byte (0x00 - 0xFF).
          3.   B: Load address low byte (0x00 - 0xFF).
          4.   Set OE to “0”, and BS1 to “0”. The flash word low byte can now be read at DATA.
          5.   Set BS1 to “1”. The flash word high byte can now be read at DATA.
          6.   Set OE to “1”.
5.27.7.7 Reading the EEPROM
        The algorithm for reading the EEPROM memory is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page
        268 for details on command and address loading):
          1. A: Load command “0000 0011”.
          2.   G: Load address high byte (0x00 - 0xFF).
          3.   B: Load address low byte (0x00 - 0xFF).
          4.   Set OE to “0”, and BS1 to “0”. The EEPROM data byte can now be read at DATA.
          5.   Set OE to “1”.
5.27.7.8 Programming the Fuse Low Bits
        The algorithm for programming the fuse low bits is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page
        268 for details on command and data loading):
          1. A: Load command “0100 0000”.
          2.   C: Load data low byte. Bit n = “0” programs and bit n = “1” erases the fuse bit.
          3.   Give WR a negative pulse and wait for RDY/BSY to go high.
                                                                                                ATA6614Q [DATASHEET]           271
                                                                                                           9240I–AUTO–03/16


5.27.7.9 Programming the Fuse High Bits
          The algorithm for programming the fuse high bits is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page
          268 for details on command and data loading):
            1. A: Load command “0100 0000”.
            2.   C: Load data low byte. Bit n = “0” programs and bit n = “1” erases the Fuse bit.
            3.   Set BS1 to “1” and BS2 to “0”. This selects high data byte.
            4.   Give WR a negative pulse and wait for RDY/BSY to go high.
            5.   Set BS1 to “0”. This selects low data byte.
5.27.7.10 Programming the Extended Fuse Bits
          The algorithm for programming the extended fuse bits is as follows (refer to Section 5.27.7.4 “Programming the Flash” on
          page 268 for details on command and data loading):
            1. A: Load command “0100 0000”.
            2.   C: Load data low byte. Bit n = “0” programs and bit n = “1” erases the fuse bit.
            3.   Set BS1 to “0” and BS2 to “1”. This selects extended data byte.
            4.   Give WR a negative pulse and wait for RDY/BSY to go high.
            5.   Set BS2 to “0”. This selects low data byte.
Figure 5-122. Programming the FUSES Waveforms
                                       Write Fuse Low byte                     Write Fuse High byte              Write Extended Fuse byte
                       A       C                              A        C                              A     C
          DATA        0x40    DATA     XX                    0x40     DATA      XX                   0x40  DATA      XX
           XA1
           XA0
           BS1
           BS2
         XTAL1
            WR
       RDY/BSY
    RESET +12V
            OE
         PAGEL
5.27.7.11 Programming the Lock Bits
          The algorithm for programming the lock bits is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page 268 for
          details on command and data loading):
            1. A: Load command “0010 0000”.
            2.   C: Load data low byte. Bit n = “0” programs the lock bit. If LB mode 3 is programmed (LB1 and LB2 is pro-
                 grammed), it is not possible to program the boot lock bits by any external programming mode.
            3.   Give WR a negative pulse and wait for RDY/BSY to go high.
          The lock bits can only be cleared by executing chip erase.
272       ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


5.27.7.12 Reading the Fuse and Lock Bits
        The algorithm for reading the fuse and lock bits is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page 268
        for details on command loading):
          1. A: Load command “0000 0100”.
          2.   Set OE to “0”, BS2 to “0” and BS1 to “0”. The status of the fuse low bits can now be read at DATA (“0” means
               programmed).
          3.   Set OE to “0”, BS2 to “1” and BS1 to “1”. The status of the fuse high bits can now be read at DATA (“0” means
               programmed).
          4.   Set OE to “0”, BS2 to “1”, and BS1 to “0”. The status of the extended fuse bits can now be read at DATA (“0”
               means programmed).
          5.   Set OE to “0”, BS2 to “0” and BS1 to “1”. The status of the lock bits can now be read at DATA (“0” means
               programmed).
          6.   Set OE to “1”.
        Figure 5-123. Mapping between BS1, BS2 and the Fuse and Lock Bits During Read
                                         Fuse Low Byte                0
                                                                                              0
                                      Extended Fuse Byte              1
                                                                                                     DATA
                                                            BS2
                                            Lock Bits                 0
                                                                                              1
                                                                                    BS1
                                         Fuse High Byte               1
                                                            BS2
5.27.7.13 Reading the Signature Bytes
        The algorithm for reading the signature bytes is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page 268
        for details on command and address loading):
          1. A: Load command “0000 1000”.
          2.   B: Load address low byte (0x00 - 0x02).
          3.   Set OE to “0”, and BS1 to “0”. The selected signature byte can now be read at DATA.
          4.   Set OE to “1”.
5.27.7.14 Reading the Calibration Byte
        The algorithm for reading the calibration byte is as follows (refer to Section 5.27.7.4 “Programming the Flash” on page 268
        for details on command and address loading):
          1. A: Load command “0000 1000”.
          2.   B: Load address Low Byte, 0x00.
          3.   Set OE to “0”, and BS1 to “1”. The calibration byte can now be read at DATA.
          4.   Set OE to “1”.
5.27.7.15 Parallel Programming Characteristics
        For characteristics of the parallel programming, see Section 5.28.9 “Parallel Programming Characteristics” on page 285.
                                                                                                 ATA6614Q [DATASHEET]             273
                                                                                                             9240I–AUTO–03/16


5.27.8 Serial Downloading
        Both the flash and EEPROM memory arrays can be programmed using the serial SPI bus while RESET is pulled to GND.
        The serial interface consists of pins SCK, MOSI (input) and MISO (output). After RESET is set low, the programming enable
        instruction needs to be executed first before program/erase operations can be executed. NOTE, in Table 5-125 on page 274,
        the pin mapping for SPI programming is listed. Not all parts use the SPI pins dedicated for the internal SPI interface.
        Figure 5-124. Serial Programming and Verify(1)
                                                                                            +1.8V to 5.5V
                                                                                       VCC
                                                                                           +1.8V to 5.5V(2)
                                                MOSI
                                                                                    AVCC
                                                MISO
                                                 SCK
                                                                 XTAL1
                                                                 RESET
                                                                 GND
        Notes:    1.   If the device is clocked by the internal oscillator, it is no need to connect a clock source to the XTAL1 pin.
                  2.   VCC - 0.3V < AVCC < VCC + 0.3V, however, AVCC should always be within 2.7 - 5.5V
        When programming the EEPROM, an auto-erase cycle is built into the self-timed programming operation (in the serial mode
        ONLY) and there is no need to first execute the chip erase instruction. The chip erase operation turns the content of every
        memory location in both the program and EEPROM arrays into 0xFF.
        Depending on CKSEL fuses, a valid clock must be present. The minimum low and high periods for the serial clock (SCK)
        input are defined as follows:
        Low: > 2 CPU clock cycles for fck < 12MHz, 3 CPU clock cycles for fck ≥ 12MHz
        High: > 2 CPU clock cycles for fck < 12MHz, 3 CPU clock cycles for fck ≥ 12MHz
5.27.8.1 Serial Programming Pin Mapping
        Table 5-125. Pin Mapping Serial Programming
                  Symbol                         Pins                              I/O                          Description
                    MOSI                          PB3                                I                         Serial data in
                    MISO                          PB4                               O                          Serial data out
                     SCK                          PB5                                I                          Serial clock
274     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.27.8.2 Serial Programming Algorithm
        When writing serial data to the ATmega328P, data is clocked on the rising edge of SCK.
        When reading data from the ATmega328P, data is clocked on the falling edge of SCK. See Figure 5-126 for timing details.
        To program and verify the ATmega328P in the serial programming mode, the following sequence is recommended (See
        serial programming instruction set in Table 5-127 on page 276):
          1. Power-up sequence:
                Apply power between VCC and GND while RESET and SCK are set to “0”. In some systems, the programmer can
                not guarantee that SCK is held low during power-up. In this case, RESET must be given a positive pulse of at
                least two CPU clock cycles duration after SCK has been set to “0”.
          2.    Wait for at least 20ms and enable serial programming by sending the programming enable serial instruction to pin
                MOSI.
          3.    The serial programming instructions will not work if the communication is out of synchronization. When in sync.
                the second byte (0x53), will echo back when issuing the third byte of the programming enable instruction. Whether
                the echo is correct or not, all four bytes of the instruction must be transmitted. If the 0x53 did not echo back, give
                RESET a positive pulse and issue a new programming enable command.
          4.    The flash is programmed one page at a time. The memory page is loaded one byte at a time by supplying the 6
                LSB of the address and data together with the load program memory page instruction. To ensure correct loading
                of the page, the data low byte must be loaded before data high byte is applied for a given address. The program
                memory page is stored by loading the write program memory page instruction with the 7 MSB of the address. If
                polling (RDY/BSY) is not used, the user must wait at least tWD_FLASH before issuing the next page (See Table 5-
                126). Accessing the serial programming interface before the flash write operation completes can result in incorrect
                programming.
          5.    A: The EEPROM array is programmed one byte at a time by supplying the address and data together with the
                appropriate write instruction. An EEPROM memory location is first automatically erased before new data is writ-
                ten. If polling (RDY/BSY) is not used, the user must wait at least tWD_EEPROM before issuing the next byte (See
                Table 5-126). In a chip erased device, no 0xFFs in the data file(s) need to be programmed.
                B: The EEPROM array is programmed one page at a time. The memory page is loaded one byte at a time by sup-
                plying the 6 LSB of the address and data together with the Load EEPROM memory page instruction. The
                EEPROM memory page is stored by loading the Write EEPROM memory page Instruction with the 7 MSB of the
                address. When using EEPROM page access only byte locations loaded with the load EEPROM memory page
                instruction is altered. The remaining locations remain unchanged. If polling (RDY/BSY) is not used, the used must
                wait at least tWD_EEPROM before issuing the next byte (See Table 5-126). In a chip erased device, no 0xFF in the
                data file(s) need to be programmed.
          6.    Any memory location can be verified by using the read instruction which returns the content at the selected
                address at serial output MISO.
          7.    At the end of the programming session, RESET can be set high to commence normal operation.
          8.    Power-off sequence (if needed):
                Set RESET to “1”.
                Turn VCC power off.
        Table 5-126. Typical Wait Delay Before Writing the Next Flash or EEPROM Location
                                       Symbol                                                   Minimum Wait Delay
                                      tWD_FLASH                                                          4.5ms
                                     tWD_EEPROM                                                          3.6ms
                                      tWD_ERASE                                                          9.0ms
                                                                                                  ATA6614Q [DATASHEET]                 275
                                                                                                                 9240I–AUTO–03/16


5.27.8.3 Serial Programming Instruction set
         Table 5-127 on page 276 and Figure 5-125 on page 277 describes the Instruction set.
Table 5-127. Serial Programming Instruction Set (Hexadecimal Values)
                                                                                   Instruction Format
 Instruction/Operation                                  Byte 1                 Byte 2                Byte 3                 Byte4
 Programming enable                                      $AC                    $53                   $00                     $00
 Chip erase (program memory/EEPROM)                      $AC                    $80                   $00                     $00
 Poll RDY/BSY                                            $F0                    $00                   $00                data byte out
 Load Instructions
 Load extended address byte(1)                           $4D                    $00              Extended adr                 $00
 Load program memory page, high byte                     $48                    $00                 adr LSB            high data byte in
 Load program memory page, low byte                      $40                    $00                 adr LSB            low data byte in
 Load EEPROM memory page (page access)                   $C1                    $00               0000 000aa              data byte in
 Read Instructions
 Read program memory, high byte                          $28                  adr MSB               adr LSB           high data byte out
 Read program memory, low byte                           $20                  adr MSB               adr LSB           low data byte out
 Read EEPROM memory                                      $A0                 0000 00aa             aaaa aaaa             data byte out
 Read lock bits                                          $58                    $00                   $00                data byte out
 Read signature byte                                     $30                    $00               0000 000aa             data byte out
 Read fuse bits                                          $50                    $00                   $00                data byte out
 Read fuse high bits                                     $58                    $08                   $00                data byte out
 Read extended fuse bits                                 $50                    $08                   $00                data byte out
 Read calibration byte                                   $38                    $00                   $00                data byte out
 Write Instructions(6)
 Write program memory page                               $4C                  adr MSB               adr LSB                   $00
 Write EEPROM memory                                     $C0                 0000 00aa             aaaa aaaa              data byte in
 Write EEPROM memory page (page access)                  $C2                 0000 00aa             aaaa aa00                  $00
 Write lock bits                                         $AC                    $E0                   $00                 data byte in
 Write fuse bits                                         $AC                    $A0                   $00                 data byte in
 Write fuse high bits                                    $AC                    $A8                   $00                 data byte in
 Write extended fuse bits                                $AC                    $A4                   $00                 data byte in
 Notes: 1. Not all instructions are applicable for all parts.
           2. a = address.
           3. Bits are programmed ‘0’, unprogrammed ‘1’.
           4. To ensure future compatibility, unused fuses and lock bits should be unprogrammed (‘1’).
           5. Refer to the corresponding section for fuse and lock bits, calibration and signature bytes and page size.
           6. Instructions accessing program memory use a word address. This address may be random within the page range.
           7.   See http://www.atmel.com/avr for application notes regarding programming and programmers.
         If the LSB in RDY/BSY data byte out is ‘1’, a programming operation is still pending. Wait until this bit returns ‘0’ before the
         next instruction is carried out.
         Within the same page, the low data byte must be loaded prior to the high data byte.
         After data is loaded to the page buffer, program the EEPROM page, see Figure 5-125 on page 277.
276      ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


        Figure 5-125. Serial Programming Instruction Example
                                                             Serial Programming Instruction
                            Load Program Memory Page (High/Low Byte)/                        Write Program Memory Page /
                            Load EEPROM Memory Page (page access)                            Write EEPROM Memory Page
                        Byte 1         Byte 2     Byte 3        Byte 4             Byte 1         Byte 2      Byte 3       Byte 4
                                       Adr MBS    Adr LBS                                         Adr MBS     Adr LBS
                              Bit 15 B                     0                            Bit 15 B                       0
                                                                       Page Buffer
                                                      Page Offset
                                                                          Page 0
                                                                          Page 1
                                                                          Page 2
                                                                                      Page Number
                                                                         Page N-1
                                                                    Program Memory /
                                                                    EEPROM Memory
5.27.8.4 SPI Serial Programming Characteristics
        Figure 5-126. Serial Programming Waveforms
                          SERIAL DATA INPUT
                                         (MOSI)        MSB                                                           LSB
                        SERIAL DATA OUTPUT
                                         (MISO)        MSB                                                           LSB
                         SERIAL CLOCK INPUT
                                           (SCK)
                                        SAMPLE
        For characteristics of the SPI module see Section 5.28.6 “SPI Timing Characteristics” on page 281.
                                                                                                      ATA6614Q [DATASHEET]            277
                                                                                                                     9240I–AUTO–03/16


5.28      Electrical Characteristics
          All DC/AC characteristics contained in this datasheet are based on characterization of ATmega328P AVR® microcontroller
          manufactured in an automotive process technology.
5.28.1 DC Characteristics
Tcase = –40°C to 125°C, VCC = 2.7V to 5.5V (unless otherwise noted)
Parameter                        Condition                     Symbol         Min.            Typ.            Max.            Unit
Input low voltage, except
                                 VCC = 2.7V - 5.5V               VIL          –0.5                          0.3VCC(1)           V
XTAL1 and RESET pin
Input high voltage, except
                                 VCC = 2.7V - 5.5V               VIH       0.6VCC(2)                        VCC + 0.5           V
XTAL1 and RESET pins
Input low voltage,
                                 VCC = 2.7V - 5.5V               VIL1         –0.5                          0.1VCC(1)           V
XTAL1 pin
Input high voltage,
                                 VCC = 2.7V - 5.5V               VIH1      0.7VCC(2)                        VCC + 0.5           V
XTAL1 pin
Input low voltage,
                                 VCC = 2.7V - 5.5V               VIL2         –0.5                          0.1VCC(1)           V
RESET pin
Input high voltage,
                                 VCC = 2.7V - 5.5V               VIH2      0.9VCC(2)                        VCC + 0.5           V
RESET pin
                                 IOL = 20mA, VCC = 5V                                                          0.8
Output low voltage(3)                                            VOL                                                            V
                                 IOL = 5mA, VCC = 3V                                                           0.5
                                 IOH = –20mA, VCC = 5V                         4.1
Output high voltage(4)                                           VOH                                                            V
                                 IOH = –10mA, VCC = 3V                         2.3
                                 VCC = 5.5V, pin low
Input leakage current I/O pin                                     IIL                                           1              µA
                                 (absolute value)
                                 VCC = 5.5V, pin high
Input leakage current I/O pin                                     IIH                                           1              µA
                                 (absolute value)
Reset pull-up resistor                                          RRST           30                              60              k
I/O pin pull-up resistor                                         RPU           20                              50              k
Analog comparator input          0.4V < Vin < VCC – 0.5
                                                                VACIO                          10              40              mV
offset voltage                   (absolute value)
Analog comparator input          VCC = 5V
                                                                IACLK         –50                              50              nA
leakage current                  Vin = VCC/2
Notes: 1. “Max” means the highest value where the pin is guaranteed to be read as low
           2. “Min” means the lowest value where the pin is guaranteed to be read as high
           3. Although each I/O port can sink more than the test conditions (20mA at VCC = 5V, 10 mA at VCC = 3V) under steady state
               conditions (non-transient), the following must be observed:
               ATmega328P:
               1] The sum of all IOL, for ports C0 - C5, should not exceed 100mA.
               2] The sum of all IOL, for ports B0 - B5, D5 - D7, XTAL1, XTAL2 should not exceed 100mA.
               3] The sum of all IOL, for ports D0 - D4, should not exceed 100mA.
               If IOL exceeds the test condition, VOL may exceed the related specification. Pins are not guaranteed to sink current
               greater than the listed test condition.
           4.   Although each I/O port can source more than the test conditions (20mA at VCC = 5V, 10mA at VCC = 3V) under steady
                state conditions (non-transient), the following must be observed:
                ATmega328P:
                1] The sum of all IOH, for ports C0 - C5, D0- D4, should not exceed 150mA.
                2] The sum of all IOH, for ports B0 - B5, D5 - D7, XTAL1, XTAL2 should not exceed 150mA.
                If IIOH exceeds the test condition, VOH may exceed the related specification. Pins are not guaranteed to source current
                greater than the listed test condition.
278       ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


5.28.2 DC Characteristics
Tcase = –40°C to 125°C, VCC = 2.7V to 5.5V (unless otherwise noted)
Symbol       Parameter                  Condition                         Min.            Typ.(2)      Max.             Unit
                                        Active 4MHz, VCC = 3V                               1.5         2.4              mA
                                        Active 8MHz, VCC = 5V                               5.2          10              mA
                                        Active 16MHz, VCC = 5V                              9.2          14              mA
             Power Supply Current(1)
                                        Idle 4MHz, VCC = 3V                                0.25         0.6              mA
                                        Idle 8MHz, VCC = 5V                                 1.0         1.6              mA
ICC
                                        Idle 16MHz, VCC = 5V                                1.9         2.8              mA
                                        WDT enabled, VCC = 3V                                            44              µA
                                        WDT enabled, VCC = 5V                                            66              µA
             Power-down mode(3)
                                        WDT disabled, VCC = 3V                                           40              µA
                                        WDT disabled, VCC = 5V                                           60              µA
Notes:    1. Values with “Minimizing Power Consumption” enabled (0xFF).
          2. Typical values at 25°C.
          3.   The current consumption values include input leakage current.
5.28.3 Speed Grades
          Figure 5-127. Maximum Frequency
                                          16MHz
                                           8MHz                   Safe Operating Area
                                                     2.7V                    4.5V          5.5V
5.28.4 Clock Characteristics
5.28.4.1 Calibrated Internal RC Oscillator Accuracy
Table 5-128. Calibration Accuracy of Internal RC Oscillator
                                  Frequency                     VCC                   Temperature        Calibration Accuracy
          Factory                                                3V                       25°C                    ±2%
                                    8.0MHz
        Calibration                                          2.7V - 5.5V              –40°C - 125°C              ±14%
                                                                                              ATA6614Q [DATASHEET]           279
                                                                                                        9240I–AUTO–03/16


5.28.4.2 Watchdog Oscillator Accuracy
Table 5-129. Accuracy of Watchdog Oscillator
                Parameter                           Condition               Symbol           Min        Typ         Max       Unit
     Watchdog oscillator frequency               VCC = 2.7 - 5.5V            Fwdt            76         128         180       kHz
5.28.4.3 External Clock Drive Waveforms
          Figure 5-128. External Clock Drive Waveforms
                                                                                                tCHCX
                                                  tCHCX                        tCLCH                              tCHCL
                                            VIH1
                                       VIL1
                                                                         tCLCX
                                                                                       tCLCL
5.28.4.4 External Clock Drive
Table 5-130. External Clock Drive
                                                                   VCC = 2.7-5.5V                   VCC = 4.5-5.5V
 Parameter                                 Symbol              Min.              Max.            Min.            Max.         Unit
 Oscillator frequency                       1/tCLCL              0                 8               0              20          MHz
 High time                                   tCHCX              50                                25                           ns
 Low time                                    tCLCX              50                                25                           ns
 Rise time                                   tCLCH                                1.6                            0.5           ns
 Fall time                                   tCHCL                                1.6                            0.5           ns
 Change in period from one clock
                                            tCLCL                                 2                               2           %
 cycle to the next
                                                                                                                            ®
 Note:         All DC/AC characteristics contained in this datasheet are based on characterization of ATmega328P AVR microcon-
               troller manufactured in an automotive process technology.
5.28.5 System and Reset Characteristics
Table 5-131. Reset, Brown-out and Internal Voltage Characteristics
 Parameter                                                    Condition        Symbol         Min          Typ          Max     Unit
 Brown-out detector hysteresis                                                   VHYST                      80                  mV
 Bandgap reference voltage                                    VCC = 5V            VBG         1.0           1.1         1.2       V
280       ATA6614Q [DATASHEET]
          9240I–AUTO–03/16


Table 5-132. BODLEVEL Fuse Coding(1)
              BODLEVEL 2:0 Fuses                         Min VBOT               Typ VBOT               Max VBOT              Unit
                         111                                                           BOD Disabled
                         110                                                    Reserved
                         101                                 2.5                    2.7                  2.9                   V
                         100                                 4.0                    4.3                  4.6
                         011
                         010
                                                                                         Reserved
                         001
                         000
 Notes:    1. VBOT may be below nominal minimum operating voltage for some devices. For devices where this is the case, the
              device is tested down to VCC = VBOT during the production test. This guarantees that a brown-out reset will occur before
              VCC drops to a voltage where correct operation of the microcontroller is no longer guaranteed. The test is performed
              using BODLEVEL = 100 and BODLEVEL = 101 for ATmega328P.
5.28.6 SPI Timing Characteristics
          See Figure 5-129 and Figure 5-130 for details.
Table 5-133. SPI Timing Parameters
   No.              Description               Mode                Min                     Typ                    Max              Unit
    1               SCK period                Master                                 See Table 5-68
    2              SCK high/low               Master                                 50% duty cycle
    3              Rise/Fall time             Master                                       3.6
    4                  Setup                  Master                                       10
    5                   Hold                  Master                                       10
    6               Out to SCK                Master                                    0.5  tsck
    7                SCK to out               Master                                       10
    8             SCK to out high             Master                                       10
    9              SS low to out              Slave                                        15
                                                                                                                                   ns
   10               SCK period                Slave              4  tck
   11             SCK high/low(1)             Slave              2  tck
   12              Rise/Fall time             Slave                                                              1600
   13                  Setup                  Slave                10
   14                   Hold                  Slave                tck
   15                SCK to out               Slave                                        15
   16             SCK to SS high              Slave                20
   17           SS high to tri-state          Slave                                        10
   18             SS low to SCK               Slave                20
 Note:     1.  In SPI Programming mode the minimum SCK high/low period is:
               - 2 tCLCL for fCK < 12MHz
               - 3 tCLCL for fCK > 12MHz
 All AC/AC characteristics contained in this datasheet are based on characterization of ATmega328P AVR® microcontroller manufac-
 tured in an automotive process technology.
                                                                                                 ATA6614Q [DATASHEET]              281
                                                                                                             9240I–AUTO–03/16


    Figure 5-129. SPI Interface Timing Requirements (Master Mode)
                              SS
                                    6                                  1
                            SCK
                      (CPOL = 0)
                                                                  2           2
                            SCK
                      (CPOL = 1)
                                    4    5                                          3
                           MISO
                     (Data Input)     MSB                ...         LSB
                                                 7                                     8
                           MOSI
                                          MSB            ...              LSB
                  (Data Output)
    Figure 5-130. SPI Interface Timing Requirements (Slave Mode)
                             SS
                                  9                                    10             16
                           SCK
                    (CPOL = 0)
                                                                  11          11
                           SCK
                    (CPOL = 1)
                                    13      14                                   12
                          MOSI
                   (Data Input)         MSB                  ...          LSB
                                                    15                                    17
                          MISO
                                          MSB                ...           LSB           X
                 (Data Output)
282 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.28.7 2-wire Serial Interface Characteristics
         Table 5-134 describes the requirements for devices connected to the 2-wire serial bus. The ATmega328P 2-wire serial
         interface meets or exceeds these requirements under the noted conditions.
         Timing symbols refer to Figure 5-131.
Table 5-134. 2-wire Serial Bus Requirements
Parameter                                                    Condition              Symbol             Min                            Max            Unit
Input low-voltage                                                                 VIL                  -0.5                        0.3 VCC            V
Input high-voltage                                                                VIH             0.7 VCC                         VCC + 0.5           V
Hysteresis of Schmitt trigger inputs                                              Vhys(1)      0.05         VCC(2)                        –           V
Output low-voltage                                       3 mA sink current        VOL(1)                   0                            0.4           V
Rise time for both SDA and SCL                                                    tr(1)      20 + 0.1Cb               (2)(3)
                                                                                                                                       300            ns
                                                                          (3)
Output fall time from VIHmin to VILmax                 10pF < Cb < 400pF          tof(1)     20 + 0.1Cb               (2)(3)
                                                                                                                                       250            ns
                                                                                                                                             (2)
Spikes suppressed by input filter                                                 tSP(1)                   0                          50              ns
Input current each I/O pin                             0.1VCC < Vi < 0.9VCC       Ii                    -10                              10          µA
Capacitance for each I/O pin                                                      Ci(1)                    –                             10           pF
                                                                              (5)
SCL clock frequency                              fCK(4) > max(16fSCL, 250kHz)     fSCL                     0                           400           kHz
                                                                                              V CC – 0,4V                          1000ns
                                                           fSCL ≤ 100kHz                      ----------------------------         -----------------  
                                                                                                      3mA                               Cb
Value of pull-up resistor                                                         Rp
                                                                                              V CC – 0,4V                           300ns
                                                           fSCL > 100kHz                      ----------------------------          --------------    
                                                                                                      3mA                               Cb
                                                           fSCL ≤ 100kHz                                4.0                               –           µs
Hold time (repeated) START condition                                              tHD;STA
                                                           fSCL > 100kHz                                0.6                               –           µs
                                                           fSCL ≤ 100kHz                                4.7                               –           µs
Low period of the SCL clock                                                       tLOW
                                                           fSCL > 100kHz                                1.3                               –           µs
                                                           fSCL ≤ 100kHz                                4.0                               –           µs
High period of the SCL clock                                                      tHIGH
                                                           fSCL > 100kHz                                0.6                               –           µs
                                                           fSCL ≤ 100kHz                                4.7                               –           µs
Set-up time for a repeated START condition                                        tSU;STA
                                                           fSCL > 100kHz                                0.6                               –           µs
                                                           fSCL ≤ 100kHz                                   0                          3.45            µs
Data hold time                                                                    tHD;DAT
                                                           fSCL > 100kHz                                   0                            0.9           µs
                                                           fSCL ≤ 100kHz                               250                                –           ns
Data setup time                                                                   tSU;DAT
                                                           fSCL > 100kHz                               100                                –           ns
                                                           fSCL ≤ 100kHz                                4.0                               –           µs
Setup time for STOP condition                                                     tSU;STO
                                                           fSCL > 100kHz                                0.6                               –           µs
Bus free time between a STOP and START                     fSCL ≤ 100kHz                                4.7                               –           µs
                                                                                  tBUF
condition                                                  fSCL > 100kHz                                1.3                               –           µs
Notes:    1. In ATmega328P, this parameter is characterized and not 100% tested.
          2. Required only for fSCL > 10 kHz.
          3. Cb = capacitance of one bus line in pF.
          4.   fCK = CPU clock frequency
          5.   This requirement applies to all ATmega328P 2-wire serial interface operation. Other devices connected to the 2-wire
               serial bus need only obey the general fSCL requirement.
                                                                                              ATA6614Q [DATASHEET]                                     283
                                                                                                                             9240I–AUTO–03/16


         Figure 5-131. 2-wire Serial Bus Timing
                                            tof            tHIGH                              tr
                                                 tLOW                      tLOW
                  SCL
                          tSU,STA   tHD,STA                  tHD,DAT              tSU,DAT        tHD,STA
                  SDA
                                                                                                            tBUF
5.28.8 ADC Characteristics
Table 5-135. ADC Characteristics
Parameter                                    Condition            Symbol          Min     Typ         Max        Unit
                                  –40°C +125°C / 2.70 - 5.50V
Resolution                                                                                 10                    bits
                                  ADC clock = 200kHz
Absolute accuracy                 VCC = 4.0V, VRef = 4.0V            TUE                  2.2          3.5       LSB
Integral non linearity            VCC = 4.0V, VRef = 4.0V             INL                 0.6          1.5       LSB
Differential non linearity        VCC = 4.0V, VRef = 4.0V            DNL                  0.3          0.7       LSB
Gain error                        VCC = 4.0V, VRef = 4.0V                         –3.5                 3.5       LSB
Offset error                      VCC = 4.0V, VRef = 4.0V                         –3.5                 3.5       LSB
Clock frequency                                                                    50                  200       kHz
Analog supply voltage                                                AVCC       VCC – 0.3          VCC +0.3        V
Reference voltage                                                    VRef          1.0                AVCC         V
Input voltage                                                          Vin        GND                  VRef        V
Internal voltage reference        VCC = 5v                            Vint         1.0    1.1          1.2         V
Reference input resistance                                            Rref        22.4     32         41.6        k
Analog input resistance                                               Rain                100                    M
284      ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


5.28.9 Parallel Programming Characteristics
Table 5-136. Parallel Programming Characteristics, VCC = 5V ±10%
Parameter                                                    Symbol            Min             Typ        Max            Unit
Programming enable voltage                                      VPP            11.5                       12.5            V
Programming enable current                                       IPP                                       250           µA
Data and control valid before XTAL1 high                      tDVXH             67                                        ns
XTAL1 low to XTAL1 high                                        tXLXH           200                                        ns
XTAL1 pulse width high                                         tXHXL           150                                        ns
Data and control hold after XTAL1 low                          tXLDX            67                                        ns
XTAL1 low to WR low                                            tXLWL             0                                        ns
XTAL1 low to PAGEL high                                        tXLPH             0                                        ns
PAGEL low to XTAL1 high                                        tPLXH           150                                        ns
BS1 valid before PAGEL high                                    tBVPH            67                                        ns
PAGEL pulse width high                                         tPHPL           150                                        ns
BS1 hold after PAGEL low                                       tPLBX            67                                        ns
BS2/1 hold after WR Low                                       tWLBX             67                                        ns
PAGEL low to WR low                                            tPLWL            67                                        ns
BS1 valid to WR low                                           tBVWL             67                                        ns
WR pulse width low                                            tWLWH            150                                        ns
WR low to RDY/BSY low                                         tWLRL              0                          1             µs
WR low to RDY/BSY high(1)                                     tWLRH             3.7                        4.5           ms
                                         (2)
WR low to RDY/BSY high for chip erase                       tWLRH_CE            7.5                         9            ms
XTAL1 low to OE low                                            tXLOL             0                                        ns
BS1 valid to DATA valid                                        tBVDV             0                         250            ns
OE low to DATA valid                                           tOLDV                                       250            ns
OE high to DATA tri-stated                                    tOHDZ                                        250            ns
Notes: 1. tWLRH is valid for the write flash, write EEPROM, write fuse bits and write lock bits commands.
         2.   tWLRH_CE is valid for the chip erase command.
                                                                                            ATA6614Q [DATASHEET]              285
                                                                                                        9240I–AUTO–03/16


    Figure 5-132. Parallel Programming Timing, Including some General Timing Requirements
                                                                             tXLWL
                                  XTAL1                      tXHXL
                                                  tDVXH                tXLDX
                        Data and Control
                (DATA, XA0/1, BS1, BS2)
                                                  tBVPH                tPLBX       tBVWL                    tWLBX
                                 PAGEL                       tPHPL
                                                                                             tWLWH
                                     WR
                                                                             tPLWL
                                                                                               tWLRL
                               RDY/BSY
                                                                                                          tWLRH
    Figure 5-133. Parallel Programming Timing, Loading Sequence with Timing Requirements(1)
                           Load Address                Load Data                       Load Data                            Load Address
                            (Low Byte)                 (Low Byte)                     (High Byte)    Load Data               (Low Byte)
                                                                         tXLXH                        tXLPH        tPLXH
      XTAL1
        BS1
      PAGEL
       DATA              ADDR0 (Low Byte)            DATA (Low Byte)                      DATA (High Byte)                ADDR1 (Low Byte)
        XA0
        XA1
    Note:    1.   The timing requirements shown in Figure 5-132 (i.e., tDVXH, tXHXL, and tXLDX) also apply to loading operation.
    Figure 5-134. Parallel Programming Timing, Reading Sequence (within the Same Page) with Timing
                  Requirements(1)
                          Load Address                        Read Data                          Read Data               Load Address
                           (Low Byte)                         (Low Byte)                        (High Byte)                (Low Byte)
                                          tXLOL
       XTAL1
                                                                               tBVDV
         BS1
                                            tOLDV
          OE
                                                                                                             tOHDZ
        DATA            ADDR0 (Low Byte)                   DATA (Low Byte)                   DATA (High Byte)             ADDR1 (Low Byte)
         XA0
         XA1
    Note:    1.   The timing requirements shown in Figure 5-132 (i.e., tDVXH, tXHXL, and tXLDX) also apply to reading operation.
286 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


5.29   Typical Characteristics
       The data contained in this section are characterized values of actual automotive silicon. Unless otherwise specified, the data
       contained in this chapter are for –40° to 125°C.
       The following charts show typical behavior. These figures are not tested during manufacturing. All current consumption
       measurements are performed with all I/O pins configured as inputs and with internal pull-ups enabled. A square wave
       generator with rail-to-rail output is used as clock source.
       All active- and idle current consumption measurements are done with all bits in the PRR register set and thus, the
       corresponding I/O modules are turned off. Also the analog comparator is disabled during these measurements. The “Supply
       Current of IO Modules” shows the additional current consumption compared to ICC active and ICC idle for every I/O module
       controlled by the power reduction register. See Section 5.9.9 “Power Reduction Register” on page 60 for details.
       The power consumption in power-down mode is independent of clock selection.
       The current consumption is a function of several factors such as: operating voltage, operating frequency, loading of I/O pins,
       switching rate of I/O pins, code executed and ambient temperature. The dominating factors are operating voltage and
       frequency.
       The current drawn from capacitive loaded pins may be estimated (for one pin) as CL*VCC*f where CL = load capacitance,
       VCC = operating voltage and f = average switching frequency of I/O pin.
       The parts are characterized at frequencies higher than test limits. Parts are not guaranteed to function properly at
       frequencies higher than the ordering code indicates.
       The difference between current consumption in power-down mode with watchdog timer enabled and power-down mode with
       watchdog timer disabled represents the differential current drawn by the watchdog timer.
5.29.1 ATmega328P Typical Characteristics
5.29.1.1 Active Supply Current
       Figure 5-135. Active Supply Current versus Frequency
                                  16
                                  14
                                  12
                                  10
                       ICC (mA)
                                                                                                                  5.5
                                   8
                                                                                                                  5.0
                                   6                                                                              4.5
                                                                                                                  3.6
                                   4
                                                                                                                  3.3
                                   2                                                                              3.0
                                                                                                                  2.7
                                   0
                                       0   2   4   6     8      10     12      14     16     18     20
                                                         Frequency (MHz)
                                                                                             ATA6614Q [DATASHEET]                287
                                                                                                           9240I–AUTO–03/16


      Figure 5-136. Idle Supply Current versus Frequency
                                     4
                                    3.5
                                     3
                                    2.5
                         ICC (mA)
                                                                                                                           5.5
                                     2                                                                                     5.0
                                    1.5                                                                                    4.5
                                                                                                                           3.6
                                     1
                                                                                                                           3.3
                                    0.5                                                                                    3.0
                                                                                                                           2.7
                                     0
                                          0   2         4       6   8           10          12   14    16       18   20
                                                                    Frequency (MHz)
5.29.1.2 Power-down Supply Current
      Figure 5-137. Power-down Supply Current versus VCC (Watchdog Timer Disabled)
                                    25
                                    20
                                    15
                         ICC (µA)                                                                                          125
                                    10                                                                                      85
                                                                                                                            25
                                     5                                                                                     -45
                                     0
                                          2       2.5       3           3.5             4        4.5        5        5.5
                                                                              VCC (V)
      Figure 5-138. Power-down Supply Current versus VCC (Watchdog Timer Enabled)
                                    35
                                    30
                                    25
                                                                                                                           125
                         ICC (µA)
                                    20
                                                                                                                            85
                                    15                                                                                      25
                                                                                                                           -45
                                    10
                                     5
                                     0
                                          2       2.5       3           3.5             4        4.5        5        5.5
                                                                              VCC (V)
288   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.29.1.3 Pin Pull-Up
       Figure 5-139. I/O Pin Pull-up Resistor Current versus Input Voltage (VCC = 5V)
                                   160
                                   140
                                   120
                                                                                                               125
                                   100
                     IOP (µA)
                                                                                                                85
                                    80                                                                          25
                                                                                                                -45
                                    60
                                    40
                                    20
                                     0
                                         0   0.5   1   1.5   2      2.5       3    3.5   4    4.5   5
                                                                  VOP (V)
       Figure 5-140. Reset Pull-up Resistor Current versus Reset Pin Voltage (VCC = 5V)
                                   120
                                   100
                                    80                                                                         125
                     IRESET (µA)
                                                                                                                85
                                    60                                                                          25
                                                                                                                -45
                                    40
                                    20
                                    40
                                         0   0.5   1   1.5   2      2.5       3    3.5   4    4.5   5
                                                                 VRESET (V)
5.29.1.4 Pin Driver Strength
       Figure 5-141. I/O Pin Output Voltage versus Sink Current (VCC = 3V)
                                   1.2
                                     1
                                   0.8                                                                         125
                     VOL (V)
                                                                                                                85
                                   0.6                                                                          25
                                                                                                                -45
                                   0.4
                                   0.2
                                     0
                                         0   2     4   6     8      10        12   14    16   18    20
                                                                 IOL (mA)
                                                                                              ATA6614Q [DATASHEET]          289
                                                                                                         9240I–AUTO–03/16


      Figure 5-142. I/O Pin Output Voltage versus Sink Current (VCC = 5V)
                                   0.7
                                   0.6
                                   0.5
                                                                                                 125
                     VOL (V)
                                   0.4                                                            85
                                                                                                  25
                                   0.3
                                                                                                 -45
                                   0.2
                                   0.1
                                     0
                                         0   2   4   6   8      10      12   14   16   18   20
                                                             IOL (mA)
      Figure 5-143. I/O Pin Output Voltage versus Source Current (VCC = 3V)
                                   3.5
                                    3
                                   2.5
                                                                                                 125
                         VOH (V)
                                    2                                                             85
                                                                                                  25
                                   1.5
                                                                                                 -45
                                    1
                                   0.5
                                    0
                                         0   2   4   6   8     10       12   14   16   18   20
                                                             IOH (mA)
      Figure 5-144. I/O Pin Output Voltage versus Source Current (VCC = 5V)
                                   5.1
                                   5.0
                                   4.9
                                   4.8                                                           125
                         VOH (V)
                                   4.7                                                            85
                                                                                                  25
                                   4.6
                                                                                                 -45
                                   4.5
                                   4.4
                                   4.3
                                   4.2
                                         0   2   4   6   8     10       12   14   16   18   20
                                                             IOH (mA)
290   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.29.1.5 Pin Threshold and Hysteresis
       Figure 5-145. I/O Pin Input Threshold Voltage versus VCC (VIH, I/O Pin read as ‘1’)
                                      3.5
                                       3
                                      2.5
                      Threshold (V)
                                                                                                          125
                                       2                                                                   85
                                                                                                           25
                                      1.5
                                                                                                           -45
                                       1
                                      0.5
                                       0
                                            2   2.5   3   3.5             4   4.5    5        5.5
                                                                VCC (V)
       Figure 5-146. I/O Pin Input Threshold Voltage versus VCC (VIL, I/O Pin read as ‘0’)
                                      2.5
                                       2
                      Threshold (V)
                                                                                                          125
                                      1.5
                                                                                                           85
                                                                                                           25
                                       1                                                                   -45
                                      0.5
                                       0
                                            2   2.5   3   3.5             4   4.5     5        5.5
                                                                VCC (V)
       Figure 5-147. Reset Input Threshold Voltage versus VCC (VIH, I/O Pin read as ‘1’)
                                                                                          ATA6614Q [DATASHEET]          291
                                                                                                     9240I–AUTO–03/16


      Figure 5-148. Reset Input Threshold Voltage versus VCC (VIL, I/O Pin read as ‘0’)
                                            2.5
                                                 2
                           Threshold (V)
                                                                                                                                               125
                                            1.5
                                                                                                                                                85
                                                                                                                                                25
                                                 1                                                                                             -45
                                            0.5
                                                 0
                                                     2       2.5           3          3.5              4          4.5          5         5.5
                                                                                            VCC (V)
5.29.1.6 BOD Threshold
      Figure 5-149. BOD Thresholds versus Temperature (BODLEVEL is 2.7V)
                                           3.0
                                           2.9
                     Threshold (V)
                                           2.8
                                                                                                                                                 1
                                           2.7                                                                                                   0
                                           2.6
                                           2.5
                                           2.4
                                                 -60 -50 -40 -30 -20 -10   0   10   20 30    40   50   60   70   80   90 100 110 120 130 140
                                                                                    Temperature (°C)
      Figure 5-150. BOD Thresholds versus Temperature (BODLEVEL is 4.3V)
                                           4.6
                                           4.5
                     Threshold (V)
                                           4.4
                                                                                                                                                 1
                                           4.3                                                                                                   0
                                           4.2
                                           4.1
                                            4
                                                 -60 -50 -40 -30 -20 -10   0   10   20 30    40   50   60   70   80   90 100 110 120 130 140
                                                                                    Temperature (°C)
292   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


5.29.1.7 Internal Oscillator Speed
       Figure 5-151. Watchdog Oscillator Frequency versus Temperature
                                    160
                                    150
                                    140
                                    130
                    FRC (kHz)       120                                                                                                       5.5
                                                                                                                                              5.0
                                    110                                                                                                       4.5
                                    100                                                                                                       3.3
                                                                                                                                              3.0
                                     90
                                                                                                                                              2.7
                                     80
                                          -40 -30 -20 -10    0    10   20     30   40   50     60   70   80    90    100 110 120
                                                                            Temperature (°C)
       Figure 5-152. Calibrated 8MHz RC Oscillator Frequency versus Temperature
                                    8.4
                                    8.3
                                    8.2
                                                                                                                                              5.5
                                    8.1
                     FRC (MHz)
                                                                                                                                              5.0
                                    8.0                                                                                                       4.5
                                                                                                                                              3.3
                                    7.9
                                                                                                                                              3.0
                                    7.8                                                                                                       2.7
                                    7.7
                                    7.6
                                          -45 -35 -25 -15    -5   5    15     25   35   45     55   65   75   85    95   105 115 125
                                                                            Temperature (°C)
       Figure 5-153. Calibrated 8MHz RC Oscillator Frequency versus OSCCAL Value
                                    16
                                    14
                                    12                                                                                                      125
                                                                                                                                             85
                        FRC (MHz)
                                    10
                                                                                                                                             25
                                     8
                                                                                                                                             -45
                                     6
                                     4
                                     2
                                     0
                                          0             50              100                  150              200             250
                                                                            OSCCAL (X1)
                                                                                                                         ATA6614Q [DATASHEET]             293
                                                                                                                                       9240I–AUTO–03/16


5.30    Register Summary
  Address       Name        Bit 7       Bit 6       Bit 5       Bit 4       Bit 3       Bit 2      Bit 1       Bit 0         Page
   (0xFF)     Reserved        –           –          –           –            –          –           –          –
   (0xFE)     Reserved        –           –          –           –            –          –           –          –
   (0xFD)     Reserved        –           –          –           –            –          –           –          –
   (0xFC)     Reserved        –           –          –           –            –          –           –          –
   (0xFB)     Reserved        –           –          –           –            –          –           –          –
   (0xFA)     Reserved        –           –          –           –            –          –           –          –
   (0xF9)     Reserved        –           –          –           –            –          –           –          –
   (0xF8)     Reserved        –           –          –           –            –          –           –          –
   (0xF7)     Reserved        –           –          –           –            –          –           –          –
   (0xF6)     Reserved        –           –          –           –            –          –           –          –
   (0xF5)     Reserved        –           –          –           –            –          –           –          –
   (0xF4)     Reserved        –           –          –           –            –          –           –          –
   (0xF3)     Reserved        –           –          –           –            –          –           –          –
   (0xF2)     Reserved        –           –          –           –            –          –           –          –
   (0xF1)     Reserved        –           –          –           –            –          –           –          –
   (0xF0)     Reserved        –           –          –           –            –          –           –          –
   (0xEF)     Reserved        –           –          –           –            –          –           –          –
   (0xEE)     Reserved        –           –          –           –            –          –           –          –
   (0xED)     Reserved        –           –          –           –            –          –           –          –
   (0xEC)     Reserved        –           –          –           –            –          –           –          –
   (0xEB)     Reserved        –           –          –           –            –          –           –          –
   (0xEA)     Reserved        –           –          –           –            –          –           –          –
   (0xE9)     Reserved        –           –          –           –            –          –           –          –
   (0xE8)     Reserved        –           –          –           –            –          –           –          –
   (0xE7)     Reserved        –           –          –           –            –          –           –          –
   (0xE6)     Reserved        –           –          –           –            –          –           –          –
   (0xE5)     Reserved        –           –          –           –            –          –           –          –
   (0xE4)     Reserved        –           –          –           –            –          –           –          –
   (0xE3)     Reserved        –           –          –           –            –          –           –          –
   (0xE2)     Reserved        –           –          –           –            –          –           –          –
   (0xE1)     Reserved        –           –          –           –            –          –           –          –
   (0xE0)     Reserved        –           –          –           –            –          –           –          –
   (0xDF)     Reserved        –           –          –           –            –          –           –          –
   (0xDE)     Reserved        –           –          –           –            –          –           –          –
   (0xDD)     Reserved        –           –          –           –            –          –           –          –
   (0xDC)     Reserved        –           –          –           –            –          –           –          –
   (0xDB)     Reserved        –           –          –           –            –          –           –          –
Notes:   1. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory
            addresses should never be written.
         2. I/O registers within the address range 0x00 - 0x1F are directly bit-accessible using the SBI and CBI instructions. In these
            registers, the value of single bits can be checked by using the SBIS and SBIC instructions.
         3. Some of the status flags are cleared by writing a logical one to them. Note that, unlike most other AVR®s, the CBI and
            SBI instructions will only operate on the specified bit, and can therefore be used on registers containing such status
            flags. The CBI and SBI instructions work with registers 0x00 to 0x1F only.
         4. When using the I/O specific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O
            registers as data space using LD and ST instructions, 0x20 must be added to these addresses. The ATmega328P is a
            complex microcontroller with more peripheral units than can be supported within the 64 location reserved in Opcode for
            the IN and OUT instructions. For the extended I/O space from 0x60 - 0xFF in SRAM, only the ST/STS/STD and
            LD/LDS/LDD instructions can be used.
294     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.30    Register Summary (Continued)
  Address       Name        Bit 7        Bit 6       Bit 5          Bit 4          Bit 3         Bit 2     Bit 1          Bit 0         Page
   (0xDA)     Reserved        –           –           –               –             –              –         –             –
   (0xD9)     Reserved        –           –           –               –             –              –         –             –
   (0xD8)     Reserved        –           –           –               –             –              –         –             –
   (0xD7)     Reserved        –           –           –               –             –              –         –             –
   (0xD6)     Reserved        –           –           –               –             –              –         –             –
   (0xD5)     Reserved        –           –           –               –             –              –         –             –
   (0xD4)     Reserved        –           –           –               –             –              –         –             –
   (0xD3)     Reserved        –           –           –               –             –              –         –             –
   (0xD2)     Reserved        –           –           –               –             –              –         –             –
   (0xD1)     Reserved        –           –           –               –             –              –         –             –
   (0xD0)     Reserved        –           –           –               –             –              –         –             –
   (0xCF)     Reserved        –           –           –               –             –              –         –             –
   (0xCE)     Reserved        –           –           –               –             –              –         –             –
   (0xCD)     Reserved        –           –           –               –             –              –         –             –
   (0xCC)     Reserved        –           –           –               –             –              –         –             –
   (0xCB)     Reserved        –           –           –               –             –              –         –             –
   (0xCA)     Reserved        –           –           –               –             –              –         –             –
   (0xC9)     Reserved        –           –           –               –             –              –         –             –
   (0xC8)     Reserved        –           –           –               –             –              –         –             –
   (0xC7)     Reserved        –           –           –               –             –              –         –             –
   (0xC6)       UDR0                                             USART I/O data register                                                 180
   (0xC5)      UBRR0H         –           –           –               –                    USART baud rate register high                 184
   (0xC4)      UBRR0L                                         USART baud rate register low                                               184
   (0xC3)     Reserved        –           –           –               –             –              –         –             –
                                                                                               UCSZ01   UCSZ00 /
   (0xC2)      UCSR0C     UMSEL01 UMSEL00          UPM01          UPM00          USBS0                                  UCPOL0        183/193
                                                                                              /UDORD0    UCPHA0
   (0xC1)      UCSR0B      RXCIE0      TXCIE0     UDRIE0          RXEN0          TXEN0         UCSZ02     RXB80          TXB80           182
   (0xC0)      UCSR0A       RXC0        TXC0       UDRE0            FE0           DOR0          UPE0      U2X0          MPCM0            181
   (0xBF)     Reserved        –           –           –               –             –              –         –             –
   (0xBE)     Reserved        –           –           –               –             –              –         –             –
   (0xBD)      TWAMR       TWAM6       TWAM5       TWAM4          TWAM3          TWAM2         TWAM1     TWAM0             –             222
   (0xBC)       TWCR       TWINT        TWEA       TWSTA          TWSTO          TWWC           TWEN         –           TWIE            219
   (0xBB)       TWDR                                        2-wire serial interface data register                                        221
   (0xBA)       TWAR        TWA6        TWA5        TWA4           TWA3           TWA2          TWA1      TWA0          TWGCE            222
   (0xB9)       TWSR        TWS7        TWS6        TWS5           TWS4           TWS3             –     TWPS1          TWPS0            221
   (0xB8)       TWBR                                       2-wire serial interface bit rate register                                     219
   (0xB7)     Reserved        –                       –               –             –              –         –             –
   (0xB6)       ASSR          –        EXCLK         AS2         TCN2UB         OCR2AUB OCR2BUB TCR2AUB                TCR2BUB           155
Notes:   1. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory
            addresses should never be written.
         2. I/O registers within the address range 0x00 - 0x1F are directly bit-accessible using the SBI and CBI instructions. In these
            registers, the value of single bits can be checked by using the SBIS and SBIC instructions.
         3. Some of the status flags are cleared by writing a logical one to them. Note that, unlike most other AVR®s, the CBI and
            SBI instructions will only operate on the specified bit, and can therefore be used on registers containing such status
            flags. The CBI and SBI instructions work with registers 0x00 to 0x1F only.
         4. When using the I/O specific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O
            registers as data space using LD and ST instructions, 0x20 must be added to these addresses. The ATmega328P is a
            complex microcontroller with more peripheral units than can be supported within the 64 location reserved in Opcode for
            the IN and OUT instructions. For the extended I/O space from 0x60 - 0xFF in SRAM, only the ST/STS/STD and
            LD/LDS/LDD instructions can be used.
                                                                                                       ATA6614Q [DATASHEET]                  295
                                                                                                                        9240I–AUTO–03/16


5.30    Register Summary (Continued)
  Address       Name        Bit 7       Bit 6       Bit 5       Bit 4        Bit 3       Bit 2     Bit 1       Bit 0         Page
   (0xB5)     Reserved        –           –          –            –           –            –         –          –
   (0xB4)      OCR2B                                  Timer/Counter2 output compare register B                                154
   (0xB3)      OCR2A                                  Timer/Counter2 output compare register A                                154
   (0xB2)       TCNT2                                          Timer/Counter2 (8-bit)                                         154
   (0xB1)      TCCR2B      FOC2A       FOC2B         –            –         WGM22       CS22       CS21       CS20            153
   (0xB0)      TCCR2A     COM2A1      COM2A0      COM2B1      COM2B0          –            –      WGM21      WGM20            150
   (0xAF)     Reserved        –           –          –            –           –            –         –          –
   (0xAE)     Reserved        –           –          –            –           –            –         –          –
   (0xAD)     Reserved        –           –          –            –           –            –         –          –
   (0xAC)     Reserved        –           –          –            –           –            –         –          –
   (0xAB)     Reserved        –           –          –            –           –            –         –          –
   (0xAA)     Reserved        –           –          –            –           –            –         –          –
   (0xA9)     Reserved        –           –          –            –           –            –         –          –
   (0xA8)     Reserved        –           –          –            –           –            –         –          –
   (0xA7)     Reserved        –           –          –            –           –            –         –          –
   (0xA6)     Reserved        –           –          –            –           –            –         –          –
   (0xA5)     Reserved        –           –          –            –           –            –         –          –
   (0xA4)     Reserved        –           –          –            –           –            –         –          –
   (0xA3)     Reserved        –           –          –            –           –            –         –          –
   (0xA2)     Reserved        –           –          –            –           –            –         –          –
   (0xA1)     Reserved        –           –          –            –           –            –         –          –
   (0xA0)     Reserved        –           –          –            –           –            –         –          –
   (0x9F)     Reserved        –           –          –            –           –            –         –          –
   (0x9E)     Reserved        –           –          –            –           –            –         –          –
   (0x9D)     Reserved        –           –          –            –           –            –         –          –
   (0x9C)     Reserved        –           –          –            –           –            –         –          –
   (0x9B)     Reserved        –           –          –            –           –            –         –          –
   (0x9A)     Reserved        –           –          –            –           –            –         –          –
   (0x99)     Reserved        –           –          –            –           –            –         –          –
   (0x98)     Reserved        –           –          –            –           –            –         –          –
   (0x97)     Reserved        –           –          –            –           –            –         –          –
   (0x96)     Reserved        –           –          –            –           –            –         –          –
   (0x95)     Reserved        –           –          –            –           –            –         –          –
   (0x94)     Reserved        –           –          –            –           –            –         –          –
   (0x93)     Reserved        –           –          –            –           –            –         –          –
   (0x92)     Reserved        –           –          –            –           –            –         –          –
   (0x91)     Reserved        –           –          –            –           –            –         –          –
   (0x90)     Reserved        –           –          –            –           –            –         –          –
Notes:   1. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory
            addresses should never be written.
         2. I/O registers within the address range 0x00 - 0x1F are directly bit-accessible using the SBI and CBI instructions. In these
            registers, the value of single bits can be checked by using the SBIS and SBIC instructions.
         3. Some of the status flags are cleared by writing a logical one to them. Note that, unlike most other AVR®s, the CBI and
            SBI instructions will only operate on the specified bit, and can therefore be used on registers containing such status
            flags. The CBI and SBI instructions work with registers 0x00 to 0x1F only.
         4. When using the I/O specific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O
            registers as data space using LD and ST instructions, 0x20 must be added to these addresses. The ATmega328P is a
            complex microcontroller with more peripheral units than can be supported within the 64 location reserved in Opcode for
            the IN and OUT instructions. For the extended I/O space from 0x60 - 0xFF in SRAM, only the ST/STS/STD and
            LD/LDS/LDD instructions can be used.
296     ATA6614Q [DATASHEET]
        9240I–AUTO–03/16


5.30    Register Summary (Continued)
  Address       Name        Bit 7        Bit 6       Bit 5       Bit 4         Bit 3         Bit 2      Bit 1    Bit 0         Page
   (0x8F)     Reserved        –           –           –            –             –            –          –        –
   (0x8E)     Reserved        –           –           –            –             –            –          –        –
   (0x8D)     Reserved        –           –           –            –             –            –          –        –
   (0x8C)     Reserved        –           –           –            –             –            –          –        –
   (0x8B)      OCR1BH                            Timer/Counter1 - Output compare register B high byte                           134
   (0x8A)      OCR1BL                            Timer/Counter1 - Output compare register B low byte                            134
   (0x89)      OCR1AH                            Timer/Counter1 - Output compare register A high byte                           134
   (0x88)      OCR1AL                            Timer/Counter1 - Output compare register A low byte                            134
   (0x87)       ICR1H                              Timer/Counter1 - Input capture register high byte                            135
   (0x86)       ICR1L                               Timer/Counter1 - Input capture register low byte                            135
   (0x85)      TCNT1H                                 Timer/Counter1 - Counter register high byte                               134
   (0x84)      TCNT1L                                 Timer/Counter1 - Counter register low byte                                134
   (0x83)     Reserved        –           –           –            –             –            –          –        –
   (0x82)      TCCR1C      FOC1A       FOC1B          –            –             –            –          –        –             134
   (0x81)      TCCR1B      ICNC1        ICES1         –        WGM13         WGM12          CS12        CS11     CS10           133
   (0x80)      TCCR1A     COM1A1      COM1A0      COM1B1      COM1B0             –            –       WGM11    WGM10            131
   (0x7F)       DIDR1         –           –           –            –             –            –        AIN1D    AIN0D           225
   (0x7E)       DIDR0         –           –        ADC5D       ADC4D          ADC3D        ADC2D       ADC1D    ADC0D           241
   (0x7D)     Reserved        –           –           –            –             –            –          –        –
   (0x7C)      ADMUX       REFS1       REFS0       ADLAR           –          MUX3          MUX2       MUX1     MUX0            237
   (0x7B)      ADCSRB         –         ACME          –            –             –         ADTS2       ADTS1    ADTS0           241
   (0x7A)      ADCSRA       ADEN        ADSC       ADATE         ADIF          ADIE        ADPS2       ADPS1    ADPS0           239
   (0x79)       ADCH                                         ADC data register high byte                                        240
   (0x78)        ADCL                                        ADC data register low byte                                         240
   (0x77)     Reserved        –           –           –            –             –            –          –        –
   (0x76)     Reserved        –           –           –            –             –            –          –        –
   (0x75)     Reserved        –           –           –            –             –            –          –        –
   (0x74)     Reserved        –           –           –            –             –            –          –        –
   (0x73)     Reserved        –           –           –            –             –            –          –        –
   (0x72)     Reserved        –           –           –            –             –            –          –        –
   (0x71)     Reserved        –           –           –            –             –            –          –        –
   (0x70)      TIMSK2         –           –           –            –             –        OCIE2B      OCIE2A    TOIE2           154
   (0x6F)      TIMSK1         –           –         ICIE1          –             –        OCIE1B      OCIE1A    TOIE1           135
   (0x6E)      TIMSK0         –           –           –            –             –        OCIE0B      OCIE0A    TOIE0           111
   (0x6D)      PCMSK2     PCINT23     PCINT22     PCINT21     PCINT20        PCINT19      PCINT18     PCINT17  PCINT16           81
   (0x6C)      PCMSK1         –       PCINT14     PCINT13     PCINT12        PCINT11      PCINT10     PCINT9   PCINT8            81
   (0x6B)      PCMSK0      PCINT7      PCINT6      PCINT5      PCINT4        PCINT3       PCINT2      PCINT1   PCINT0            81
   (0x6A)     Reserved        –           –           –            –             –            –          –        –
Notes:   1. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory
            addresses should never be written.
         2. I/O registers within the address range 0x00 - 0x1F are directly bit-accessible using the SBI and CBI instructions. In these
            registers, the value of single bits can be checked by using the SBIS and SBIC instructions.
         3. Some of the status flags are cleared by writing a logical one to them. Note that, unlike most other AVR®s, the CBI and
            SBI instructions will only operate on the specified bit, and can therefore be used on registers containing such status
            flags. The CBI and SBI instructions work with registers 0x00 to 0x1F only.
         4. When using the I/O specific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O
            registers as data space using LD and ST instructions, 0x20 must be added to these addresses. The ATmega328P is a
            complex microcontroller with more peripheral units than can be supported within the 64 location reserved in Opcode for
            the IN and OUT instructions. For the extended I/O space from 0x60 - 0xFF in SRAM, only the ST/STS/STD and
            LD/LDS/LDD instructions can be used.
                                                                                                     ATA6614Q [DATASHEET]           297
                                                                                                               9240I–AUTO–03/16


5.30     Register Summary (Continued)
  Address        Name        Bit 7        Bit 6      Bit 5       Bit 4           Bit 3         Bit 2    Bit 1     Bit 0       Page
    (0x69)       EICRA         –           –          –             –           ISC11         ISC10    ISC01     ISC00          78
    (0x68)       PCICR         –           –          –             –             –           PCIE2    PCIE1     PCIE0
    (0x67)     Reserved        –           –          –             –             –             –        –          –
    (0x66)      OSCCAL                                       Oscillator calibration register                                    57
    (0x65)     Reserved        –           –          –             –             –             –        –          –
    (0x64)        PRR       PRTWI       PRTIM2     PRTIM0           –         PRTIM1          PRSPI  PRUSART0   PRADC           60
    (0x63)     Reserved        –           –          –             –             –             –        –          –
    (0x62)     Reserved        –           –          –             –             –             –        –          –
    (0x61)       CLKPR     CLKPCE          –          –             –         CLKPS3        CLKPS2    CLKPS1    CLKPS0          57
    (0x60)     WDTCSR        WDIF         WDIE      WDP3        WDCE             WDE          WDP2     WDP1      WDP0           71
 0x3F (0x5F)     SREG          I           T          H            S              V             N        Z          C           34
 0x3E (0x5E)      SPH          –           –          –             –             –          (SP10)     SP9        SP8          37
 0x3D (0x5D)      SPL        SP7          SP6        SP5          SP4            SP3           SP2      SP1        SP0          37
 0x3C (0x5C)   Reserved        –           –          –             –             –             –        –          –
 0x3B (0x5B)   Reserved        –           –          –             –             –             –        –          –
 0x3A (0x5A)   Reserved        –           –          –             –             –             –        –          –
 0x39 (0x59)   Reserved        –           –          –             –             –             –        –          –
 0x38 (0x58)   Reserved        –           –          –             –             –             –        –          –
 0x37 (0x57)   SPMCSR       SPMIE      (RWWSB)        –       (RWWSRE)        BLBSET         PGWRT    PGERS   SELFPRGEN        261
 0x36 (0x56)   Reserved        –           –          –             –             –             –        –          –
 0x35 (0x55)    MCUCR          –         BODS       BODSE        PUD              –             –      IVSEL      IVCE       62/76/96
 0x34 (0x54)    MCUSR          –           –          –             –          WDRF           BORF    EXTRF      PORF           71
 0x33 (0x53)     SMCR          –           –          –             –            SM2           SM1      SM0        SE           59
 0x32 (0x52)   Reserved        –           –          –             –             –             –        –          –
 0x31 (0x51)   Reserved        –           –          –             –             –             –        –          –
 0x30 (0x50)     ACSR        ACD         ACBG        ACO          ACI            ACIE          ACIC    ACIS1     ACIS0         224
 0x2F (0x4F)   Reserved        –           –          –             –             –             –        –          –
 0x2E (0x4E)     SPDR                                              SPI Data Register                                           164
 0x2D (0x4D)     SPSR        SPIF        WCOL         –             –             –             –        –       SPI2X         164
 0x2C (0x4C)     SPCR        SPIE         SPE       DORD        MSTR            CPOL          CPHA     SPR1      SPR0          163
 0x2B (0x4B)    GPIOR2                                      General purpose I/O register 2                                      47
 0x2A (0x4A)    GPIOR1                                      General purpose I/O register 1                                      47
 0x29 (0x49)   Reserved        –           –          –             –             –             –        –          –
 0x28 (0x48)    OCR0B                                  Timer/Counter0 output compare register B
 0x27 (0x47)    OCR0A                                  Timer/Counter0 output compare register A
 0x26 (0x46)     TCNT0                                          Timer/Counter0 (8-bit)
 0x25 (0x45)    TCCR0B      FOC0A        FOC0B        –             –         WGM02            CS02     CS01      CS00
 0x24 (0x44)    TCCR0A     COM0A1       COM0A0     COM0B1      COM0B0             –             –     WGM01     WGM00
Notes:    1. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory
             addresses should never be written.
          2. I/O registers within the address range 0x00 - 0x1F are directly bit-accessible using the SBI and CBI instructions. In these
             registers, the value of single bits can be checked by using the SBIS and SBIC instructions.
          3. Some of the status flags are cleared by writing a logical one to them. Note that, unlike most other AVR®s, the CBI and
             SBI instructions will only operate on the specified bit, and can therefore be used on registers containing such status
             flags. The CBI and SBI instructions work with registers 0x00 to 0x1F only.
          4. When using the I/O specific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O
             registers as data space using LD and ST instructions, 0x20 must be added to these addresses. The ATmega328P is a
             complex microcontroller with more peripheral units than can be supported within the 64 location reserved in Opcode for
             the IN and OUT instructions. For the extended I/O space from 0x60 - 0xFF in SRAM, only the ST/STS/STD and
             LD/LDS/LDD instructions can be used.
298      ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


5.30     Register Summary (Continued)
   Address       Name        Bit 7       Bit 6       Bit 5        Bit 4        Bit 3         Bit 2    Bit 1     Bit 0         Page
 0x23 (0x43)    GTCCR        TSM           –           –           –            –             –     PSRASY   PSRSYNC         138/156
 0x22 (0x42)    EEARH                                    (EEPROM address register high byte)                                    43
 0x21 (0x41)    EEARL                                      EEPROM address register low byte                                     43
 0x20 (0x40)     EEDR                                           EEPROM data register                                            44
 0x1F (0x3F)     EECR          –           –        EEPM1       EEPM0         EERIE       EEMPE      EEPE      EERE             44
 0x1E (0x3E)    GPIOR0                                       General purpose I/O register 0                                     47
 0x1D (0x3D)    EIMSK          –           –           –           –            –             –       INT1      INT0            79
 0x1C (0x3C)      EIFR         –           –           –           –            –             –      INTF1     INTF0            79
 0x1B (0x3B)     PCIFR         –           –           –           –            –           PCIF2    PCIF1     PCIF0
 0x1A (0x3A)   Reserved        –           –           –           –            –             –         –         –
 0x19 (0x39)   Reserved        –           –           –           –            –             –         –         –
 0x18 (0x38)   Reserved        –           –           –           –            –             –         –         –
 0x17 (0x37)     TIFR2         –           –           –           –            –          OCF2B     OCF2A     TOV2            155
 0x16 (0x36)     TIFR1         –           –         ICF1          –            –          OCF1B     OCF1A     TOV1            136
 0x15 (0x35)     TIFR0         –           –           –           –            –          OCF0B     OCF0A     TOV0
 0x14 (0x34)   Reserved        –           –           –           –            –             –         –         –
 0x13 (0x33)   Reserved        –           –           –           –            –             –         –         –
 0x12 (0x32)   Reserved        –           –           –           –            –             –         –         –
 0x11 (0x31)   Reserved        –           –           –           –            –             –         –         –
 0x10 (0x30)   Reserved        –           –           –           –            –             –         –         –
 0x0F (0x2F)   Reserved        –           –           –           –            –             –         –         –
 0x0E (0x2E)   Reserved        –           –           –           –            –             –         –         –
 0x0D (0x2D)   Reserved        –           –           –           –            –             –         –         –
 0x0C (0x2C)   Reserved        –           –           –           –            –             –         –         –
 0x0B (0x2B)    PORTD      PORTD7      PORTD6      PORTD5      PORTD4       PORTD3        PORTD2    PORTD1    PORTD0            97
 0x0A (0x2A)     DDRD        DDD7       DDD6        DDD5         DDD4         DDD3          DDD2     DDD1      DDD0             97
 0x09 (0x29)     PIND       PIND7       PIND6       PIND5        PIND4        PIND3        PIND2     PIND1     PIND0            97
 0x08 (0x28)    PORTC          –       PORTC6      PORTC5      PORTC4       PORTC3        PORTC2    PORTC1    PORTC0            97
 0x07 (0x27)     DDRC          –        DDC6         DDC5        DDC4         DDC3          DDC2     DDC1      DDC0             97
 0x06 (0x26)     PINC          –        PINC6       PINC5        PINC4        PINC3        PINC2     PINC1     PINC0            97
 0x05 (0x25)    PORTB      PORTB7      PORTB6      PORTB5      PORTB4       PORTB3        PORTB2    PORTB1    PORTB0            96
 0x04 (0x24)     DDRB        DDB7        DDB6        DDB5        DDB4         DDB3          DDB2     DDB1      DDB0             96
 0x03 (0x23)      PINB      PINB7       PINB6       PINB5        PINB4        PINB3         PINB2    PINB1     PINB0            97
 0x02 (0x22)   Reserved        –           –           –           –            –             –         –         –
 0x01 (0x21)   Reserved        –           –           –           –            –             –         –         –
  0x0 (0x20)   Reserved        –           –           –           –            –             –         –         –
Notes:    1. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory
             addresses should never be written.
          2. I/O registers within the address range 0x00 - 0x1F are directly bit-accessible using the SBI and CBI instructions. In these
             registers, the value of single bits can be checked by using the SBIS and SBIC instructions.
          3. Some of the status flags are cleared by writing a logical one to them. Note that, unlike most other AVR®s, the CBI and
             SBI instructions will only operate on the specified bit, and can therefore be used on registers containing such status
             flags. The CBI and SBI instructions work with registers 0x00 to 0x1F only.
          4. When using the I/O specific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O
             registers as data space using LD and ST instructions, 0x20 must be added to these addresses. The ATmega328P is a
             complex microcontroller with more peripheral units than can be supported within the 64 location reserved in Opcode for
             the IN and OUT instructions. For the extended I/O space from 0x60 - 0xFF in SRAM, only the ST/STS/STD and
             LD/LDS/LDD instructions can be used.
                                                                                                   ATA6614Q [DATASHEET]              299
                                                                                                              9240I–AUTO–03/16


5.31       Instruction Set Summary
 Mnemonics         Operands                      Description                          Operation             Flags   #Clocks
Arithmetic and Logic Instructions
      ADD            Rd, Rr                   Add two registers                     Rd  Rd + Rr         Z,C,N,V,H     1
      ADC            Rd, Rr             Add with carry two registers              Rd  Rd + Rr + C       Z,C,N,V,H     1
     ADIW            Rdl,K                 Add immediate to word                Rdh:Rdl  Rdh:Rdl + K    Z,C,N,V,S     2
      SUB            Rd, Rr                Subtract two registers                    Rd  Rd - Rr        Z,C,N,V,H     1
      SUBI           Rd, K             Subtract constant from register               Rd  Rd - K         Z,C,N,V,H     1
      SBC            Rd, Rr           Subtract with carry two registers            Rd  Rd - Rr - C      Z,C,N,V,H     1
      SBCI           Rd, K         Subtract with carry constant from reg.          Rd  Rd - K - C       Z,C,N,V,H     1
     SBIW            Rdl,K             Subtract immediate from word             Rdh:Rdl  Rdh:Rdl - K    Z,C,N,V,S     2
      AND            Rd, Rr                Logical AND registers                     Rd Rd  Rr           Z,N,V      1
      ANDI           Rd, K           Logical AND register and constant               Rd  Rd K            Z,N,V      1
       OR            Rd, Rr                 Logical OR registers                     Rd  Rd v Rr           Z,N,V      1
       ORI           Rd, K            Logical OR register and constant               Rd Rd v K            Z,N,V      1
      EOR            Rd, Rr                Exclusive OR registers                   Rd  Rd  Rr            Z,N,V      1
      COM              Rd                    One’s complement                      Rd  0xFF  Rd         Z,C,N,V      1
      NEG              Rd                     Two’s complement                     Rd  0x00  Rd        Z,C,N,V,H     1
      SBR            Rd,K                    Set Bit(s) in register                  Rd  Rd v K            Z,N,V      1
      CBR            Rd,K                  Clear Bit(s) in register              Rd  Rd  (0xFF - K)       Z,N,V      1
       INC             Rd                          Increment                         Rd  Rd + 1            Z,N,V      1
      DEC              Rd                          Decrement                         Rd  Rd  1            Z,N,V      1
       TST             Rd                  Test for zero or minus                   Rd  Rd  Rd            Z,N,V      1
      CLR              Rd                        Clear register                     Rd  Rd  Rd            Z,N,V      1
      SER              Rd                         Set register                        Rd  0xFF             None       1
      MUL            Rd, Rr                   Multiply unsigned                    R1:R0  Rd x Rr           Z,C       2
     MULS            Rd, Rr                     Multiply signed                    R1:R0  Rd x Rr           Z,C       2
    MULSU            Rd, Rr            Multiply signed with unsigned               R1:R0  Rd x Rr           Z,C       2
     FMUL            Rd, Rr             Fractional multiply unsigned           R1:R0  (Rd x Rr) << 1        Z,C       2
    FMULS            Rd, Rr              Fractional multiply signed            R1:R0  (Rd x Rr) << 1        Z,C       2
   FMULSU            Rd, Rr       Fractional multiply signed with unsigned     R1:R0  (Rd x Rr) << 1        Z,C       2
Branch Instructions
     RJMP               k                        Relative jump                     PC PC + k + 1          None       2
      IJMP                                   Indirect jump to (Z)                       PC  Z              None       2
      JMP               k                         Direct jump                           PC k              None       3
    RCALL               k                 Relative subroutine call                 PC  PC + k + 1          None       3
     ICALL                                    Indirect call to (Z)                      PC  Z              None       3
      CALL              k                   Direct subroutine call                      PC  k              None       4
      RET                                     Subroutine return                      PC  STACK             None       4
      RETI                                      Interrupt return                     PC  STACK                I       4
     CPSE            Rd,Rr                 Compare, skip if equal          if (Rd = Rr) PC PC + 2 or 3    None     1/2/3
        CP           Rd,Rr                          Compare                             Rd  Rr          Z, N,V,C,H    1
      CPC            Rd,Rr                   Compare with carry                       Rd  Rr  C        Z, N,V,C,H    1
       CPI           Rd,K            Compare register with immediate                    Rd  K           Z, N,V,C,H    1
     SBRC             Rr, b             Skip if Bit in register cleared    if (Rr(b)=0) PC  PC + 2 or 3    None     1/2/3
     SBRS             Rr, b              Skip if Bit in register is set    if (Rr(b)=1) PC  PC + 2 or 3    None     1/2/3
      SBIC            P, b            Skip if Bit in I/O register cleared   if (P(b)=0) PC  PC + 2 or 3    None     1/2/3
      SBIS            P, b             Skip if Bit in I/O register is set   if (P(b)=1) PC  PC + 2 or 3    None     1/2/3
300        ATA6614Q [DATASHEET]
           9240I–AUTO–03/16


5.31      Instruction Set Summary (Continued)
 Mnemonics          Operands             Description                                Operation                Flags      #Clocks
     BRBS               s, k       Branch if status flag set     if (SREG(s) = 1) then PCPC+k + 1           None         1/2
     BRBC               s, k    Branch if status flag cleared    if (SREG(s) = 0) then PCPC+k + 1           None         1/2
     BREQ                 k             Branch if equal               if (Z = 1) then PC  PC + k + 1        None         1/2
     BRNE                 k           Branch if not equal             if (Z = 0) then PC  PC + k + 1        None         1/2
     BRCS                 k            Branch if carry set           if (C = 1) then PC  PC + k + 1         None         1/2
     BRCC                 k        Branch if carry cleared           if (C = 0) then PC  PC + k + 1         None         1/2
     BRSH                 k       Branch if same or higher           if (C = 0) then PC  PC + k + 1         None         1/2
     BRLO                 k             Branch if lower              if (C = 1) then PC  PC + k + 1         None         1/2
     BRMI                 k             Branch if minus              if (N = 1) then PC  PC + k + 1         None         1/2
     BRPL                 k              Branch if plus              if (N = 0) then PC  PC + k + 1         None         1/2
     BRGE                 k   Branch if greater or equal, signed  if (N  V= 0) then PC  PC + k + 1         None         1/2
     BRLT                 k    Branch if less than zero, signed   if (N  V= 1) then PC  PC + k + 1         None         1/2
     BRHS                 k      Branch if half carry flag set       if (H = 1) then PC  PC + k + 1         None         1/2
     BRHC                 k    Branch if half carry flag cleared     if (H = 0) then PC  PC + k + 1         None         1/2
     BRTS                 k           Branch if T flag set           if (T = 1) then PC  PC + k + 1         None         1/2
     BRTC                 k        Branch if T flag cleared           if (T = 0) then PC  PC + k + 1        None         1/2
     BRVS                 k     Branch if overflow flag is set       if (V = 1) then PC  PC + k + 1         None         1/2
     BRVC                 k   Branch if overflow flag is cleared     if (V = 0) then PC  PC + k + 1         None         1/2
     BRIE                 k      Branch if interrupt enabled          if ( I = 1) then PC  PC + k + 1       None         1/2
     BRID                 k      Branch if interrupt disabled         if ( I = 0) then PC  PC + k + 1       None         1/2
Bit and Bit-test Instructions
      SBI               P,b         Set Bit in I/O register                        I/O(P,b)  1              None          2
      CBI               P,b        Clear Bit in I/O register                       I/O(P,b)  0              None          2
      LSL               Rd              Logical shift left              Rd(n+1)  Rd(n), Rd(0)  0          Z,C,N,V        1
      LSR               Rd             Logical shift right              Rd(n)  Rd(n+1), Rd(7)  0          Z,C,N,V        1
      ROL               Rd        Rotate left through carry      Rd(0)C,Rd(n+1) Rd(n),CRd(7)             Z,C,N,V        1
      ROR               Rd        Rotate right through carry     Rd(7)C,Rd(n) Rd(n+1),CRd(0)             Z,C,N,V        1
      ASR               Rd           Arithmetic shift right                Rd(n)  Rd(n+1), n=0..6          Z,C,N,V        1
     SWAP               Rd               Swap nibbles            Rd(3..0)Rd(7..4),Rd(7..4)Rd(3..0)         None          1
     BSET                 s                 Flag set                              SREG(s)  1              SREG(s)         1
     BCLR                 s                Flag clear                             SREG(s)  0              SREG(s)         1
      BST              Rr, b     Bit store from register to T                        T  Rr(b)                 T           1
      BLD              Rd, b      Bit load from T to register                       Rd(b)  T                None          1
      SEC                                  Set carry                                   C1                     C           1
      CLC                                 Clear carry                                  C0                     C           1
      SEN                              Set negative flag                               N1                     N           1
      CLN                             Clear negative flag                              N0                     N           1
      SEZ                                Set zero flag                                 Z1                     Z           1
      CLZ                               Clear zero flag                                Z0                     Z           1
      SEI                          Global interrupt enable                             I1                      I          1
      CLI                          Global interrupt disable                            I 0                    I          1
      SES                             Set signed test flag                             S1                     S           1
      CLS                           Clear signed test flag                             S0                     S           1
      SEV                      Set twos complement overflow.                           V1                     V           1
      CLV                     Clear twos complement overflow                           V0                     V           1
      SET                               Set T in SREG                                  T1                     T           1
                                                                                            ATA6614Q [DATASHEET]             301
                                                                                                       9240I–AUTO–03/16


5.31     Instruction Set Summary (Continued)
 Mnemonics         Operands              Description                           Operation                 Flags #Clocks
     CLT                               Clear T in SREG                            T0                      T      1
     SEH                         Set half carry flag in SREG                     H1                       H      1
     CLH                        Clear half carry flag in SREG                    H0                       H      1
Data Transfer Instructions
    MOV             Rd, Rr         Move between registers                       Rd  Rr                  None     1
   MOVW             Rd, Rr            Copy register word                 Rd+1:Rd  Rr+1:Rr               None     1
     LDI             Rd, K             Load immediate                           Rd  K                   None     1
      LD             Rd, X               Load indirect                         Rd  (X)                  None     2
      LD            Rd, X+        Load indirect and post-inc.            Rd  (X), X  X + 1             None     2
      LD            Rd, - X       Load indirect and pre-dec.             X  X - 1, Rd  (X)             None     2
      LD             Rd, Y               Load indirect                         Rd  (Y)                  None     2
      LD            Rd, Y+        Load indirect and post-inc.            Rd  (Y), Y  Y + 1             None     2
      LD            Rd, - Y       Load indirect and pre-dec.             Y  Y - 1, Rd  (Y)             None     2
     LDD            Rd,Y+q     Load indirect with displacement               Rd  (Y + q)                None     2
      LD             Rd, Z               Load indirect                         Rd  (Z)                  None     2
      LD            Rd, Z+        Load indirect and post-inc.             Rd  (Z), Z  Z+1              None     2
      LD             Rd, -Z       Load indirect and pre-dec.             Z  Z - 1, Rd  (Z)             None     2
     LDD            Rd, Z+q    Load indirect with displacement               Rd  (Z + q)                None     2
     LDS              Rd, k        Load direct from SRAM                       Rd  (k)                  None     2
      ST              X, Rr              Store indirect                         (X) Rr                 None     2
      ST             X+, Rr      Store indirect and post-inc.            (X) Rr, X  X + 1             None     2
      ST            - X, Rr       Store indirect and pre-dec.            X  X - 1, (X)  Rr             None     2
      ST              Y, Rr              Store indirect                         (Y)  Rr                 None     2
      ST             Y+, Rr      Store indirect and post-inc.            (Y)  Rr, Y  Y + 1             None     2
      ST             - Y, Rr      Store indirect and pre-dec.            Y  Y - 1, (Y)  Rr             None     2
     STD            Y+q,Rr     Store indirect with displacement              (Y + q)  Rr                None     2
      ST              Z, Rr              Store indirect                         (Z)  Rr                 None     2
      ST             Z+, Rr      Store indirect and post-inc.            (Z)  Rr, Z  Z + 1             None     2
      ST             -Z, Rr       Store indirect and pre-dec.             Z  Z - 1, (Z)  Rr            None     2
     STD            Z+q,Rr     Store indirect with displacement              (Z + q)  Rr                None     2
     STS              k, Rr          Store direct to SRAM                       (k)  Rr                 None     2
     LPM                            Load program memory                        R0  (Z)                  None     3
     LPM             Rd, Z          Load program memory                        Rd  (Z)                  None     3
     LPM            Rd, Z+   Load program memory and post-inc             Rd  (Z), Z  Z+1              None     3
    SPM                            Store program memory                      (Z)  R1:R0                 None     -
      IN             Rd, P                   In port                             Rd  P                  None     1
     OUT              P, Rr                Out port                              P  Rr                  None     1
    PUSH               Rr           Push register on stack                   STACK  Rr                  None     2
     POP               Rd          Pop register from stack                   Rd  STACK                  None     2
MCU Control Instructions
    NOP                                  No operation                                                    None     1
   SLEEP                                     Sleep              (see specific descr. for Sleep function) None     1
    WDR                                 Watchdog reset            (see specific descr. for WDR/timer)    None     1
   BREAK                                     Break                     For On-chip Debug Only            None    N/A
302      ATA6614Q [DATASHEET]
         9240I–AUTO–03/16


6.   Application
     Figure 6-1. Typical LIN Slave Application
                                                                                                                         C1
                                                                                                                         100nF
                                PB4 PB3
                                    48   47   46   45    44    43    42    41     40       39    38       37
                                     PB4   PB3   PB2   PB1   PB0   PD7   PD6   PD5    PB7      PB6
                                                                                                     MCUVCC
                                                                                                               GND2
                     PB5 1                                                                                                   36
             100nF            PB5                                                                             MCUVCC                                      C2
                          2                                                                                                  35
                              MCUAVCC                                                                                 GND1                                100nF
                          3                                                                                                  34                                                              220pF
                              ADC6                                                                                     PD4
                          4                                                                                                  33
                              AREF                                                                                     PD3                                                                           LIN
                          5                                                                                                  32
                              GND4                                                                                     LIN
                          6                               Atmel                                                              31
                              ADC7                                                                                    GND
                          7                                                                                                  30
                              PC0                        ATA6614Q                                                 WAKE
                          8                                                                                                  29
                              PC1                                                                                NTRIG
                          9                                                                                                  28
                              PC2                                                                                       EN                                                                       VBAT
                         10                                                                                                  27
                              PC3                                                                                       VS
                         11                                                                                                  26
                              PC4                                                                                     VCC                                 PVCC
                         12                                                                                                  25                                                                  GND
                                                                                      WD_OSC
                              PC5                                                                                     PVCC
                                     PC6   PD0   PD1   PD2   RXD   INH   TDX   NRES            TM    MODE     KL_15
                                                                                                                                                                           +
                                    13   14   15   16    17    18    19    20     21       22    23       24
                                                                                                                                                           100nF               22μF
                                                                                                                                              +
                                                                                                                             100nF    100nF       10μF
                                    PC6
                                                                          10kΩ
                                                                                                                      47kΩ
                                                                                                                                                                                                 KL_15
                                                        INH                                                                                                      1
                                                                                                                                     MODE*          PB4                               PVCC
                                                                         51kΩ                                 10kΩ*                                 PB5                               PB3
                                                                                                                                                    PC6
                                                                                                                                                                     ISP
                     * The MODE pin can be connected directly to GND, if it is not needed to disable the Watchdog
     Note:           All open pins of the SiP can be used for application-specific purposes.
                     AVR®: Internal clock, no ADC application, TXD, RXD, NRES, EN and NTRIG connected for LIN slave. The
                     connection between the LIN-SBC and the AVR requires the software being programmed correspondingly.
                     SBC: LIN slave operation with watchdog, 5V regulator and KL15 wake up
                     RF emissions: Best results for RF emissions will be achieved by connecting the blocking capacitors of the
                     microcontroller supply (C1 and C2) between the microcontroller pins and the GND/PVCC line. See also Figure
                     6-1.
                                                                                                                                                           ATA6614Q [DATASHEET]                            303
                                                                                                                                                                                9240I–AUTO–03/16


      Figure 6-2. Typical LIN Master Application
                                                                                                                                                                      1
                                                                                                                                                         PB4                       PVCC
                                           22pF                          22pF                                                                            PB5                       PB3
                                                                   XTAL                                                  C1                              PC6
                                                                                                                         100nF                                            ISP
                                PB4 PB3
                                    48   47   46   45    44    43    42    41     40       39    38       37
                                     PB4   PB3   PB2   PB1   PB0   PD7   PD6   PD5    PB7      PB6
                                                                                                     MCUVCC
                                                                                                               GND2
                   PB5    1                                                                                                  36
           100nF              PB5                                                                             MCUVCC                           C2
                          2                                                                                                  35
                              MCUAVCC                                                                                 GND1                     100nF
                          3                                                                                                  34                                                 560pF
                              ADC6                                                                                     PD4
                          4                                                                                                  33
                              AREF                                                                                     PD3                                                         LIN
                          5                                                                                                  32
                              GND4                                                                                     LIN
                          6                                   Atmel                                                          31
                              ADC7                                                                                    GND                       2.7kΩ                                     WAKE
                          7                                  ATA6614Q                                                        30
                              PC0                                                                                 WAKE
                          8                                                                                                  29
                              PC1                                                                                NTRIG
                          9                                                                                                  28                        10kΩ
                              PC2                                                                                       EN                                                        VBAT
                         10                                                                                                  27
                              PC3                                                                                       VS
                         11                                                                                                  26
                              PC4                                                                                     VCC                      PVCC
                         12                                                                                                  25                                                    GND
                                                                                      WD_OSC
                              PC5                                                                                     PVCC
                                     PC6   PD0   PD1   PD2   RXD   INH   TDX   NRES            TM    MODE     KL_15
                                                                                                                                                                      1kΩ
                                                                                                                                      +                   +
                                    13   14   15   16    17    18    19    20     21       22    23       24                 100nF        10μF 100nF           22μF
                                                                                           51kΩ
                                                                                                                              MODE*
                                    PC6                                               10kΩ                    10kΩ*
              * The MODE pin can be connected directly to GND, if it is not needed to disable the Watchdog
      Note:           All open pins of the SiP can be used for application-specific purposes.
                      AVR®: TXD, RXD, NRES and EN connected for LIN master. The connection between the LIN-SBC and the
                      AVR requires the software being programmed correspondingly. Analog digital converter not active; system
                      clock from external crystal.
                      LIN-SBC: Master application with 5V regulator and watchdog, 1k Master resistance connected via diode to
                      VBAT, local wake up via pin WAKE.
                      RF emissions: Best results for RF emissions will be achieved by connecting the blocking capacitors of the
                      microcontroller supply (C1 and C2) between the microcontroller pins and the GND/PVCC line. See also Figure
                      6-2.
304   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


Figure 6-3. Typical LIN Master Application
            LIN Master Pull-up Switched Off during Sleep Mode
                                                                                                                                                                 1
                                                                                                                                                    PB4                         PVCC
                                    22pF                          22pF                                                                              PB5                         PB3
                                                            XTAL                                                  C1                                PC6
                                                                                                                  100nF                                              ISP
                         PB4 PB3
                             48   47   46   45    44    43    42    41     40       39    38       37
                              PB4   PB3   PB2   PB1   PB0   PD7   PD6   PD5    PB7      PB6
                                                                                              MCUVCC
                                                                                                        GND2
            PB5    1                                                                                                  36
    100nF              PB5                                                                             MCUVCC                             C2
                   2                                                                                                  35
                       MCUAVCC                                                                                 GND1                       100nF
                   3                                                                                                  34                                                    560pF
                       ADC6                                                                                     PD4                                              10kΩ
                   4                                                                                                  33
                       AREF                                                                                     PD3                                                             LIN
                   5                                                                                                  32
                       GND4                                                                                     LIN
                   6                                Atmel                                                             31
                       ADC7                                                                                    GND                         2.7kΩ                                       WAKE
                   7                                                                                                  30
                       PC0                        ATA6614Q                                                 WAKE
                   8                                                                                                  29
                       PC1                                                                                NTRIG
                   9                                                                                                  28                          10kΩ
                       PC2                                                                                       EN                                                            VBAT
                  10                                                                                                  27
                       PC3                                                                                       VS
                  11                                                                                                  26
                       PC4                                                                                     VCC                        PVCC
                  12                                                                                                  25                                                        GND
                                                                               WD_OSC
                       PC5                                                                                     PVCC
                              PC6   PD0   PD1   PD2   RXD   INH   TDX   NRES            TM    MODE     KL_15
                                                                                                                                                                 1kΩ
                                                                                                                                                     +
                             13   14   15   16    17    18    19    20     21       22    23       24
                                                                                                                                          100nF           22μF
                                                                                                                               +
                                                                                    51kΩ
                                                                                                                      100nF        10μF
                             PC6                                                                                       MODE*
                                                                               10kΩ                    10kΩ*
             * The MODE pin can be connected directly to GND, if it is not needed to disable the Watchdog
Note:        All open pins of the SiP can be used for application-specific purposes.
             AVR®: TXD, RXD, NRES and EN connected for LIN master. The connection between the LIN-SBC and the
             AVR requires the software being programmed correspondingly. Analog digital converter not active; system
             clock from external crystal.
             LIN-SBC: Master application with 5V regulator and watchdog, 1k Master resistance connected via diode and
             INH output to VBAT, local wake up via pin WAKE.
             RF emissions: Best results for RF emissions will be achieved by connecting the blocking capacitors of the
             microcontroller supply (C1 and C2) between the microcontroller pins and the GND/PVCC line. See also Figure
             6-3.
                                                                                                                                                    ATA6614Q [DATASHEET]                      305
                                                                                                                                                                       9240I–AUTO–03/16


      Figure 6-4. LIN Slave Application with Minimum External Components
                                                                                                                       C1
                                                                                                                       100nF
                                PB4 PB3
                                    48   47   46   45    44    43    42    41     40       39    38       37
                                     PB4   PB3   PB2   PB1   PB0   PD7   PD6   PD5    PB7      PB6
                                                                                                     MCUVCC
                                                                                                               GND2
                      PB5 1                                                                                                  36
              100nF           PB5                                                                             MCUVCC                                  C2
                          2                                                                                                  35
                              MCUAVCC                                                                                 GND1                            100nF                               220pF
                          3                                                                                                  34
                              ADC6                                                                                     PD4
                          4                                                                                                  33
                              AREF                                                                                     PD3                                                                        LIN
                          5                                                                                                  32
                              GND4                                                                                     LIN
                          6                                Atmel                                                             31
                              ADC7                                                                                    GND
                          7                              ATA6614Q                                                            30
                              PC0                                                                                 WAKE
                          8                                                                                                  29
                              PC1                                                                                NTRIG
                          9                                                                                                  28
                              PC2                                                                                       EN                                                                    VBAT
                         10                                                                                                  27
                              PC3                                                                                       VS
                         11                                                                                                  26
                              PC4                                                                                     VCC                             PVCC
                         12                                                                                                  25                                                               GND
                                                                                      WD_OSC
                              PC5                                                                                     PVCC
                                     PC6   PD0   PD1   PD2   RXD   INH   TDX   NRES            TM    MODE     KL_15
                                                                                                                                                                        +
                                    13   14   15   16    17    18    19    20     21       22    23       24
                                                                                                                                                        100nF               22μF
                                                                                                                                          +
                                                                                                                                  100nF       10μF
                                                                                      10kΩ
                                    PC6
                                                                                                                                                              1
                                                                                                                                                PB4                                PVCC
                                                                                                                                                PB5                                PB3
                                                                                                                                                PC6
                                                                                                                                                                  ISP
      Note:           All open pins of the SiP can be used for application-specific purposes.
                      AVR®: Internal clock, no ADC application, TXD, RXD, NRES and EN connected for LIN slave. The connection
                      between the LIN-SBC and the AVR requires the software being programmed correspondingly.
                      SBC: LIN slave operation with 5V regulator, no watchdog, no local wake-up.
                      RF emissions: Best results for RF emissions will be achieved by connecting the blocking capacitors of the
                      microcontroller supply (C1 and C2) between the microcontroller pins and the GND/PVCC line. See also Figure
                      6-4.
306   ATA6614Q [DATASHEET]
      9240I–AUTO–03/16


7.   Ordering Information
     Extended Type Number                               Program Memory                   Package                               MOQ
      ATA6614Q-PLQW-1                                       32kB flash                 QFN48, 77                          4,000 pieces
8.   Package Information
                                       Top View
                                          D
                              48
                      1
          PIN 1 ID                                                                       technical drawings
                                                            E
                                                                                         according to DIN
                                                                                         specifications
                                                                                       Dimensions in mm
                     12
                                       Side View            A1       A3   A
                                      Bottom View
                                          D2
                             13                       24
                                                        25
                     12
                                                                                       COMMON DIMENSIONS
                                                                E2                      (Unit of Measure = mm)
                                                                              Symbol    MIN     NOM           MAX       NOTE
                                                                                A       0.8      0.85         0.9
                         1                                                      A1       0      0.035         0.05
                                                           36
                     A                                                          A3      0.16     0.21         0.26
                              48                   37
                                               e                                D       6.9        7          7.1
                                                                                D2      5.5       5.6         5.7
                                                                                E       6.9        7          7.1
                         A (10:1)                                               E2      5.5       5.6         5.7
                                               L                                L       0.35      0.4         0.45
                                                                                b       0.2      0.25         0.3
                                                                                e                 0.5
                                  b
                                                                                                                                       05/20/14
                                                   TITLE                                                GPC           DRAWING NO.         REV.
          Package Drawing Contact:                 Package: QFN_7x7_48L
          packagedrawings@atmel.com                Exposed pad 5.6x5.6                                               6.543-5188.03-4       1
                                                                                                   ATA6614Q [DATASHEET]                           307
                                                                                                                       9240I–AUTO–03/16


9.  Revision History
    Please note that the following page numbers referred to in this section refer to the specific revision mentioned, not to this
    document.
     Revision No.                      History
                                       Fixed typo to correct value to match with PPAP in Table 3-1 “Maximum Ratings of the
     9240I-AUTO-03/16
                                         SiP” on page 5
                                       Section 2 “Pin Configuration” on pages 3 to 4 updated
                                       Section 3 “Absolute Maximum Ratings” on pages 5 to 6 added
                                       Section 4.4.2 “Silent Mode” on page 12 updated
     9240H-AUTO-10/14
                                       Section 6 “Application” on pages 303 to 306 updated
                                       Section 7 “Ordering Information” on page 307 updated
                                       Section 8 “Package Information” on page 307 updated
                                       Section 8 “Ordering Information” on page 364 updated
     9240G-AUTO-11/12
                                       Set datasheet from Preliminary to Standard
                                       ATmega88P and ATmega168P references removed
     9240F-AUTO-10/12                  Section 4 “Absolute Maximum Ratings” on page 24 updated
                                       Section 6.1 “Features” on page 31 updated
     9240E-AUTO-07/12                  Section 4 “Absolute Maximum Ratings” on page 24 updated
     9240D-AUTO-06/12                  Section 6 “Microcontroller Block” on pages 31 to 359 updated
                                       Section 6.28.1 “Absolute Maximum Ratings” on page 340 changed
     9240C-AUTO-05/12
                                       Section 6.28.2 “DC Characteristics” on page 340 changed
                                       ATA6614P renamed to ATA6614Q on all pages
                                       General Features on page 1 changed
                                       Table 2-1 “Pin Description” on page 3 changed
     9240B-AUTO-02/12
                                       Section 3.4.6 “Unpowered Mode” on pages 17 to 18 changed
                                       Section 3.6 “Voltage Regulator” on page 21 changed
                                       Section 7 “Application” on page 456 added
308 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


10. Table of Contents
               General Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
               1.    Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
               2.    Pin Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
               3.    Absolute Maximum Ratings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
               4.    LIN System-basis-chip Block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
                  4.1    Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
                  4.2    Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
                  4.3    Functional Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
                  4.4    Modes of Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
                  4.5    Wake-up Scenarios from Silent or Sleep Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
                  4.6    Voltage Regulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
                  4.7    Watchdog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
                  4.8    Electrical Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
               5.    Microcontroller Block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
                  5.1    Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
                  5.2    Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
                  5.3    Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
                  5.4    Data Retention . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
                  5.5    About Code Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
                  5.6    AVR CPU Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
                  5.7    AVR Memories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
                  5.8    System Clock and Clock Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
                  5.9    Power Management and Sleep Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
                  5.10   System Control and Reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
                  5.11   Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
                  5.12   External Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
                  5.13   I/O-Ports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
                  5.14   8-bit Timer/Counter0 with PWM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
                  5.15   16-bit Timer/Counter1 with PWM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
                  5.16   Timer/Counter0 and Timer/Counter1 Prescalers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
                  5.17   8-bit Timer/Counter2 with PWM and Asynchronous Operation . . . . . . . . . . . . . . . . . . . . . 139
                  5.18   SPI – Serial Peripheral Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
                  5.19   USART0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
                  5.20   USART in SPI Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
                  5.21   2-wire Serial Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
                  5.22   Analog Comparator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
                  5.23   Analog-to-Digital Converter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
                  5.24   debugWIRE On-chip Debug System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
                  5.25   Self-programming the Flash, ATmega328P . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
                  5.26   Boot Loader Support – Read-while-write Self-programming . . . . . . . . . . . . . . . . . . . . . . . 250
                  5.27   Memory Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
                  5.28   Electrical Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
                  5.29   Typical Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
                  5.30   Register Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
                  5.31   Instruction Set Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
               6.    Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
               7.    Ordering Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
                                                                                                          ATA6614Q [DATASHEET]                                    309
                                                                                                                                9240I–AUTO–03/16


                     8.  Package Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
                     9.  Revision History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
                     10. Table of Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
310 ATA6614Q [DATASHEET]
    9240I–AUTO–03/16


                                                                                                                                             XXXXXX
Atmel Corporation              1600 Technology Drive, San Jose, CA 95110 USA                   T: (+1)(408) 441.0311          F: (+1)(408) 436.4200           |      www.atmel.com
© 2016 Atmel Corporation. / Rev.: 9240I–AUTO–03/16
Atmel®, Atmel logo and combinations thereof, Enabling Unlimited Possibilities®, AVR®, and others are registered trademarks or trademarks of Atmel Corporation in U.S.
and other countries. Other terms and product names may be trademarks of others.
DISCLAIMER: The information in this document is provided in connection with Atmel products. No license, express or implied, by estoppel or otherwise, to any intellectual property right
is granted by this document or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN THE ATMEL TERMS AND CONDITIONS OF SALES LOCATED ON THE
ATMEL WEBSITE, ATMEL ASSUMES NO LIABILITY WHATSOEVER AND DISCLAIMS ANY EXPRESS, IMPLIED OR STATUTORY WARRANTY RELATING TO ITS PRODUCTS
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. IN NO EVENT
SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR INCIDENTAL DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES
FOR LOSS AND PROFITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING OUT OF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Atmel makes no representations or warranties with respect to the accuracy or completeness of the contents of this
document and reserves the right to make changes to specifications and products descriptions at any time without notice. Atmel does not make any commitment to update the information
contained herein. Unless specifically provided otherwise, Atmel products are not suitable for, and shall not be used in, automotive applications. Atmel products are not intended,
authorized, or warranted for use as components in applications intended to support or sustain life.
SAFETY-CRITICAL, MILITARY, AND AUTOMOTIVE APPLICATIONS DISCLAIMER: Atmel products are not designed for and will not be used in connection with any applications where
the failure of such products would reasonably be expected to result in significant personal injury or death (“Safety-Critical Applications”) without an Atmel officer's specific written
consent. Safety-Critical Applications include, without limitation, life support devices and systems, equipment or systems for the operation of nuclear facilities and weapons systems.
Atmel products are not designed nor intended for use in military or aerospace applications or environments unless specifically designated by Atmel as military-grade. Atmel products are
not designed nor intended for use in automotive applications unless specifically designated by Atmel as automotive-grade.


Mouser Electronics
Authorized Distributor
Click to View Pricing, Inventory, Delivery & Lifecycle Information:
Microchip:
 ATA6614Q-PLQW ATA6614Q-PLQW-1
